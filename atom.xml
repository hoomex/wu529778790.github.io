<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神族九帝</title>
  <subtitle>永不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.newbug.xyz/"/>
  <updated>2017-04-19T09:30:12.422Z</updated>
  <id>http://blog.newbug.xyz/</id>
  
  <author>
    <name>wu529778790</name>
    <email>529778790@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js判断移动端是否安装app，若安装，则打开，未安装则跳转到下载页面</title>
    <link href="http://blog.newbug.xyz/2017/04/19/js%E5%88%A4%E6%96%AD%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85app%EF%BC%8C%E8%8B%A5%E5%AE%89%E8%A3%85%EF%BC%8C%E5%88%99%E6%89%93%E5%BC%80%EF%BC%8C%E6%9C%AA%E5%AE%89%E8%A3%85%E5%88%99%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%8B%E8%BD%BD%E9%A1%B5%E9%9D%A2/"/>
    <id>http://blog.newbug.xyz/2017/04/19/js判断移动端是否安装app，若安装，则打开，未安装则跳转到下载页面/</id>
    <published>2017-04-19T09:29:48.000Z</published>
    <updated>2017-04-19T09:30:12.422Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;initial-scale=1.0,user-scalable=no&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Js判定移动端是否安装app,若已安装，则打开，未安装则跳转到下载页面&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&amp;apos;apple-itunes-app&amp;apos; content=&amp;apos;app-id=1221201728&amp;apos;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:;&amp;quot; id=&amp;quot;openApp&amp;quot;&amp;gt;点击打开安装app&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    document.getElementById(&amp;apos;openApp&amp;apos;).onclick = function(e){

        if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i))
           {
            window.location.href = &amp;quot;com.baidu.tieba://&amp;quot;;//ios app协议(如：com.baidu.tieba://)
            window.setTimeout(function() {
                window.location.href = &amp;quot;https://itunes.apple.com/cn/app/id477927812&amp;quot;; //跳转到App store
            }, 2000)
           }
        if(navigator.userAgent.match(/android/i))
        {
            window.location.href = &amp;quot;com.baidu.tieba://app&amp;quot;;//android app协议(如：com.baidu.tieba://app)
            window.setTimeout(function() {
                window.location.href = &amp;quot;https://****.apk&amp;quot;;//android 下载地址
            }, 2000)    
        }
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>jquery知识点归纳--dom篇</title>
    <link href="http://blog.newbug.xyz/2017/04/18/jquery%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3-dom%E7%AF%87/"/>
    <id>http://blog.newbug.xyz/2017/04/18/jquery知识点归纳-dom篇/</id>
    <published>2017-04-18T06:00:01.000Z</published>
    <updated>2017-04-18T06:07:11.117Z</updated>
    
    <content type="html">&lt;p&gt;jquery——dom篇&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;创建节点和节点属性&quot;&gt;&lt;a href=&quot;#创建节点和节点属性&quot; class=&quot;headerlink&quot; title=&quot;创建节点和节点属性&quot;&gt;&lt;/a&gt;创建节点和节点属性&lt;/h2&gt;&lt;p&gt;通过JavaScript可以很方便的获取DOM节点，从而进行一系列的DOM操作。但实际上一般开发者都习惯性的先定义好HTML结构，但这样就非常不灵活了。&lt;br&gt;试想下这样的情况：如果我们通过AJAX获取到数据之后然后才能确定结构的话，这种情况就需要动态的处理节点了&lt;br&gt;流程中涉及的一点方法：&lt;br&gt;创建元素：document.createElement&lt;br&gt;设置属性：setAttribute&lt;br&gt;添加文本：innerHTML&lt;br&gt;加入文档：appendChild&lt;br&gt;jquery创建节点&lt;br&gt;$(“html结构”)就是$(“&lt;div&gt;&lt;/div&gt;“)／$(“&lt;div&gt;我是文本节点&lt;/div&gt;“)／$(“&lt;div id=&quot;test&quot; class=&quot;aaron&quot;&gt;我是文本节点&lt;/div&gt;“)&lt;/p&gt;
&lt;h2 id=&quot;dom节点的插入&quot;&gt;&lt;a href=&quot;#dom节点的插入&quot; class=&quot;headerlink&quot; title=&quot;dom节点的插入&quot;&gt;&lt;/a&gt;dom节点的插入&lt;/h2&gt;&lt;h3 id=&quot;append-和appendTo&quot;&gt;&lt;a href=&quot;#append-和appendTo&quot; class=&quot;headerlink&quot; title=&quot;append()和appendTo()&quot;&gt;&lt;/a&gt;append()和appendTo()&lt;/h3&gt;&lt;p&gt;动态创建的元素是不够的，它只是临时存放在内存中，最终我们需要放到页面文档并呈现出来。那么问题来了，怎么放到文档上？这里就涉及到一个位置关系，常见的就是把这个新创建的元素，当作页面某一个元素的子元素放到其内部。针对这样的处理，jQuery就定义2个操作的方法&lt;br&gt;append()前面是被插入的对象，后面是要在对象内插入的元素内容&lt;br&gt;appendTo()前面是要插入的元素内容，而后面是被插入的对象&lt;/p&gt;
&lt;p&gt;###　after()与before()&lt;/p&gt;
&lt;p&gt;before与after都是用来对相对选中元素外部增加相邻的兄弟节点&lt;br&gt;2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面&lt;br&gt;2个方法都支持多个参数传递after(div1,div2,….)&lt;/p&gt;
&lt;h3 id=&quot;prepend-与prependTo&quot;&gt;&lt;a href=&quot;#prepend-与prependTo&quot; class=&quot;headerlink&quot; title=&quot;prepend()与prependTo()&quot;&gt;&lt;/a&gt;prepend()与prependTo()&lt;/h3&gt;&lt;p&gt;.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append()).&lt;/p&gt;
&lt;p&gt;.prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同&lt;br&gt;对于.prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数&lt;/p&gt;
&lt;p&gt;而.prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。&lt;/p&gt;
&lt;h3 id=&quot;insertAfter-与insertBefore&quot;&gt;&lt;a href=&quot;#insertAfter-与insertBefore&quot; class=&quot;headerlink&quot; title=&quot;insertAfter()与insertBefore()&quot;&gt;&lt;/a&gt;insertAfter()与insertBefore()&lt;/h3&gt;&lt;p&gt;.before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面&lt;/p&gt;
&lt;p&gt;.after()和.insertAfter() &lt;/p&gt;
&lt;p&gt;实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面&lt;br&gt;before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理&lt;/p&gt;
&lt;h2 id=&quot;dom结点的删除&quot;&gt;&lt;a href=&quot;#dom结点的删除&quot; class=&quot;headerlink&quot; title=&quot;dom结点的删除&quot;&gt;&lt;/a&gt;dom结点的删除&lt;/h2&gt;&lt;h3 id=&quot;empty&quot;&gt;&lt;a href=&quot;#empty&quot; class=&quot;headerlink&quot; title=&quot;empty()&quot;&gt;&lt;/a&gt;empty()&lt;/h3&gt;&lt;p&gt;empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。&lt;/p&gt;
&lt;h3 id=&quot;remove&quot;&gt;&lt;a href=&quot;#remove&quot; class=&quot;headerlink&quot; title=&quot;remove()&quot;&gt;&lt;/a&gt;remove()&lt;/h3&gt;&lt;p&gt;remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。&lt;/p&gt;
&lt;h3 id=&quot;保留数据的删除操作detach&quot;&gt;&lt;a href=&quot;#保留数据的删除操作detach&quot; class=&quot;headerlink&quot; title=&quot;保留数据的删除操作detach()&quot;&gt;&lt;/a&gt;保留数据的删除操作detach()&lt;/h3&gt;&lt;p&gt;这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。&lt;/p&gt;
&lt;h2 id=&quot;DOM节点的复制与替换&quot;&gt;&lt;a href=&quot;#DOM节点的复制与替换&quot; class=&quot;headerlink&quot; title=&quot;DOM节点的复制与替换&quot;&gt;&lt;/a&gt;DOM节点的复制与替换&lt;/h2&gt;&lt;h3 id=&quot;clone&quot;&gt;&lt;a href=&quot;#clone&quot; class=&quot;headerlink&quot; title=&quot;clone()&quot;&gt;&lt;/a&gt;clone()&lt;/h3&gt;&lt;p&gt;.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。&lt;br&gt;clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了&lt;/p&gt;
&lt;h3 id=&quot;replaceWith-和replaceAll&quot;&gt;&lt;a href=&quot;#replaceWith-和replaceAll&quot; class=&quot;headerlink&quot; title=&quot;replaceWith()和replaceAll()&quot;&gt;&lt;/a&gt;replaceWith()和replaceAll()&lt;/h3&gt;&lt;p&gt;.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合&lt;br&gt;$(“p:eq(1)”).replaceWith(‘&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;‘)&lt;br&gt;$(‘&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;‘).replaceAll(‘p:eq(1)’)&lt;/p&gt;
&lt;h3 id=&quot;包裹wrap-方法&quot;&gt;&lt;a href=&quot;#包裹wrap-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrap()方法&quot;&gt;&lt;/a&gt;包裹wrap()方法&lt;/h3&gt;&lt;p&gt;.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构&lt;br&gt;.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。&lt;/p&gt;
&lt;h3 id=&quot;包裹wrapAll-方法&quot;&gt;&lt;a href=&quot;#包裹wrapAll-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrapAll()方法&quot;&gt;&lt;/a&gt;包裹wrapAll()方法&lt;/h3&gt;&lt;p&gt;.wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构&lt;br&gt;.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。&lt;/p&gt;
&lt;h3 id=&quot;包裹wrapInner-方法&quot;&gt;&lt;a href=&quot;#包裹wrapInner-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrapInner()方法&quot;&gt;&lt;/a&gt;包裹wrapInner()方法&lt;/h3&gt;&lt;p&gt;.wrapInner( wrappingElement )：给集合中匹配的元素的内部，增加包裹的HTML结构&lt;/p&gt;
&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;h3 id=&quot;children-方法&quot;&gt;&lt;a href=&quot;#children-方法&quot; class=&quot;headerlink&quot; title=&quot;children()方法&quot;&gt;&lt;/a&gt;children()方法&lt;/h3&gt;&lt;p&gt;代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。&lt;/p&gt;
&lt;h3 id=&quot;find-方法&quot;&gt;&lt;a href=&quot;#find-方法&quot; class=&quot;headerlink&quot; title=&quot;find()方法&quot;&gt;&lt;/a&gt;find()方法&lt;/h3&gt;&lt;p&gt;此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）&lt;/p&gt;
&lt;h3 id=&quot;parent-方法&quot;&gt;&lt;a href=&quot;#parent-方法&quot; class=&quot;headerlink&quot; title=&quot;parent()方法&quot;&gt;&lt;/a&gt;parent()方法&lt;/h3&gt;&lt;p&gt;parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象&lt;/p&gt;
&lt;h3 id=&quot;parents-方法&quot;&gt;&lt;a href=&quot;#parents-方法&quot; class=&quot;headerlink&quot; title=&quot;parents()方法&quot;&gt;&lt;/a&gt;parents()方法&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法&lt;br&gt;其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点&lt;/p&gt;
&lt;h3 id=&quot;closest-方法&quot;&gt;&lt;a href=&quot;#closest-方法&quot; class=&quot;headerlink&quot; title=&quot;closest()方法&quot;&gt;&lt;/a&gt;closest()方法&lt;/h3&gt;&lt;p&gt;从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素&lt;br&gt;起始位置不同：.closest开始于当前元素 .parents开始于父元素&lt;br&gt;遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合&lt;br&gt;结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象&lt;/p&gt;
&lt;h3 id=&quot;next&quot;&gt;&lt;a href=&quot;#next&quot; class=&quot;headerlink&quot; title=&quot;next()&quot;&gt;&lt;/a&gt;next()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法&lt;/p&gt;
&lt;h3 id=&quot;prev-方法&quot;&gt;&lt;a href=&quot;#prev-方法&quot; class=&quot;headerlink&quot; title=&quot;prev()方法&quot;&gt;&lt;/a&gt;prev()方法&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法&lt;/p&gt;
&lt;h3 id=&quot;siblings&quot;&gt;&lt;a href=&quot;#siblings&quot; class=&quot;headerlink&quot; title=&quot;siblings()&quot;&gt;&lt;/a&gt;siblings()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法&lt;/p&gt;
&lt;h3 id=&quot;add&quot;&gt;&lt;a href=&quot;#add&quot; class=&quot;headerlink&quot; title=&quot;add()&quot;&gt;&lt;/a&gt;add()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中&lt;/p&gt;
&lt;h3 id=&quot;each&quot;&gt;&lt;a href=&quot;#each&quot; class=&quot;headerlink&quot; title=&quot;each()&quot;&gt;&lt;/a&gt;each()&lt;/h3&gt;&lt;p&gt;.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://www.imooc.com/article/17456&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.imooc.com/article/17456&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;jquery——dom篇&lt;/p&gt;
    
    </summary>
    
    
      <category term="jquery" scheme="http://blog.newbug.xyz/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包面试题</title>
    <link href="http://blog.newbug.xyz/2017/04/18/JavaScript%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/18/JavaScript闭包面试题/</id>
    <published>2017-04-18T02:52:22.000Z</published>
    <updated>2017-04-18T05:48:15.061Z</updated>
    
    <content type="html">&lt;p&gt;这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;function fun(n, o) {
    console.log(o);
    return {
        fun: function(m){
            return fun(m, n)
        }
    }
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一道很经典的js闭包问题，其中嵌套了三层fun函数：&lt;br&gt;    //答案：&lt;br&gt;    //a: undefined,0,0,0&lt;br&gt;    //b: undefined,0,1,2&lt;br&gt;    //c: undefined,0,1,1&lt;br&gt;首先，在此之前需要了解的是，在JS中函数可以分为两种，具名函数（命名函数）和匿名函数。&lt;/p&gt;
&lt;p&gt;区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数&lt;br&gt;或是采用兼容IE的获取函数name方法来获取函数名称：&lt;br&gt;    /**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    * 获取指定函数的函数名称（用于兼容IE）
    * @param {Function} fun 任意函数
    */
function getFunctionName(fun) {
    if (fun.name !== undefined)
        return fun.name;
    var ret = fun.toString();
    ret = ret.substr(&amp;apos;function &amp;apos;.length);
    ret = ret.substr(0, ret.indexOf(&amp;apos;(&amp;apos;));
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;js有两种创建函数方式，一种是声明函数：&quot;&gt;&lt;a href=&quot;#js有两种创建函数方式，一种是声明函数：&quot; class=&quot;headerlink&quot; title=&quot;　js有两种创建函数方式，一种是声明函数：&quot;&gt;&lt;/a&gt;　js有两种创建函数方式，一种是声明函数：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function fn1(){}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;一种是创建匿名函数表达式：&quot;&gt;&lt;a href=&quot;#一种是创建匿名函数表达式：&quot; class=&quot;headerlink&quot; title=&quot;　一种是创建匿名函数表达式：&quot;&gt;&lt;/a&gt;　一种是创建匿名函数表达式：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var fn1=function (){}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意采用这种方法创建的函数为匿名函数，即没有函数name；&lt;br&gt;var fn1=function (){};&lt;br&gt;getFunctionName(fn1).length;//0&lt;/p&gt;
&lt;h3 id=&quot;创建具名函数表达式：&quot;&gt;&lt;a href=&quot;#创建具名函数表达式：&quot; class=&quot;headerlink&quot; title=&quot;　创建具名函数表达式：&quot;&gt;&lt;/a&gt;　创建具名函数表达式：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var fn1=function xxcanghai(){};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：具名函数表达式的函数名只能在创建函数内部使用&lt;/p&gt;
&lt;p&gt;即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用&lt;/p&gt;
&lt;p&gt;测试：&lt;br&gt;    var fn1=function xxcanghai(){&lt;br&gt;        console.log(“in:fn1&amp;lt;”,typeof fn1,”&amp;gt;xxcanghai:&amp;lt;”,typeof xxcanghai,”&amp;gt;”);&lt;br&gt;    };&lt;br&gt;    console.log(“out:fn1&amp;lt;”,typeof fn1,”&amp;gt;xxcanghai:&amp;lt;”,typeof xxcanghai,”&amp;gt;”);&lt;br&gt;    fn1();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//out:fn1&amp;lt; function &amp;gt;xxcanghai:&amp;lt; undefined &amp;gt;
//in:fn1&amp;lt; function &amp;gt;xxcanghai:&amp;lt; function &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。&lt;/p&gt;
&lt;h3 id=&quot;自执行函数&quot;&gt;&lt;a href=&quot;#自执行函数&quot; class=&quot;headerlink&quot; title=&quot;　自执行函数&quot;&gt;&lt;/a&gt;　自执行函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;(function(){alert(1);})();
(function fn1(){alert(1);})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自执行函数属于上述的“函数表达式”，规则相同&lt;/p&gt;
&lt;h3 id=&quot;其他创建函数的方法&quot;&gt;&lt;a href=&quot;#其他创建函数的方法&quot; class=&quot;headerlink&quot; title=&quot;　其他创建函数的方法&quot;&gt;&lt;/a&gt;　其他创建函数的方法&lt;/h3&gt;&lt;p&gt;当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 eval ， setTimeout ， setInterval 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开&lt;/p&gt;
&lt;p&gt;###　三个fun函数的关系是什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      //...
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。&lt;/p&gt;
&lt;p&gt;这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。&lt;/p&gt;
&lt;p&gt;注意：所有声明的匿名函数都是一个新函数。&lt;/p&gt;
&lt;h3 id=&quot;函数作用域链的问题&quot;&gt;&lt;a href=&quot;#函数作用域链的问题&quot; class=&quot;headerlink&quot; title=&quot;函数作用域链的问题&quot;&gt;&lt;/a&gt;函数作用域链的问题&lt;/h3&gt;&lt;p&gt;再说第三个fun函数之前需要先说下，在函数表达式内部能不能访问存放当前函数的变量&lt;/p&gt;
&lt;p&gt;测试1，对象内部的函数表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var o={
  fn:function (){
    console.log(fn);
  }
};
o.fn();//ERROR报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试2，非对象内部的函数表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fn=function (){
  console.log(fn);
};
fn();//function (){console.log(fn);};正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。&lt;/p&gt;
&lt;p&gt;原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。&lt;/p&gt;
&lt;p&gt;所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。&lt;/p&gt;
&lt;p&gt;所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。&lt;/p&gt;
&lt;h3 id=&quot;到底在调用哪个函数？&quot;&gt;&lt;a href=&quot;#到底在调用哪个函数？&quot; class=&quot;headerlink&quot; title=&quot;到底在调用哪个函数？&quot;&gt;&lt;/a&gt;到底在调用哪个函数？&lt;/h3&gt;&lt;p&gt;再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####　第一行a&lt;/p&gt;
&lt;p&gt;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);&lt;/p&gt;
&lt;p&gt;可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：&lt;/p&gt;
&lt;p&gt;第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0&lt;/p&gt;
&lt;p&gt;第四次同理；&lt;/p&gt;
&lt;p&gt;即：最终答案为undefined,0,0,0&lt;/p&gt;
&lt;h4 id=&quot;第二行b&quot;&gt;&lt;a href=&quot;#第二行b&quot; class=&quot;headerlink&quot; title=&quot;第二行b&quot;&gt;&lt;/a&gt;第二行b&lt;/h4&gt;&lt;p&gt;var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?&lt;/p&gt;
&lt;p&gt;先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用第一层fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；&lt;/p&gt;
&lt;p&gt;第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；&lt;/p&gt;
&lt;p&gt;即最终答案：undefined,0,1,2&lt;/p&gt;
&lt;h4 id=&quot;第三行c&quot;&gt;&lt;a href=&quot;#第三行c&quot; class=&quot;headerlink&quot; title=&quot;第三行c&quot;&gt;&lt;/a&gt;第三行c&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据前面两个例子，可以得知：&lt;/p&gt;
&lt;p&gt;fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用第一层fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；&lt;/p&gt;
&lt;p&gt;第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1&lt;/p&gt;
&lt;p&gt;即最终答案：undefined,0,1,1&lt;/p&gt;
&lt;p&gt;转载：&lt;a href=&quot;http://caibaojian.com/toutiao/5450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://caibaojian.com/toutiao/5450&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端程序员经常忽略的一道js面试题</title>
    <link href="http://blog.newbug.xyz/2017/04/12/%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E9%81%93js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/12/前端程序员经常忽略的一道js面试题/</id>
    <published>2017-04-12T03:02:24.000Z</published>
    <updated>2017-04-13T06:46:31.609Z</updated>
    
    <content type="html">&lt;p&gt;在网上看的这道面试题很经典，就转载过来记录一下，顺便加深自己的印象&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;function Foo() {&lt;br&gt;    getName = function () { alert (1); };&lt;br&gt;    return this;&lt;br&gt;}&lt;br&gt;Foo.getName = function () { alert (2);};&lt;br&gt;Foo.prototype.getName = function () { alert (3);};&lt;br&gt;var getName = function () { alert (4);};&lt;br&gt;function getName() { alert (5);}&lt;/p&gt;
&lt;p&gt;//请写出以下输出结果：&lt;br&gt;Foo.getName();&lt;br&gt;getName();&lt;br&gt;Foo().getName();&lt;br&gt;getName();&lt;br&gt;new Foo.getName();&lt;br&gt;new Foo().getName();&lt;br&gt;new new Foo().getName();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这几道题经常碰见，但是没有好好研究过，今天看了一下，考查的内容确实很多，基本看出了js的综合能力，包含了变量定义提升，this指针指向，运算符优先级，原型，继承，全局变量污染，对象属性以及原型属性优先级等知识。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第一问&quot;&gt;&lt;a href=&quot;#第一问&quot; class=&quot;headerlink&quot; title=&quot;第一问&quot;&gt;&lt;/a&gt;第一问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;先看此题的上半部分说了什么，首先是自定义了一个叫Foo的函数，之后为Foo创建了一个getName的静态属性储存了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个getName函数。

第一问的Foo.getName自然是访问Foo函数上储存的静态属性，答案自然是2，这个很简单，没什么说的，但是我们来复习下基础知识

    function User(name) {
        var name = name ;//私有属性
        this.name = name ;//公有属性
        function getName() {//公有方法
            return name;
        }
    }
    User.prototype.getName = function() {
        return this.name;
    }
    User.name = &amp;apos;Wscats&amp;apos;;//静态属性
    User.getName = function(){//静态方法
        return this.name ;
    }
    var Wscat = new User(&amp;apos;Wscats&amp;apos;);//实例化

注意下面这几点：
    * 调用公有方法，公有属性，我们必须先实例化对象，也就是用new操作符实例化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态属性的
    * 静态方法和静态属性就是我们无需实例化就可以调用
    * 而对象的私有方法和属性，外部是不可以访问的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第二问&quot;&gt;&lt;a href=&quot;#第二问&quot; class=&quot;headerlink&quot; title=&quot;第二问&quot;&gt;&lt;/a&gt;第二问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;直接调用getName函数，就是访问当前尚文作用域内的叫getName的函数，所以这里应该直接把关注点放在4和5上，跟123都没什么关系。此处有两个坑，一是变量生命提升，而是函数表达式和函数声明的区别。
此处可以参考https://github.com/Wscats/Good-text-Share/issues/73

https://github.com/Wscats/Good-text-Share/issues/86

在js中，定义函数有两种类型

### 函数声明
    //函数声明
    function wacat(type){
        return type === &amp;apos;wscat&amp;apos;;
    }

### 函数表达式
    //函数表达式
    var oaoafly = function (type){
        return type ===  &amp;apos;oaoafly&amp;apos;;
    }

    先来看一下下面这个问题，在一个程序里同时用函数声明和函数表达式定义一个名为getName的函数
        getName()//oaoafly
        var getName  = function () {
            console.log(&amp;apos;wscat&amp;apos;)
        }
        getName()//wscat
        function getName(){
            console.log(&amp;apos;oaoafly&amp;apos;)
        }
        getName()//wscat
    #### js解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在后面，也还是会被提升到前面
    #### 而用函数表达式创建的函数在运行时进行赋值，且要等到表达式赋值完成后才能调用

        var getName //变量被提升，此时为undefined

        getName();//oaoafly函数被提升，这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了
        var getName = function () {
            console.log(&amp;apos;wacat&amp;apos;)
        }//函数表达式此时才开始覆盖函数声明的定义
        getName()//wscat
        function getName () {
            console.log(&amp;apos;oaoafly&amp;apos;);
        }
        getName()//wscat 这里就执行了函数表达式的值

    所以可以分解为这两个简单的问题来看清楚区别的本质

        var getName ;
        console.log(getName)//undefined
        getName()//Uncaught TypeError: getName is not a function
        var getName = function () {
            console.log(&amp;apos;wscat&amp;apos;)
        }



        var getName ;
        console.log(getName);//function getName() {console.log(&amp;apos;oaoafly&amp;apos;)}
        getName()//oaoafly
        function getName(){
            console.log(&amp;apos;oaoafly&amp;apos;)
        }
    这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且知名的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机上的差异。
    总结：
        #### js中函数声明和函数表达式是存在区别的，函数声明在js解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪定义，该函数都可以进行调用，而函数表达式的值是在js运行时确定，并且在表达式赋值完成后，该函数才能调用。
        所以第二问的答案就是4，5的函数生命被4的函数表达式覆盖了
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第三问&quot;&gt;&lt;a href=&quot;#第三问&quot; class=&quot;headerlink&quot; title=&quot;第三问&quot;&gt;&lt;/a&gt;第三问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Foo().getName();先执行了Foo函数，然后再调用Foo函数的返回值对象的getName属性函数
Foo函数的第一句getName = function (){alert(1)}是一句函数赋值语句，注意他没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有的话，在想当前函数作用域上层，即外层作用域内寻找是否含有getNAme变量，找到了，也就是第二问种的alert(4)函数,将此变量的值赋值为function(){alert(1)}
此处实际上是将外层作用域内的getName函数修改了。

注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。

之后Foo函数的返回值是this，简单的讲，this的指向室友所在函数的调用方式决定的，而此处的直接调用方式，this指向window对象。所以Foo函数返回的是window对象，相当于执行window.getname(),而window种的getName已经被修改为alert(1),所以最终会输出1

    var name = &amp;apos;wscat&amp;apos;;//全局变量
    window.name = &amp;apos;Wscats&amp;apos;;//全局变量
    function getName () {
        name = &amp;apos;Oaoafly&amp;apos;; //去掉var变成了全局变量
        var privateName = &amp;apos;Stacsw&amp;apos;;
        return function () {
            console.log(this);//window
            return privateName
        }
    }
    var getPrivate = getName(&amp;apos;Hello&amp;apos;);//当然传参是局部变量，但函数里面没有接受这个参数

    console.log(name);//Oaoafly
    console.log(getPrivate());//Stacsw

    因为js没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值得方法会直接或间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真是第一公民呀
    而关于this，this的志向是在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象
    所以第三问中实际上就是window在调用  Foo() 函数，所以this的指向是window

    window.Foo().getName()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第四问&quot;&gt;&lt;a href=&quot;#第四问&quot; class=&quot;headerlink&quot; title=&quot;第四问&quot;&gt;&lt;/a&gt;第四问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;直接调用getName函数，相当于window.getName(),因为这个变量已经被Foo函数执行时修改了，所以结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的拿个getName函数。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第五问&quot;&gt;&lt;a href=&quot;#第五问&quot; class=&quot;headerlink&quot; title=&quot;第五问&quot;&gt;&lt;/a&gt;第五问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;第五问的 new Foo.getName() 此处考查的是js的运算符优先级问题
js运算符的优先级问题，可以参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

这道题首先看优先级的第18和第17都出现关于new的优先级，new(带参数列表)比new(无参数列表)高，跟成员访问同级

new Foo.getName();的优先级是这样的
相当于是：
    new (Foo.getName)();

    * 点的优先级(18)比new无序列表(17)优先级高
    * 当点运算完后又因为有个括号(),此时就是变成new有序列表(18)，所以直接执行new，当然也有可能有朋友会问，为什么遇到()不函数调用在new呢，那是因为函数调用(17)比new有参数列表(18)优先级低
所以这里实际上将getName函数作为了构造函数来执行，所以是2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第六问&quot;&gt;&lt;a href=&quot;#第六问&quot; class=&quot;headerlink&quot; title=&quot;第六问&quot;&gt;&lt;/a&gt;第六问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;这一题比上一题的区别就在Foo那里多了一个括号，这个有括号跟没括号在我们上疑问中就看出来优先级是有区别的

    (new Foo()).getName()

首先new有参数列表(18)跟点的优先级(18)是同级，同级的话按照从左到右的执行顺序，所以先执行new有参数列表(18)在执行点的优先级(18),最后在函数调用(17)
    new有参数列表(18)-&amp;gt;.成员访问(18)-&amp;gt;()函数调用(17)
这里还有一个知识点，Foo作为构造函数有返回值
#### 构造函数的返回值
    在传统语言中， 构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。而在js中构造函数可以有返回值也可以没有。
    1，没有返回值则按照其他语言一样返回实例化对象
        function Foo(name) {
            this.name = name;
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))

    2,若有返回值则检查其返回值是否为引用类型，如果是非引用类型，如基本类型(String.Number.Boolean.Null.Undefined)则于无返回值相同，实际返回其实例化对象

        function Foo(name) {
            this.name = name
            return 520
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))

    3,若返回值是引用类型，则实际返回值为这个引用类型

        function foo(name) {
            this.name = name
            return {
                age:16
            }
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))


原题中，由于返回的是this，而在this在构造函数中本来就代表当前实例化对象，最终Foo函数返回实例化对象
之后调用实例化对象的getName函数，因为在Foo构造函数中没有实例化对象添加任何属性，当前对象的原型对象(prototype)中寻找getName函数。
当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认会拿构造函数的公有方法而不是原型链，这个知识点在原题中没有表现出来，后面改进版我已经加上

    function Foo(name) {
        this.name = name ;
        this.getName = function() {
            return this.name
        }
    }
    Foo.prototype.name = &amp;apos;Oaoafly&amp;apos;;
    Foo.prototype.getName = function () {
        return &amp;apos;Oaoafly&amp;apos;
    }
    console.log((new Foo(&amp;apos;Wscats&amp;apos;)).name)//Wscats
    console.log((new Foo(&amp;apos;Wscats&amp;apos;)).getName)//Wscats
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第七问&quot;&gt;&lt;a href=&quot;#第七问&quot; class=&quot;headerlink&quot; title=&quot;第七问&quot;&gt;&lt;/a&gt;第七问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;new new Foo().getName(); 同样是运算符优先级问题

实际上问的是 

    new ((new Foo()).getName)()
    new有参数列表(18)-&amp;gt;new有参数列表(18)
先初始化Foo的实例化对象，然后将原型上的getName函数作为构造函数再次new
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##答案&lt;br&gt;        function Foo() {&lt;br&gt;            getName = function () { alert (1); };&lt;br&gt;            return this;&lt;br&gt;        }&lt;br&gt;        Foo.getName = function () { alert (2);};&lt;br&gt;        Foo.prototype.getName = function () { alert (3);};&lt;br&gt;        var getName = function () { alert (4);};&lt;br&gt;        function getName() { alert (5);}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//答案：
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;难度加大，在Foo函数里面加多一个公有方法getName

            function Foo() {
                this.getName = function() {
                    console.log(3);
                    return {
                        getName: getName//这个就是第六问中涉及的构造函数的返回值问题
                    }
                };//这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级
                getName = function() {
                    console.log(1);
                };
                return this
            }
            Foo.getName = function() {
                console.log(2);
            };
            Foo.prototype.getName = function() {
                console.log(6);
            };
            var getName = function() {
                console.log(4);
            };

            function getName() {
                console.log(5);
            } //答案：
            Foo.getName(); //2
            getName(); //4
            console.log(Foo())
            Foo().getName(); //1
            getName(); //1
            new Foo.getName(); //2
            new Foo().getName(); //3
                    //多了一问
            new Foo().getName().getName(); //3 1
            new new Foo().getName(); //3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转载自&lt;a href=&quot;https://github.com/Wscats/Good-text-Share/issues/85&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Wscats/Good-text-Share/issues/85&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看的这道面试题很经典，就转载过来记录一下，顺便加深自己的印象&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>typeof和instanceof</title>
    <link href="http://blog.newbug.xyz/2017/04/11/typeof%E5%92%8Cinstanceof/"/>
    <id>http://blog.newbug.xyz/2017/04/11/typeof和instanceof/</id>
    <published>2017-04-11T07:41:31.000Z</published>
    <updated>2017-04-11T07:49:56.363Z</updated>
    
    <content type="html">&lt;p&gt;JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。但它们之间还是有区别的：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;typeof是一个一元运算，放在一个运算数之前，运算数可以是任意类型。他返回值是一个字符串，该字符串说明运算数的类型，typeof 一般只能返回如下几个结果：
number,boolean,string,function,object,undefined。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;我们可以使用-typeof-来获取一个变量是否存在，如-if-typeof-a-”undefined”-alert-“ok”-，而不要去使用-if-a-因为如果-a-不存在（未声明）则会出错，对于-Array-Null-等特殊对象使用-typeof-一律返回-object，这正是-typeof-的局限性。&quot;&gt;&lt;a href=&quot;#我们可以使用-typeof-来获取一个变量是否存在，如-if-typeof-a-”undefined”-alert-“ok”-，而不要去使用-if-a-因为如果-a-不存在（未声明）则会出错，对于-Array-Null-等特殊对象使用-typeof-一律返回-object，这正是-typeof-的局限性。&quot; class=&quot;headerlink&quot; title=&quot;我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。&quot;&gt;&lt;/a&gt;我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;document.write (&amp;quot;typeof(1): &amp;quot;+typeof(1)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(NaN): &amp;quot;+typeof(NaN)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Number.MIN_VALUE): &amp;quot;+typeof(Number.MIN_VALUE)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Infinity): &amp;quot;+typeof(Infinity)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(\&amp;quot;123\&amp;quot;): &amp;quot;+typeof(&amp;quot;123&amp;quot;)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(true): &amp;quot;+typeof(true)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(window): &amp;quot;+typeof(window)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Array()): &amp;quot;+typeof(new Array())+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(function(){}): &amp;quot;+typeof(function(){})+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(document): &amp;quot;+typeof(document)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(null): &amp;quot;+typeof(null)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(eval): &amp;quot;+typeof(eval)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Date): &amp;quot;+typeof(Date)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(sss): &amp;quot;+typeof(sss)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(undefined): &amp;quot;+typeof(undefined)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;instanceof&quot;&gt;&lt;a href=&quot;#instanceof&quot; class=&quot;headerlink&quot; title=&quot;instanceof&quot;&gt;&lt;/a&gt;instanceof&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;instance：实例,例子
a instanceof b?alert(&amp;quot;true&amp;quot;):alert(&amp;quot;false&amp;quot;); //a是b的实例？真:假
instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array); 会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。再如：function test(){};var a=new test();alert(a instanceof test) 会返回
谈到 instanceof 我们要多插入一个问题，就是 function 的 arguments，我们大家也许都认为 arguments 是一个 Array，但如果使用 instaceof 去测试会发现 arguments 不是一个 Array 对象，尽管看起来很像。
另外：
测试 var a=new Array();if (a instanceof Object) alert(&amp;apos;Y&amp;apos;);else alert(&amp;apos;N&amp;apos;);
得&amp;apos;Y’
但 if (window instanceof Object) alert(&amp;apos;Y&amp;apos;);else alert(&amp;apos;N&amp;apos;);
得&amp;apos;N&amp;apos;
所以，这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。
使用 typeof 会有些区别
alert(typeof(window)) 会得 object
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。但它们之间还是有区别的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js复习重点</title>
    <link href="http://blog.newbug.xyz/2017/04/11/js%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.newbug.xyz/2017/04/11/js复习重点/</id>
    <published>2017-04-11T03:30:42.000Z</published>
    <updated>2017-04-11T03:31:21.579Z</updated>
    
    <content type="html">&lt;p&gt;1.闭包的概念及其应用&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;2.原型链/继承，构造对象的方法&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.oyanglul.us/javascript/understand-prototype.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.oyanglul.us/javascript/understand-prototype.html&lt;/a&gt;&lt;br&gt;这一部分 js高级程序设计上面讲的挺好的&lt;/p&gt;
&lt;p&gt;3.bom/dom(重点是dom)&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000654274（这个说的挺详细）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/a/1190000000654274（这个说的挺详细）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.itxueyuan.org/view/6299.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.itxueyuan.org/view/6299.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.NET/xiao__gui/article/details/8315148&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.NET/xiao__gui/article/details/8315148&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.获取元素的方法，queryselector()（get—byid，byclassname。。。。。）&lt;br&gt;&lt;a href=&quot;http://blog.csdn.Net/mydeman/article/details/2078107&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.Net/mydeman/article/details/2078107&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.nodelist和array&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/jeffwongishandsome/archive/2010/07/07/1773144.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/jeffwongishandsome/archive/2010/07/07/1773144.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.数组的常规操作&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/ahthw/p/4279642.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/ahthw/p/4279642.html&lt;/a&gt;&lt;br&gt;熟悉一下一下基本的算法，排序，逆置什么的。&lt;br&gt;7.apply/call&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html&lt;/a&gt;&lt;br&gt;call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过：var domNodes =  Array.prototype.slice.call(document.getElementsByTagName(“*”));这样domNodes就可以应用Array下的所有方法了。&lt;br&gt;8.string对象的操作&lt;br&gt;&lt;a href=&quot;http://itbilu.com/javascript/js/EymJA6WY.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://itbilu.com/javascript/js/EymJA6WY.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9.五种基本类型（数字，字符串，undefined，null，boolearn）以及复合类型（array，object，function），他们二者的判别方法&lt;br&gt;&lt;a href=&quot;http://www.xiabingbao.com/javascript/2015/07/04/javascript-type/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.xiabingbao.com/javascript/2015/07/04/javascript-type/&lt;/a&gt;&lt;br&gt;10.事件流（冒泡，捕获）&lt;br&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000003497939&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://segmentfault.com/a/1190000003497939&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11.事件的添加，删除&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/jaylongli/article/details/4038042&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/jaylongli/article/details/4038042&lt;/a&gt;&lt;br&gt;结合事件流选择合适的元素进行事件添加可以适当的优化性能，也就是事件委托&lt;/p&gt;
&lt;p&gt;12.事件委托&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html&lt;/a&gt;&lt;br&gt;13.this&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14.new&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/hy6688_/article/details/22453043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/hy6688_/article/details/22453043&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;15.js跨域&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html&lt;/a&gt;&lt;br&gt;js的类库看一下jQuery，有时间浏览一下源码，$符的实现原理&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1.闭包的概念及其应用&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot;&gt;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript初级试题</title>
    <link href="http://blog.newbug.xyz/2017/04/10/JavaScript%E5%88%9D%E7%BA%A7%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/10/JavaScript初级试题/</id>
    <published>2017-04-10T02:27:55.000Z</published>
    <updated>2017-04-11T02:44:34.794Z</updated>
    
    <content type="html">&lt;p&gt;今天在网上看了几个初级的试题，没想到竟然后好几个不确定答案的，所以就在此记录下&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;1,输出下面的值&lt;br&gt;        var a = 10, b = 20, c = (a++,b++,100);&lt;br&gt;        console.log(c);&lt;br&gt;运算符的优先级，这里的运算符逗号是多重求值，不论多少个逗号，都是返回最后一个逗号后面的值&lt;br&gt;2,判断是否为质数&lt;br&gt;        function isZhuShu(m){&lt;br&gt;            if( m &amp;lt;= 1 || m%1 !== 0){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            var n = 2;&lt;br&gt;            while(n&amp;lt;m){&lt;br&gt;                if(m%n==0){&lt;br&gt;                    return false;&lt;br&gt;                }else{&lt;br&gt;                    n++;&lt;br&gt;                    continue;&lt;br&gt;                }&lt;br&gt;            }&lt;br&gt;            return true&lt;br&gt;        }&lt;br&gt;下面的是优化算法：&lt;br&gt;        function isPrime(number){&lt;br&gt;            if (typeof number !== ‘number’ || number &amp;lt; 2){&lt;br&gt;                //不是数字或者字数小于2&lt;br&gt;                return false;&lt;br&gt;            }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if (number === 2){
        //2是质数
        return true 
    } else if (number % 2 === 0){
        //排除偶数
        return true
    } 
    var squareRoot = Math.sqrt(number);
    for(var i = 3; i &amp;lt;= squareRoot; i+=2){
        //因为2已经验证过，所以从三开始，且已经排除偶数，所以每次加2
        if(number % i === 0){
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3,获取斐波那契数列的第n个值，如果n不是有限的数字，则返回undefined&lt;br&gt;        function getFBN(n){&lt;br&gt;            if(typeof n !== ‘number’){&lt;br&gt;                return&lt;br&gt;            }&lt;br&gt;            if(n &amp;lt; 0){&lt;br&gt;                return 1&lt;br&gt;            }&lt;br&gt;            else if (n &amp;lt;= 2){&lt;br&gt;                return 2&lt;br&gt;            }&lt;br&gt;            return getFBN(n-1) + getFBN(n-2);&lt;br&gt;        }&lt;br&gt;        console.log(getFBN(3))&lt;br&gt;4,计算从10到100中能被3或者5整除的数的和&lt;br&gt;        function getSum(){&lt;br&gt;            var sum = 0;&lt;br&gt;            for(var i = 10;i&amp;lt;=100;i++){&lt;br&gt;                sum += (i%3 === 0 || i%5 === 0) &amp;amp;&amp;amp; i&lt;br&gt;            }&lt;br&gt;            return sum&lt;br&gt;        }&lt;br&gt;        console.log(getSum)&lt;br&gt;5,将传入的字符串翻转输出，如果不是字符串输出undefined&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getReverse(str){
    var result = &amp;apos;&amp;apos;;
    if(typeof str !== &amp;apos;string&amp;apos;){
        return 
    }
    for(var len = str.length,i=len-1;i&amp;gt;=0;i--){
        result += str[i]
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是简便的方法&lt;br&gt;        function getReverse(str){&lt;br&gt;            if(typeof str !== ‘string’){&lt;br&gt;                return null&lt;br&gt;            }&lt;br&gt;            return str.split(‘’).reverse().join(‘’)&lt;br&gt;        }&lt;/p&gt;
&lt;p&gt;6,写一个函数，来实现判断一个字符串是否为回文（忽略大小写）&lt;br&gt;        function isHuiWen(str){&lt;br&gt;            if(typeof str !== ‘string’ || str.constructor !== String){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            for(var i = 0,len=(str.length+1)/2;i&amp;lt;len;i++){&lt;br&gt;                if(str[i] !== str[str.length-i-1]){&lt;br&gt;                    return false;&lt;br&gt;                }&lt;br&gt;            }&lt;br&gt;        }&lt;/p&gt;
&lt;p&gt;7,去除字符串中重复的字符&lt;br&gt;        function getNoRepeat(str){&lt;br&gt;            var tempObj = {},result = ‘’;&lt;br&gt;            if(typeof str !== ‘string’ || str.constructor !== String){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            for(var i = 0,len =str.length;i&lt;len;i++){ 1=&quot;&quot; if(!tempobj[str[i]]){=&quot;&quot; result=&quot;&quot; +=&quot;str[i];&quot; tempobj[str[i]]=&quot;true&quot; }=&quot;&quot; return=&quot;&quot; 8,=&quot;&quot; 输出1000内水仙花数水仙花数是指一个=&quot;&quot; n=&quot;&quot; 位数=&quot;&quot; (=&quot;&quot; n≥3=&quot;&quot; )，它的每个位上的数字的=&quot;&quot; 次幂之和等于它本身。（例如：1^3=&quot;&quot; 5^3+=&quot;&quot; 3^3=&quot;153）三位的水仙花数共有4个：153，370，371，407&quot; 先封装一个简易版的math.pow封装=&quot;&quot; function=&quot;&quot; pospow(n,x){=&quot;&quot; var=&quot;&quot; if(x=&quot;==0){&quot; &lt;=&quot;&quot; 0){=&quot;&quot; 只运算乘方=&quot;&quot; null=&quot;&quot; while(x=&quot;&quot;&gt;1){&lt;br&gt;                result = result*n;&lt;br&gt;                x–;&lt;br&gt;            }&lt;br&gt;            return result;&lt;br&gt;        }&lt;/len;i++){&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//最终函数
    function narc(max){
        var resultList = [],
            maxDigit=3, //max的位数
            tempResult=0;
        if(max &amp;lt;= 100){
            return null;
        }else if(typeof max !== &amp;apos;number&amp;apos;){
            return null
        }
        //取得max的位数
        maxDigit = max.toString().length+1;

        //第一层对于位数进行循环，从3位开始
        for(var digit = 3; digit &amp;lt;= maxDigit; digit++){
            //第二层循环从 0到 Max
            for(var i = 100; i &amp;lt; max; i++){
                tempResult = 0;
                //第三层循环，从i的第0位到最后一位
                for(var j=0;j&amp;lt;digit-1; j++){
                    tempResult += posPow(i.toString()[j], digit-1)
                }
                (tempResult === i) &amp;amp;&amp;amp; (resultList[resultList.length]  = i)
            }
        }

        return resultList;
    }

    console.log(narc(1000))
    console.log(narc(10000))
    console.log(narc(8209))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9,以下js代码会输出什么&lt;br&gt;        console.log(1 + “2” + “2”);//122&lt;br&gt;        console.log(1 +  + “2” + “2”);//32  空格加字符串变成数字，隐式转换&lt;br&gt;        console.log(+ “1” + “1” + “2”);//112&lt;br&gt;        console.log( “A” - “B” + “2”);//NAN2   “A” - “B” 会返回 NaN，因为 “A” 和 “B” 无法转成数字进行运算，这里不要以为 “A” 和 “B” 能转为 ASCII码 进行运算（这个和C语言是不同的，不要搞乱了）。而 NaN 和字符串相加，会转成 “NaN” 和字符串去拼接，所以，倒数第二问是 NAN+”2”,为 NAN2，NaN 和任何数字相加结果还是 NaN。&lt;br&gt;        console.log( “A” - “B” + 2 ); //NAN&lt;/p&gt;
&lt;p&gt;10,以下js输出结果为&lt;br&gt;        var length = 10;&lt;br&gt;        function fn(){&lt;br&gt;            alert(this.length);&lt;br&gt;        }&lt;br&gt;        var obj = {&lt;br&gt;            length: 5,&lt;br&gt;            method: function(fn){&lt;br&gt;                fn();&lt;br&gt;                arguments&lt;a href=&quot;&quot;&gt;0&lt;/a&gt;;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;        obj.method(fn);&lt;/p&gt;
&lt;p&gt;这个主要是考arguments，对象属于除了点操作符还可以用中括号，这里fn的scope是arguments，即fn内的this===arguments，调用时仅传了一个参数fn，因此length为1。&lt;/p&gt;
&lt;p&gt;11，&lt;br&gt;        var a = 1;&lt;br&gt;        function func(){&lt;br&gt;            a = b = 2;&lt;br&gt;        }&lt;br&gt;        func();&lt;br&gt;        alert(a); //2&lt;br&gt;        alert(b); //2&lt;br&gt;js中不用var声明的变量默认是全局变量，所以b是全聚德，所以func是可以对外进行访问的&lt;/p&gt;
&lt;p&gt;12，简述readyonly与disabled的区别&lt;br&gt;   1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。&lt;br&gt;   2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网上看了几个初级的试题，没想到竟然后好几个不确定答案的，所以就在此记录下&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html5常见的面试题</title>
    <link href="http://blog.newbug.xyz/2017/02/11/html5%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/02/11/html5常见的面试题/</id>
    <published>2017-02-11T05:31:48.000Z</published>
    <updated>2017-04-11T07:47:55.260Z</updated>
    
    <content type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1,常见的块级元素，内联元素&lt;br&gt;        fieldset - 表单字段集&lt;br&gt;        colgroup - 表单列分组元素&lt;br&gt;        pre 格式化文本&lt;br&gt;        i - 斜体&lt;br&gt;        em - 强调&lt;br&gt;        label - 表单标签&lt;br&gt;        sub - 下标&lt;br&gt;        sup - 上标&lt;br&gt;        u - 下划线&lt;br&gt;2，实现文本三个点的几个条件&lt;br&gt;    text-overflow属性仅是：当文本溢出时是否显示省略标记，并不具备其他的样式属性定义，要实现溢出时产生省略号的效果还需定义：&lt;br&gt;    1，容器宽度： width&lt;br&gt;    2，强制文本在一行内显示： white-space：nowrap&lt;br&gt;    3，溢出内容为隐藏：overflow：hidden；&lt;br&gt;    4，溢出文本显示省略号：text-overflow：ellipsis&lt;br&gt;    但行文本才可以设置文本溢出&lt;br&gt;3，垂直居中的几个条件&lt;br&gt;    设置一个元素在一个容器内垂直居中，必须更改默认的display属性值为inline-block&lt;br&gt;    并加上统计元素（标尺）（同级元素[标尺]样式设置为vertical-align:middle；width：0；height：100%；display：inline-block；）&lt;br&gt;    三个条件：&lt;br&gt;        1，必须给容器加上text-align:center；&lt;br&gt;        2，必须给当前元素转化为内块元素（display：inline-block)再给当前元素加上vertical-align:middle&lt;br&gt;        3，在当前元素的后面加上同级元素span进行vertical-align:middle；width：0；height：100%；display：inline-block；&lt;br&gt;4，图片精灵，优势&lt;br&gt;    图片整合，将小的单张背景图片整合到一张大的背景图片上&lt;br&gt;    优势：1）通过图片来整合减少对服务器的请求次数，从而提高页面的加载速度。2）通过整合图片来减少图片的体积&lt;br&gt;5，display:none与visibility:hidden的区别&lt;/p&gt;
&lt;p&gt;前者：隐藏不占位  后者：隐藏但是占位置&lt;br&gt;6，清除浮动的几种方式&lt;/p&gt;
&lt;p&gt;hack1：给父元素添加声明overflow:hidden;&lt;/p&gt;
&lt;p&gt;hack2:   给父元素加height&lt;/p&gt;
&lt;p&gt;hack3:   在浮动元素下方添加空div,并给该元素添加         声明：div{clear:both; height:0; overflow:hidden;}&lt;/p&gt;
&lt;p&gt;hack4:万能清除浮动法 p:after{content:“.”;clear:both;display:block;height:0;overflow:hidden;  visibility:hidden;}&lt;br&gt;7，哪些属性可以继承？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）文字相关：font-family、font-size、font-style、font-variant、font-weight、font、letter-spacing、line-height、text-align、text-indent、text-transform、word-spacing
2）列表相关：list-style-image、list-style-position、list-style-type、list-style
3）颜色相关：color
4）透明度（子元素会继承祖元素的opacity，但是无法更改）
注：font-size继承的是父元素的大小，而不是比例。line-height当父元素是百分比或px值得时候，子元素跟父元素相同，当父元素是normal或数字的时候，子元素的line-height是子元素的字体大小乘以数字。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8，link和@import区别？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。

2、link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了

3、加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）

4、兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题

5、使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9，定位的属性值都有哪些？每个值得意思？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;各属性值的作用：

static：默认值。位置设置为 static 的元素会正常显示，它始终会处于文档流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。

absolute：相对于父级元素的绝对定位，s浮出、脱离布局流，它不占据空间，就是我们所说的层，其位置相对于最近的已定位父元素而言的位置，可直接指定 “left”、“top”、“right” 以及 “bottom” 属性。若父级都没有定位，则以html（根元素）。(层叠的顺序z-index:value)

relative：是相对于默认位置的偏移定位，通过设置left、top、right、bottom值可将其移至相对于其正常位置的地方（相对于自己的开始的位置发生的位置上的移动，【不会破坏正常的布局流】

fixed：相对浏览器的绝对定位，是相对于浏览器窗口的指定坐标进行定位。此元素的位置可通过 &amp;quot;left&amp;quot;、&amp;quot;top&amp;quot;、&amp;quot;right&amp;quot; 以及&amp;quot;bottom&amp;quot; 属性来规定。不论窗口滚动与否，元素都会留在那个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10，写出html5新增的标签15个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;header nav footer main aside article section figure datalist video audio fieldest  legend  label caption
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11，实现垂直+水平居中有哪些方法？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、div{width:200px;height:200px;background:#f00;position:fixed;left:0;right:0;top:0;bottom:0;margin:auto;}

2、div{width:200px;height:200px;background:#f00;position:fixed;left:50%;top:50%;margin:-100px 0 0 -100px;}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1,常见的块级元素，内联元素&lt;br&gt;        fieldset - 表单字段集&lt;br&gt;        colgroup - 表单列分组元素&lt;br&gt;        pre 格式化文本&lt;br&gt;        i - 斜体&lt;br&gt;    
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图片预加载</title>
    <link href="http://blog.newbug.xyz/2016/11/16/%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.newbug.xyz/2016/11/16/图片预加载/</id>
    <published>2016-11-16T12:26:28.000Z</published>
    <updated>2016-11-16T12:30:14.000Z</updated>
    
    <content type="html">&lt;p&gt;预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方法一：用CSS和JavaScript实现预加载&lt;/p&gt;
&lt;p&gt;实现预加载图片有很多方法，包括使用CSS、JavaScript及两者的各种组合。这些技术可根据不同设计场景设计出相应的解决方案，十分高效。&lt;/p&gt;
&lt;p&gt;单纯使用CSS，可容易、高效地预加载图片，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#preload-01 { background: url(-01.png) no-repeat -9999px -9999px; }

#preload-02 { background: url(-02.png) no-repeat -9999px -9999px; }

#preload-03 { background: url(-03.png) no-repeat -9999px -9999px; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。&lt;/p&gt;
&lt;p&gt;该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：&lt;br&gt;    // better image preloading @ &amp;lt;a href=”;&amp;gt;;/a&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function preloader() {

if (document.getElementById) {

    document.getElementById(&amp;quot;preload-01&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

    document.getElementById(&amp;quot;preload-02&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

    document.getElementById(&amp;quot;preload-03&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

}

}

function addLoadEvent(func) {

var oldonload = window.onload;

if (typeof window.onload != &amp;apos;function&amp;apos;) {

    window.onload = func;

} else {

    window.onload = function() {

        if (oldonload) {

            oldonload();

        }

        func();

    }

}

}

addLoadEvent(preloader);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。&lt;/p&gt;
&lt;p&gt;该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。&lt;/p&gt;
&lt;p&gt;如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。&lt;/p&gt;
&lt;p&gt;方法二：仅使用JavaScript实现预加载&lt;/p&gt;
&lt;p&gt;上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。&lt;/p&gt;
&lt;p&gt;JavaScript代码段1&lt;/p&gt;
&lt;p&gt;只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：&lt;br&gt;    &lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

    &amp;lt;!--//--&amp;gt;&amp;lt;![CDATA[//&amp;gt;&amp;lt;!--

        var images = new Array()

        function preload() {

            for (i = 0; i &amp;lt; preload.arguments.length; i++) {

                images[i] = new Image()

                images[i].src = preload.arguments[i]
            }

        }

        preload(

            &amp;quot;;,

            &amp;quot;;,

            &amp;quot;;

        )

    //--&amp;gt;&amp;lt;!]]&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。 &lt;/p&gt;
&lt;p&gt;JavaScript代码段2&lt;/p&gt;
&lt;p&gt;该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;hidden&amp;quot;&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

    &amp;lt;!--//--&amp;gt;&amp;lt;![CDATA[//&amp;gt;&amp;lt;!--

        if (document.images) {

            img1 = new Image();

            img2 = new Image();

            img3 = new Image();

            img1.src = &amp;quot;;;

            img2.src = &amp;quot;;;

            img3.src = &amp;quot;;;

        }

    //--&amp;gt;&amp;lt;!]]&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。&lt;/p&gt;
&lt;p&gt;我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function preloader() {

if (document.images) {

    var img1 = new Image();

    var img2 = new Image();

    var img3 = new Image();

    img1.src = &amp;quot;;;

    img2.src = &amp;quot;;;

    img3.src = &amp;quot;;;

}

}

function addLoadEvent(func) {

var oldonload = window.onload;

if (typeof window.onload != &amp;apos;function&amp;apos;) {

    window.onload = func;

} else {

    window.onload = function() {

        if (oldonload) {

            oldonload();

        }

        func();

    }

}

}

addLoadEvent(preloader);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法三：使用Ajax实现预加载&lt;/p&gt;
&lt;p&gt;上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。&lt;br&gt;    window.onload = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {

    // XHR to request a JS and a CSS

    var xhr = new XMLHttpRequest();

    xhr.open(&amp;apos;GET&amp;apos;, &amp;apos;;);

    xhr.send(&amp;apos;&amp;apos;);

    xhr = new XMLHttpRequest();

    xhr.open(&amp;apos;GET&amp;apos;, &amp;apos;;);

    xhr.send(&amp;apos;&amp;apos;);

    // preload image

    new Image().src = &amp;quot;;;

}, 1000);

};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。&lt;/p&gt;
&lt;p&gt;下面，我们看看如何用JavaScript来实现该加载过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onload = function() {



setTimeout(function() {



    // reference to &amp;lt;head&amp;gt;

    var head = document.getElementsByTagName(&amp;apos;head&amp;apos;)[0];



    // a new CSS

    var css = document.createElement(&amp;apos;link&amp;apos;);

    css.type = &amp;quot;text/css&amp;quot;;

    css.rel  = &amp;quot;stylesheet&amp;quot;;

    css.href = &amp;quot;;;



    // a new JS

    var js  = document.createElement(&amp;quot;script&amp;quot;);

    js.type = &amp;quot;text/javascript&amp;quot;;

    js.src  = &amp;quot;;;



    // preload JS and CSS

    head.appendChild(css);

    head.appendChild(js);



    // preload image

    new Image().src = &amp;quot;;;



}, 1000);



};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，我们通过DOM创建三个元素来实现三个文件的预加载。正如上面提到的那样，使用Ajax，加载文件不会应用到加载页面上。从这点上看，Ajax方法优越于JavaScript。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="http://blog.newbug.xyz/2016/11/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.newbug.xyz/2016/11/10/面试总结/</id>
    <published>2016-11-10T12:49:23.000Z</published>
    <updated>2016-11-16T12:38:58.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;a href=&quot;#用js写一个函数计算出字符串的长度&quot; class=&quot;headerlink&quot; title=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;/a&gt;用js写一个函数计算出字符串的长度&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;GBK字符集实际长度计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getStrLeng(str) {
    var realLength = 0;
    var len = str.length;
    var charCode = -1;
    for (var i = 0; i &amp;lt; len; i++) {
        charCode = str.charCodeAt(i);
        if (charCode &amp;gt;= 0 &amp;amp;&amp;amp; charCode &amp;lt;= 128) {
            realLength += 1;
        }else{
            //如果是中文则长度加2；
            realLength += 2;
        }
    }
    return realLength;
}
console.log(getStrLeng(&amp;apos;ahaak522中文&amp;apos;));//12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;utf8字符集实际长度计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//utf8 字符集实际长度计算
function getStrLeng(str) {
    var realLength = 0;
    var len = str.length;
    var charCode = -1;
    for(var i = 0; i &amp;lt; len; i++){
        charCode = str.charCodeAt(i);
        if (charCode &amp;gt;= 0 &amp;amp;&amp;amp; charCode &amp;lt;= 128) { 
            realLength += 1;
        }else{ 
            // 如果是中文则长度加3
            realLength += 3;
        }
    } 
    return realLength;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在JS中字符串的长度不分中英文字符， 每一个字符都算一个长度，这跟PHP里的strlen()函数就不太一样。PHP里的strlen()函数根据字符集把GBK的中文每个2累加，把UTF-8的中文字符每个按3累加。主要是为了匹配数据库的长度范围内，比如GBK的数据库某字段是varchar(10)，那么就相当于5个汉字长度，一个汉字等于两个字母长度。如果是UTF8的数据库则是每个汉字长度为3    &lt;/p&gt;
&lt;h3 id=&quot;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和HTML5？&quot;&gt;&lt;a href=&quot;#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和HTML5？&quot; class=&quot;headerlink&quot; title=&quot;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？&quot;&gt;&lt;/a&gt;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？&lt;/h3&gt;&lt;p&gt;HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。  &lt;/p&gt;
&lt;p&gt;绘画 canvas  &lt;/p&gt;
&lt;p&gt;用于媒介回放的 video 和 audio 元素  &lt;/p&gt;
&lt;p&gt;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；&lt;br&gt;sessionStorage 的数据在浏览器关闭后自动删除 &lt;/p&gt;
&lt;p&gt;语意化更好的内容元素，比如 article、footer、header、nav、section  &lt;/p&gt;
&lt;p&gt;表单控件，calendar、date、time、email、url、search  &lt;/p&gt;
&lt;p&gt;新的技术webworker, websockt, Geolocation  &lt;/p&gt;
&lt;p&gt;移除的元素  &lt;/p&gt;
&lt;p&gt;纯表现的元素：basefont，big，center，font, s，strike，tt，u；  &lt;/p&gt;
&lt;p&gt;对可用性产生负面影响的元素：frame，frameset，noframes；  &lt;/p&gt;
&lt;p&gt;支持HTML5新标签：  &lt;/p&gt;
&lt;p&gt;IE8/IE7/IE6支持通过document.createElement方法产生的标签，&lt;br&gt;可以利用这一特性让这些浏览器支持HTML5新标签，&lt;br&gt;浏览器支持新标签后，还需要添加标签默认的样式&lt;/p&gt;
&lt;h3 id=&quot;请描述一下-cookies，sessionStorage-和-localStorage-的区别？&quot;&gt;&lt;a href=&quot;#请描述一下-cookies，sessionStorage-和-localStorage-的区别？&quot; class=&quot;headerlink&quot; title=&quot;请描述一下 cookies，sessionStorage 和 localStorage 的区别？&quot;&gt;&lt;/a&gt;请描述一下 cookies，sessionStorage 和 localStorage 的区别？&lt;/h3&gt;&lt;p&gt;cookies在浏览器之间来回传递，sessionStorage和localStorage不会，&lt;br&gt;sessionStorage和localStorage储存空间更大，有更多丰富易用的接口，有各自独立存储的空间，  &lt;/p&gt;
&lt;h3 id=&quot;如何实现浏览器内多个标签页之间的通信&quot;&gt;&lt;a href=&quot;#如何实现浏览器内多个标签页之间的通信&quot; class=&quot;headerlink&quot; title=&quot;如何实现浏览器内多个标签页之间的通信?&quot;&gt;&lt;/a&gt;如何实现浏览器内多个标签页之间的通信?&lt;/h3&gt;&lt;p&gt;调用localstorge、cookies等本地存储方式  &lt;/p&gt;
&lt;h3 id=&quot;添加-删除-替换-插入到某个接点的方法&quot;&gt;&lt;a href=&quot;#添加-删除-替换-插入到某个接点的方法&quot; class=&quot;headerlink&quot; title=&quot;添加 删除 替换 插入到某个接点的方法&quot;&gt;&lt;/a&gt;添加 删除 替换 插入到某个接点的方法&lt;/h3&gt;&lt;p&gt;obj.appendChidl()  &lt;/p&gt;
&lt;p&gt;obj.innersetBefore  &lt;/p&gt;
&lt;p&gt;obj.replaceChild  &lt;/p&gt;
&lt;p&gt;obj.removeChild  &lt;/p&gt;
&lt;h3 id=&quot;说一下什么是javascript的同源策略？&quot;&gt;&lt;a href=&quot;#说一下什么是javascript的同源策略？&quot; class=&quot;headerlink&quot; title=&quot;说一下什么是javascript的同源策略？&quot;&gt;&lt;/a&gt;说一下什么是javascript的同源策略？&lt;/h3&gt;&lt;p&gt;一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合  &lt;/p&gt;
&lt;h3 id=&quot;编写一个b继承a的方法&quot;&gt;&lt;a href=&quot;#编写一个b继承a的方法&quot; class=&quot;headerlink&quot; title=&quot;编写一个b继承a的方法;&quot;&gt;&lt;/a&gt;编写一个b继承a的方法;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function A(name){
    this.name = name;
    this.sayHello = function(){alert(this.name+” say Hello!”);};
}
function B(name,id){
    this.temp = A;
    this.temp(name);        //相当于new A();
    delete this.temp;       
     this.id = id;   
    this.checkId = function(ID){alert(this.id==ID)};
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;面试常见题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 小球从一百米落下，每次弹起的高度是上一次的一半，求第十次
var s = 100 ;
var hight = 100 ;
for (var i = 2; i &amp;lt; 11; i++) {
    hight /= 2;
    s = s + hight;
}
console.log(hight + &amp;apos; + &amp;apos; + s );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;call和apply的区别  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//     // call的定义
//     function add(a,b){
//         console.log(a+b);
//     }
//     function reduce(a,b) {
//         console.log(a-b);
//     }
//     add.call(reduce,3,4);//将add方法运用到reduce,结果为4
//     // call可以改变this的指向
//     function b() {
//         console.log(this);
//     }
//     b();//window
//     b.call();//window
//     b.call(&amp;apos;a&amp;apos;,2,3);//a
//     // 下面看一个复杂点的例子
//     function Animal() {
//         this.name = &amp;apos;animal&amp;apos;;
//         this.showName = function () {
//             console.log(this.name);
//         }
//     }
//     function Cat() {
//         this.name = &amp;apos;cat&amp;apos;;
//     }
//     var animal = new Animal();
//     var cat = new Cat();
//     animal.showName();//结果为animal
//     animal.showName.call(cat);//原本cat没有showName方法，但是通过call方法将animal的showName方法应用到cat上,因此结果为cat

    // 实现继承:
    function Animal(name) {
        this.name = name ;
        this.showName = function(){
            console.log(this.name);
        }
    }
    function Cat(name) {
        Animal.call(this,name);//将Animal应用到Cat上，因此Cat拥有了Animal的所有属性和方法
    }
    var cat = new Cat(&amp;apos;Black Cat&amp;apos;);
    cat.showName();//浏览器弹出Black Cat
    // 区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改input里面的颜色   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;color&amp;quot; placeholder=&amp;quot;你好，我会变颜色&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;nihao ,hahah &amp;quot;&amp;gt;


&amp;lt;p class=&amp;quot;weilei&amp;quot;&amp;gt;我是p&amp;lt;/p&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;css：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input::-webkit-input-placeholder {
        color: red;
}  

input::-moz-placeholder {
    color: red;
}
input:-ms-input-placeholder {
    color: red;
}
input::placeholder {
    color: red;
}
input.color::-webkit-input-placeholder {
    color: yellow;
}
/*.weilei:before {
    content: &amp;apos;我是p前面的东西&amp;apos;;
    color: blue;
}
.weilei:after {
    content: &amp;apos; http://www.baidu.com&amp;apos;;
}
.weilei {
    color: red;
}*/
/*p:before{   
    content:&amp;apos;网站名:&amp;apos;;
}   
p:after{   
    content:&amp;apos;\21E0&amp;apos;;
}*/  
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;a href=&quot;#用js写一个函数计算出字符串的长度&quot; class=&quot;headerlink&quot; title=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;/a&gt;用js写一个函数计算出字符串的长度&lt;/h3&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>js通过Ajax异步操作后端xml数据的基本原理</title>
    <link href="http://blog.newbug.xyz/2016/05/30/js%E9%80%9A%E8%BF%87Ajax%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%90%8E%E7%AB%AFxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.newbug.xyz/2016/05/30/js通过Ajax异步操作后端xml数据的基本原理/</id>
    <published>2016-05-30T04:20:31.000Z</published>
    <updated>2016-10-16T02:29:52.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;Ajax的核心操作对象是xmlHttpRequest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　  简化操作步骤：实例化一个xmlHttpRequest对象 ==&amp;gt; 发送请求 ==&amp;gt; 接受响应 ==&amp;gt; 执行回调&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;实例化对象&lt;/p&gt;
&lt;p&gt;　　考虑到兼容问题,非IE5/IE6 使用 =&amp;gt; new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;　　IE5/IE6使用 =&amp;gt; new ActiveXObject(Microsoft.XMLHTTP);    ☯神呐，请带走IE吧！&lt;/p&gt;
&lt;p&gt;发送请求&lt;/p&gt;
&lt;p&gt;　　使用 XMLHttpRequest 对象的 open(‘GET’,url,async) 和 send() 方法：&lt;/p&gt;
&lt;p&gt;　　❶ open() 有三个参数：&lt;/p&gt;
&lt;p&gt;　　　　分别为http请求方式(get/post) ==》与 POST 相比，GET 更简单也更快，POST 没有数据量限制，不会缓存，相对安全&lt;/p&gt;
&lt;p&gt;　　　　http请求地址 ==》url(统一资源定位符)文件所在服务器的地址&lt;/p&gt;
&lt;p&gt;　　　　async：true（异步）或 false（同步）&lt;/p&gt;
&lt;p&gt;　　❷send(string)   string：仅用于 POST 请求&lt;/p&gt;
&lt;p&gt;接受响应，执行回调&lt;/p&gt;
&lt;p&gt;　　当readyState的值发生改变时，触发readystatechange事件，事件中就可以为所欲为了&lt;/p&gt;
&lt;p&gt;　　readyState==4  =&amp;gt;请求加载完成  /    http的状态为200 =&amp;gt;响应成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;异步操作集合啦&amp;lt;/title&amp;gt;
        &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
            /*
             * Ajax的核心操作对象是xmlHttpRequest
             *    简化操作步骤：实例化一个xmlHttpRequest对象  ==&amp;gt; 发送请求  ==&amp;gt; 接受响应 ==&amp;gt; 执行回调
             */
            var jsAjax = function() {
                var xmlHttpR = null;
                if(window.ActiveXObject) {
                    //IE5/IE6把xmlHttpRequest封装在window的子对象ActiveXObject中
                    xmlHttpR = new ActiveXObject(Microsoft.XMLHTTP);
                } else if(window.XMLHttpRequest) {
                    //非IE5、IE6
                    xmlHttpR = new XMLHttpRequest();
                }

                if(xmlHttpR) {
                    xmlHttpR.open(&amp;quot;GET&amp;quot;, &amp;quot;ajax.xml&amp;quot;, true);
                    xmlHttpR.onreadystatechange = function(e) {
                        if(xmlHttpR.readyState == 4) {
                            if(xmlHttpR.status == 200) {
                                console.log(xmlHttpR.responseText);
                            }
                        }
                    }
                    xmlHttpR.send(null);
                }
            }
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

01
    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
02
    &amp;lt;bookstore&amp;gt;
03
    &amp;lt;book category=&amp;quot;COOKING&amp;quot;&amp;gt;
04
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Everyday Italian&amp;lt;/title&amp;gt;
05
        &amp;lt;author&amp;gt;Giada De Laurentiis&amp;lt;/author&amp;gt;
06
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
07
        &amp;lt;price&amp;gt;30.00&amp;lt;/price&amp;gt;
08
    &amp;lt;/book&amp;gt;
09
    &amp;lt;book category=&amp;quot;CHILDREN&amp;quot;&amp;gt;
10
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Harry Potter&amp;lt;/title&amp;gt;
11
        &amp;lt;author&amp;gt;J K. Rowling&amp;lt;/author&amp;gt;
12
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
13
        &amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;
14
    &amp;lt;/book&amp;gt;
15
    &amp;lt;book category=&amp;quot;WEB&amp;quot;&amp;gt;
16
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Learning XML&amp;lt;/title&amp;gt;
17
        &amp;lt;author&amp;gt;Erik T. Ray&amp;lt;/author&amp;gt;
18
        &amp;lt;year&amp;gt;2003&amp;lt;/year&amp;gt;
19
        &amp;lt;price&amp;gt;39.95&amp;lt;/price&amp;gt;
20
    &amp;lt;/book&amp;gt;
21
    &amp;lt;/bookstore&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;js中几种实用的跨域方法原理详解&quot;&gt;&lt;a href=&quot;#js中几种实用的跨域方法原理详解&quot; class=&quot;headerlink&quot; title=&quot;js中几种实用的跨域方法原理详解&quot;&gt;&lt;/a&gt;js中几种实用的跨域方法原理详解&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/2050/p/3191744.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考博客&lt;/a&gt;  &lt;/p&gt;
&lt;h3 id=&quot;ajax的简单发送&quot;&gt;&lt;a href=&quot;#ajax的简单发送&quot; class=&quot;headerlink&quot; title=&quot;ajax的简单发送&quot;&gt;&lt;/a&gt;ajax的简单发送&lt;/h3&gt;&lt;p&gt;前段代码  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script&amp;gt;
document.getElementById(&amp;quot;search&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;GET&amp;quot;, &amp;quot;server.php?number=&amp;quot; + document.getElementById(&amp;quot;keyword&amp;quot;).value);
    request.send();
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = request.responseText;
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}

document.getElementById(&amp;quot;save&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;POST&amp;quot;, &amp;quot;server.php&amp;quot;);
    var data = &amp;quot;name=&amp;quot; + document.getElementById(&amp;quot;staffName&amp;quot;).value 
                      + &amp;quot;&amp;amp;number=&amp;quot; + document.getElementById(&amp;quot;staffNumber&amp;quot;).value 
                      + &amp;quot;&amp;amp;sex=&amp;quot; + document.getElementById(&amp;quot;staffSex&amp;quot;).value 
                      + &amp;quot;&amp;amp;job=&amp;quot; + document.getElementById(&amp;quot;staffJob&amp;quot;).value;
    request.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);
    request.send(data);
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = request.responseText;
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后台php代码：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;quot;参数错误&amp;quot;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;quot;没有找到员工。&amp;quot;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;quot;找到员工：员工编号：&amp;quot; . $value[&amp;quot;number&amp;quot;] . &amp;quot;，员工姓名：&amp;quot; . $value[&amp;quot;name&amp;quot;] . 
                              &amp;quot;，员工性别：&amp;quot; . $value[&amp;quot;sex&amp;quot;] . &amp;quot;，员工职位：&amp;quot; . $value[&amp;quot;job&amp;quot;];
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;quot;参数错误，员工信息填写不全&amp;quot;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;quot;员工：&amp;quot; . $_POST[&amp;quot;name&amp;quot;] . &amp;quot; 信息保存成功！&amp;quot;;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ajaxjson数据格式&quot;&gt;&lt;a href=&quot;#ajaxjson数据格式&quot; class=&quot;headerlink&quot; title=&quot;ajaxjson数据格式&quot;&gt;&lt;/a&gt;ajaxjson数据格式&lt;/h3&gt;&lt;p&gt;HTML：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script&amp;gt;
document.getElementById(&amp;quot;search&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;GET&amp;quot;, &amp;quot;serverjson.php?number=&amp;quot; + document.getElementById(&amp;quot;keyword&amp;quot;).value);
    request.send();
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                var data = JSON.parse(request.responseText);
                if (data.success) { 
                    document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = data.msg;
                } else {
                    document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = &amp;quot;出现错误：&amp;quot; + data.msg;
                }
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}

document.getElementById(&amp;quot;save&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;POST&amp;quot;, &amp;quot;serverjson.php&amp;quot;);
    var data = &amp;quot;name=&amp;quot; + document.getElementById(&amp;quot;staffName&amp;quot;).value 
                      + &amp;quot;&amp;amp;number=&amp;quot; + document.getElementById(&amp;quot;staffNumber&amp;quot;).value 
                      + &amp;quot;&amp;amp;sex=&amp;quot; + document.getElementById(&amp;quot;staffSex&amp;quot;).value 
                      + &amp;quot;&amp;amp;job=&amp;quot; + document.getElementById(&amp;quot;staffJob&amp;quot;).value;
    request.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);
    request.send(data);
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                var data = JSON.parse(request.responseText);
                if (data.success) { 
                    document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = data.msg;
                } else {
                    document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = &amp;quot;出现错误：&amp;quot; + data.msg;
                }
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ajaxjson php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;}&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;}&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] . 
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;}&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jqueryajax&quot;&gt;&lt;a href=&quot;#jqueryajax&quot; class=&quot;headerlink&quot; title=&quot;jqueryajax&quot;&gt;&lt;/a&gt;jqueryajax&lt;/h3&gt;&lt;p&gt;HTML：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script src=&amp;quot;jquery-3.1.1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function(){ 
    $(&amp;quot;#search&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;GET&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:80/ajax/serverjQueryjson.php?number=&amp;quot; + $(&amp;quot;#keyword&amp;quot;).val(),
            dataType: &amp;quot;json&amp;quot;,
            success: function(data) {
                if (data.success) { 
                    $(&amp;quot;#searchResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#searchResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });

    $(&amp;quot;#save&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;POST&amp;quot;,     
            url: &amp;quot;serverjson.php&amp;quot;,
            data: {
                name: $(&amp;quot;#staffName&amp;quot;).val(), 
                number: $(&amp;quot;#staffNumber&amp;quot;).val(), 
                sex: $(&amp;quot;#staffSex&amp;quot;).val(), 
                job: $(&amp;quot;#staffJob&amp;quot;).val()
            },
            dataType: &amp;quot;json&amp;quot;,
            success: function(data){
                if (data.success) { 
                    $(&amp;quot;#createResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#createResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jquery 后台 php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
//header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
header(&amp;apos;Access-Control-Allow-Origin:*&amp;apos;);
header(&amp;apos;Access-Control-Allow-Methods:POST,GET&amp;apos;);
header(&amp;apos;Access-Control-Allow-Credentials:true&amp;apos;); 
header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;}&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;}&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] . 
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;}&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jQueryjsonp：&quot;&gt;&lt;a href=&quot;#jQueryjsonp：&quot; class=&quot;headerlink&quot; title=&quot;jQueryjsonp：&quot;&gt;&lt;/a&gt;jQueryjsonp：&lt;/h3&gt;&lt;p&gt;HTML：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script src=&amp;quot;jquery-3.1.1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function(){ 
    $(&amp;quot;#search&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;GET&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:80/ajax/serverjQueryjsonp.php?number=&amp;quot; + $(&amp;quot;#keyword&amp;quot;).val(),
            dataType: &amp;quot;jsonp&amp;quot;,
            jsonp: &amp;quot;callback&amp;quot;,
            success: function(data) {
                if (data.success) {
                    $(&amp;quot;#searchResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#searchResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });

    $(&amp;quot;#save&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;POST&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:8000/ajaxdemo/serverjsonp.php&amp;quot;,
            data: {
                name: $(&amp;quot;#staffName&amp;quot;).val(), 
                number: $(&amp;quot;#staffNumber&amp;quot;).val(), 
                sex: $(&amp;quot;#staffSex&amp;quot;).val(), 
                job: $(&amp;quot;#staffJob&amp;quot;).val()
            },
            dataType: &amp;quot;json&amp;quot;,
            success: function(data){
                if (data.success) { 
                    $(&amp;quot;#createResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#createResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jqueryjsonp php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
//header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    $jsonp = $_GET[&amp;quot;callback&amp;quot;];
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;})&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;})&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] .
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;})&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Ajax的核心操作对象是xmlHttpRequest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　  简化操作步骤：实例化一个xmlHttpRequest对象 ==&amp;gt; 发送请求 ==&amp;gt; 接受响应 ==&amp;gt; 执行回调&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://blog.newbug.xyz/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://blog.newbug.xyz/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>css规范总结</title>
    <link href="http://blog.newbug.xyz/2016/03/29/css%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.newbug.xyz/2016/03/29/css规范总结/</id>
    <published>2016-03-29T14:03:19.000Z</published>
    <updated>2016-07-30T02:41:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;CSS文件的分类和引用顺序&quot;&gt;&lt;a href=&quot;#CSS文件的分类和引用顺序&quot; class=&quot;headerlink&quot; title=&quot;CSS文件的分类和引用顺序&quot;&gt;&lt;/a&gt;CSS文件的分类和引用顺序&lt;/h3&gt;&lt;p&gt;通常，一个项目我们只引用一个CSS，但是对于较大的项目，我们需要把CSS文件进行分类。&lt;/p&gt;
&lt;p&gt;我们按照CSS的性质和用途，将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。&lt;/p&gt;
&lt;p&gt;2.特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。&lt;/p&gt;
&lt;p&gt;3.皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。&lt;/p&gt;
&lt;h3 id=&quot;CSS内部的分类及其顺序&quot;&gt;&lt;a href=&quot;#CSS内部的分类及其顺序&quot; class=&quot;headerlink&quot; title=&quot;CSS内部的分类及其顺序&quot;&gt;&lt;/a&gt;CSS内部的分类及其顺序&lt;/h3&gt;&lt;p&gt;1.重置（reset）和默认（base）（tags）：消除默认样式和浏览器差异，并设置部分标签的初始样式，以减少后面的重复劳动！你可以根据你的网站需求设置！&lt;/p&gt;
&lt;p&gt;2.统一处理：建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式！&lt;/p&gt;
&lt;p&gt;3.布局（grid）（.g-）：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等！&lt;/p&gt;
&lt;p&gt;4.模块（module）（.m-）：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等！&lt;/p&gt;
&lt;p&gt;5.元件（unit）（.u-）：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等！&lt;/p&gt;
&lt;p&gt;6.功能（function）（.f-）：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用！&lt;/p&gt;
&lt;p&gt;7.皮肤（skin）（.s-）：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类！&lt;/p&gt;
&lt;p&gt;8.状态（.z-）：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现（.u-ipt.z-dis{}，.m-list li.z-sel{}），具体详见命名规则的扩展相关项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;全局：global.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全局样式为全站公用，为页面样式基础，页面中必须包含。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;结构：layout.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;页面结构类型复杂，并且公用类型较多时使用。多用在首页级页面和产品类页面中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;私有：style.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;独立页面所使用的样式文件，页面中必须包含。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;模块 module.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;产品类页面应用，将可复用类模块进行剥离后，可与其它样式配合使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主题 themes.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现换肤功能时应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;补丁 mend.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;功能类和皮肤类样式为表现化的样式，请不要滥用！以上顺序可以按需求适当调整。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 重置 */
div,p,ul,ol,li{margin:0;padding:0;}
/* 默认 */
strong,em{font-style:normal;font-weight:bold;}
/* 统一调用背景图 */
.m-logo a,.m-nav a,.m-nav em{background:url(images/sprite.png) no-repeat 9999px 9999px;}
/* 统一清除浮动 */
.g-bdc:after,.m-dimg ul:after,.u-tab:after{display:block;visibility:hidden;clear:both;height:0;overflow:hidden;content:&amp;apos;.&amp;apos;;}
.g-bdc,.m-dimg ul,.u-tab{zoom:1;}
/* 布局 */
.g-sd{float:left;width:300px;}
/* 模块 */
.m-logo{width:200px;height:50px;}
/* 元件 */
.u-btn{height:20px;border:1px solid #333;}
/* 功能 */
.f-tac{text-align:center;}
/* 皮肤 */
.s-fc,a.s-fc:hover{color:#fff;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;选择器顺序&quot;&gt;&lt;a href=&quot;#选择器顺序&quot; class=&quot;headerlink&quot; title=&quot;选择器顺序&quot;&gt;&lt;/a&gt;选择器顺序&lt;/h3&gt;&lt;p&gt;请综合考虑以下顺序依据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从大到小（以选择器的范围为准）&lt;/li&gt;
&lt;li&gt;从低到高（以等级上的高低为准）&lt;/li&gt;
&lt;li&gt;从先到后（以结构上的先后为准）&lt;/li&gt;
&lt;li&gt;从父到子（以结构上的嵌套为准）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下仅为简单示范：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 从大到小 */
.m-list p{margin:0;padding:0;}
.m-list p.part{margin:1px;padding:1px;}
/* 从低到高 */
.m-logo a{color:#f00;}
.m-logo a:hover{color:#fff;}
/* 从先到后 */
.g-hd{height:60px;}
.g-bd{height:60px;}
.g-ft{height:60px;}
/* 从父到子 */
.m-list{width:300px;}
.m-list .itm{float:left;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;最佳选择器写法（模块）&quot;&gt;&lt;a href=&quot;#最佳选择器写法（模块）&quot; class=&quot;headerlink&quot; title=&quot;最佳选择器写法（模块）&quot;&gt;&lt;/a&gt;最佳选择器写法（模块）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/* 这是某个模块 */
.m-nav{}/* 模块容器 */
.m-nav li,.m-nav a{}/* 先共性  优化组合 */
.m-nav li{}/* 后个性  语义化标签选择器 */
.m-nav a{}/* 后个性中的共性 按结构顺序 */
.m-nav a.a1{}/* 后个性中的个性 */
.m-nav a.a2{}/* 后个性中的个性 */
.m-nav .z-crt a{}/* 交互状态变化 */
.m-nav .z-crt a.a1{}
.m-nav .z-crt a.a2{}
.m-nav .btn{}/* 典型后代选择器 */
.m-nav .btn-1{}/* 典型后代选择器扩展 */
.m-nav .btn-dis{}/* 典型后代选择器扩展（状态） */
.m-nav .btn.z-dis{}/* 作用同上，请二选一（如果可以不兼容IE6时使用） */
.m-nav .m-sch{}/* 控制内部其他模块位置 */
.m-nav .u-sel{}/* 控制内部其他元件位置 */
.m-nav-1{}/* 模块扩展 */
.m-nav-1 li{}
.m-nav-dis{}/* 模块扩展（状态） */
.m-nav.z-dis{}/* 作用同上，请二选一（如果可以不兼容IE6时使用） */
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;统一语义理解和命名&quot;&gt;&lt;a href=&quot;#统一语义理解和命名&quot; class=&quot;headerlink&quot; title=&quot;统一语义理解和命名&quot;&gt;&lt;/a&gt;统一语义理解和命名&lt;/h3&gt;&lt;h4 id=&quot;布局（-g-）&quot;&gt;&lt;a href=&quot;#布局（-g-）&quot; class=&quot;headerlink&quot; title=&quot;布局（.g-）&quot;&gt;&lt;/a&gt;布局（.g-）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;语义    命名    简写
文档    doc    doc
头部    head    hd
主体    body    bd
尾部    foot    ft
主栏    main    mn
主栏子容器    mainc    mnc
侧栏    side    sd
侧栏子容器    sidec    sdc
盒容器    wrap/box    wrap/box
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;模块（-m-）、元件（-u-）&quot;&gt;&lt;a href=&quot;#模块（-m-）、元件（-u-）&quot; class=&quot;headerlink&quot; title=&quot;模块（.m-）、元件（.u-）&quot;&gt;&lt;/a&gt;模块（.m-）、元件（.u-）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;语义    命名    简写
导航    nav    nav
子导航    subnav    snav
面包屑    crumb    crm
菜单    menu    menu
选项卡    tab    tab
标题区    head/title    hd/tt
内容区    body/content    bd/ct
列表    list    lst
表格    table    tb
表单    form    fm
热点    hot    hot
排行    top    top
登录    login    log
标志    logo    logo
广告    advertise    ad
搜索    search    sch
幻灯    slide    sld
提示    tips    tips
帮助    help    help
新闻    news    news
下载    download    dld
注册    regist    reg
投票    vote    vote
版权    copyright    cprt
结果    result    rst
标题    title    tt
按钮    button    btn
输入    input    ipt
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;功能（-f-）&quot;&gt;&lt;a href=&quot;#功能（-f-）&quot; class=&quot;headerlink&quot; title=&quot;功能（.f-）&quot;&gt;&lt;/a&gt;功能（.f-）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;语义    命名    简写
浮动清除    clearboth    cb
向左浮动    floatleft    fl
向右浮动    floatright    fr
内联块级    inlineblock    ib
文本居中    textaligncenter    tac
文本居右    textalignright    tar
文本居左    textalignleft    tal
垂直居中    verticalalignmiddle    vam
溢出隐藏    overflowhidden    oh
完全消失    displaynone    dn
字体大小    fontsize    fs
字体粗细    fontweight    fw
皮肤（.s-）
语义    命名    简写
字体颜色    fontcolor    fc
背景    background    bg
背景颜色    backgroundcolor    bgc
背景图片    backgroundimage    bgi
背景定位    backgroundposition    bgp
边框颜色    bordercolor    bdc
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;状态（-z-）&quot;&gt;&lt;a href=&quot;#状态（-z-）&quot; class=&quot;headerlink&quot; title=&quot;状态（.z-）&quot;&gt;&lt;/a&gt;状态（.z-）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;语义    命名    简写
选中    selected    sel
当前    current    crt
显示    show    show
隐藏    hide    hide
打开    open    open
关闭    close    close
出错    error    err
不可用    disabled    dis
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;CSS命名规范-规则-常用的CSS命名规则&quot;&gt;&lt;a href=&quot;#CSS命名规范-规则-常用的CSS命名规则&quot; class=&quot;headerlink&quot; title=&quot;CSS命名规范(规则)常用的CSS命名规则&quot;&gt;&lt;/a&gt;CSS命名规范(规则)常用的CSS命名规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;　　头：header
　　内容：content/container
　　尾：footer
　　导航：nav
　　侧栏：sidebar
　　栏目：column
　　页面外围控制整体佈局宽度：wrapper
　　左右中：left right center
　　登录条：loginbar
　　标志：logo
　　广告：banner
　　页面主体：main
　　热点：hot
　　新闻：news
　　下载：download
　　子导航：subnav
　　菜单：menu
　　子菜单：submenu
　　搜索：search
　　友情链接：friendlink
　　页脚：footer
　　版权：copyright
　　滚动：scroll
　　内容：content
　　标签：tags
　　文章列表：list
　　提示信息：msg
　　小技巧：tips
　　栏目标题：title
　　加入：joinus
　　指南：guide
　　服务：service
　　注册：regsiter
　　状态：status
　　投票：vote
　　合作伙伴：partner
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;注释的写法&quot;&gt;&lt;a href=&quot;#注释的写法&quot; class=&quot;headerlink&quot; title=&quot;注释的写法:&quot;&gt;&lt;/a&gt;注释的写法:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;　　/* Header */
　　内容区
　　/* End Header */
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Id的命名&quot;&gt;&lt;a href=&quot;#Id的命名&quot; class=&quot;headerlink&quot; title=&quot;Id的命名:&quot;&gt;&lt;/a&gt;Id的命名:&lt;/h4&gt;&lt;h5 id=&quot;1-页面结构&quot;&gt;&lt;a href=&quot;#1-页面结构&quot; class=&quot;headerlink&quot; title=&quot;1)页面结构&quot;&gt;&lt;/a&gt;1)页面结构&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;　　容器: container
　　页头：header
　　内容：content/container
　　页面主体：main
　　页尾：footer
　　导航：nav
　　侧栏：sidebar
　　栏目：column
　　页面外围控制整体佈局宽度：wrapper
　　左右中：left right center
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;2-导航&quot;&gt;&lt;a href=&quot;#2-导航&quot; class=&quot;headerlink&quot; title=&quot;(2)导航&quot;&gt;&lt;/a&gt;(2)导航&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;　　导航：nav
　　主导航：mainnav
　　子导航：subnav
　　顶导航：topnav
　　边导航：sidebar
　　左导航：leftsidebar
　　右导航：rightsidebar
　　菜单：menu
　　子菜单：submenu
　　标题: title
　　摘要: summary
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;3-功能&quot;&gt;&lt;a href=&quot;#3-功能&quot; class=&quot;headerlink&quot; title=&quot;(3)功能&quot;&gt;&lt;/a&gt;(3)功能&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;　　标志：logo
　　广告：banner
　　登陆：login
　　登录条：loginbar
　　注册：register
　　搜索：search
　　功能区：shop
　　标题：title
　　加入：joinus
　　状态：status
　　按钮：btn
　　滚动：scroll
　　标籤页：tab
　　文章列表：list
　　提示信息：msg
　　当前的: current
　　小技巧：tips
　　图标: icon
　　注释：note
　　指南：guild
　　服务：service
　　热点：hot
　　新闻：news
　　下载：download
　　投票：vote
　　合作伙伴：partner
　　友情链接：link
　　版权：copyright
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;CSS样式表文件命名&quot;&gt;&lt;a href=&quot;#CSS样式表文件命名&quot; class=&quot;headerlink&quot; title=&quot;CSS样式表文件命名&quot;&gt;&lt;/a&gt;CSS样式表文件命名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;　　主要的 master.css
　　模块 module.css
　　基本共用 base.css
　　布局、版面 layout.css
　　主题 themes.css
　　专栏 columns.css
　　文字 font.css
　　表单 forms.css
　　补丁 mend.css
　　打印 print.css
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS文件的分类和引用顺序&quot;&gt;&lt;a href=&quot;#CSS文件的分类和引用顺序&quot; class=&quot;headerlink&quot; title=&quot;CSS文件的分类和引用顺序&quot;&gt;&lt;/a&gt;CSS文件的分类和引用顺序&lt;/h3&gt;&lt;p&gt;通常，一个项目我们只引用一个CSS，但是对于较大的项目，我们需要把CSS文件进行分类。&lt;/p&gt;
&lt;p&gt;我们按照CSS的性质和用途，将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.newbug.xyz/categories/css/"/>
    
    
      <category term="css" scheme="http://blog.newbug.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>总结</title>
    <link href="http://blog.newbug.xyz/2016/03/27/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.newbug.xyz/2016/03/27/工作总结/</id>
    <published>2016-03-27T06:17:18.000Z</published>
    <updated>2016-10-31T08:58:18.000Z</updated>
    
    <content type="html">&lt;p&gt;总是碰到各种各样的问题，还老是被批评，时刻总结一下总是个好习惯。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h3&gt;&lt;p&gt;因为代码规范的问题，我没少挨骂，对于一名工程师来说，写出规范代码是基本的要求，不仅能方便你后期的维护，还能让别人看懂你的代码。同时，代码规范涉及很多方面的内容，在此作出总结：&lt;/p&gt;
&lt;p&gt;1.命名规范。类名可以多次使用，但是ID名只能使用一次。别让组长在html结构中找出重复的ID名字，也别让组长在css中找到重复的类名，所以为新元素命名的时候要注意检查原来的css中有没有这个类了。还有就是命名要用英文，别用拼音。&lt;/p&gt;
&lt;p&gt;2.图片的使用规范。首先你应该根据最适合自己的方式切图，不要只是依靠UI切图，因为别人不懂如何才能更方便地布局。&lt;/p&gt;
&lt;p&gt;3.注释规范。可能页面当中有很多你曾经引入的js或者css，但是最后你用压缩技术把他们压缩为一个js了，就不能把原来的删除，而要注释掉，这样是为了别人能看到你的引用内容。如果你复制这个页面的时候，很可能会忘记修改注释内容，我曾经因为觉得无所谓就被骂了几次。另外有一个问题就是不用的引入不要想着注释掉或者留着不碍事， 不用的东西也应该删除。&lt;/p&gt;
&lt;p&gt;4.css书写规范。重复的样式应该去掉，相近的元素应该放在一起书写，方便修改。即使后面加入的元素也不要写在最后面，应该写在相近处。&lt;/p&gt;
&lt;p&gt;5.js书写规范。js是比较复杂的东西，而且涉及功能，要写得简单明了，只用一次的函数不必封装，自己写就行了，多次使用的就需要封装起来，方便调用。写js要用ID名确定唯一性，不能用类名，切记切记。代码之间要有空行，运算符号之间要加空格，更规范，别人也看得舒服。&lt;/p&gt;
&lt;p&gt;6.文件管理规范。不用的文件应该删除，图片尽量放上七牛上面进行引用。&lt;/p&gt;
&lt;p&gt;以上是代码和文件规范方面的问题，希望自己能够从这些细节中渐渐改进，长点记性，从而让自己工作更有信心。&lt;/p&gt;
&lt;h3 id=&quot;态度问题&quot;&gt;&lt;a href=&quot;#态度问题&quot; class=&quot;headerlink&quot; title=&quot;态度问题&quot;&gt;&lt;/a&gt;态度问题&lt;/h3&gt;&lt;p&gt;对于新人来说，代码写不好，经常出bug是正常现象，只要你态度端正，意识到自己的错误，在工作中再细心，认真一点，其实很多问题都可以避免的，在此总结我的态度问题。&lt;br&gt;1.做事马虎，不认真。其实我对工作是有激情的，就是太懒了，每次做新功能都是做完就好，不求完美，但求无错，问题是你觉得你做得完美了，但是别人眼中，却是错漏百出，特别是一些严谨的工程师。因为不认真检查，导致命名出错，代码重复，出bug。后来我发现其实只要认真检查一遍，就能找出问题并解决。&lt;/p&gt;
&lt;p&gt;2.经常甩锅。做项目是一个多人协作的过程，当我出现问题的时候，我总想把责任推卸给别人，其实根本是自己的能力问题，导致做不出来产品需要的效果嘛，这样的人其实在职场中是非常令人反感的，特别是你的领导是一个不愿意甩锅的人。&lt;/p&gt;
&lt;p&gt;3.不懂装懂。组长无数次提醒我，不懂的东西要问，做不能了的东西要说，别硬撑着，到时候出事了很麻烦，因为刚开始我觉得自己啥都能做，暂时不懂的东西可以慢慢弄懂。不过我忽略了这是职场，不是学校，没有时间给你慢慢弄懂的，因为测试等着你的产品测试，用户等着你的产品用啊，骚年。&lt;/p&gt;
&lt;p&gt;主要就是上面几个态度的问题，一个做事严谨，肯负责任的人，才是能成为大工程师的人。&lt;/p&gt;
&lt;h3 id=&quot;该优化的地方没有优化&quot;&gt;&lt;a href=&quot;#该优化的地方没有优化&quot; class=&quot;headerlink&quot; title=&quot;该优化的地方没有优化&quot;&gt;&lt;/a&gt;该优化的地方没有优化&lt;/h3&gt;&lt;p&gt;其实这也是懒惰的表现，因为完成了任务了嘛，但是我的组长是个非常严格的人。产品叫你加一个二维码，我加了，但是样式了ui稿有冲突，整体非常不协调，我觉得没事，反正我的目的达成了，可是组长看到了一顿骂，你看这网站的风格基本是圆润的，你突然搞了个标准90度大箭头在这里，二维码也是小气得可怜，另外这个网站完全没有做seo优化……&lt;br&gt;区分一个优秀的人和一个平庸的人很简单，就是看你做事的态度，区分一个工程师和码农的区别也很简单，就是看你对待程序的态度，是应付，还是为了做得更好。&lt;/p&gt;
&lt;p&gt;其实代码没那么难，难得是你的态度，借此反思总结自身不足，保证以后不犯，也以此告诫各位前端新人，要保持严谨的态度对待你的程序。共勉&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;总是碰到各种各样的问题，还老是被批评，时刻总结一下总是个好习惯。&lt;br&gt;
    
    </summary>
    
      <category term="前端总结" scheme="http://blog.newbug.xyz/categories/%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>js笔记</title>
    <link href="http://blog.newbug.xyz/2016/03/14/js%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.newbug.xyz/2016/03/14/js笔记/</id>
    <published>2016-03-14T07:17:43.000Z</published>
    <updated>2016-10-15T09:54:18.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;js位置篇之窗口&quot;&gt;&lt;a href=&quot;#js位置篇之窗口&quot; class=&quot;headerlink&quot; title=&quot;js位置篇之窗口&quot;&gt;&lt;/a&gt;js位置篇之窗口&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;//屏幕大小
window.screen.width;
window.screen.height;

//视图
window.innerWidth;
window.innerHeight;
document.documentElement.clientWidth;
document.documentElement.clientHeight;

//页面的大小
document.documentElement.offsetWidth;
document.documentElement.offsetHeight;
document.body.clientWidth;
document.body.clientHeight;

//滚动条的位置
document.documentElement.scrollLeft;
document.documentElement.scrollTop;
document.body.scrollTop;
document.body.scrollLeft;

//跨浏览器获取滚动条的位置
function getScroll(){
    return {
        top : document.documentElement.scrollTop || document.body.scrollTop,
        left : document.documentElement.scrollLeft || document.body.scrollLeft
    }
}
var scroll = getScroll();
scroll.top;
scroll.left;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;location&quot;&gt;&lt;a href=&quot;#location&quot; class=&quot;headerlink&quot; title=&quot;location&quot;&gt;&lt;/a&gt;location&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//修改当前地址
//location.href=&amp;apos;http://www.baidu.com&amp;apos;;
//刷新当前页面
//location.reload();  
//确认取消框
// var result = window.confirm(&amp;apos;您的URL地址不对，请重新输入&amp;apos;);  
//输入框
//第一个参数是提示文字，第二个参数是默认值
//window.prompt(&amp;apos;请输入一个数字&amp;apos;,0);  
//打开一个窗口
//open接收三个参数，第一个参数是跳转的URL，第二个参数可以指定窗口名称
//第三个参数width,height,top,left,location,menubar可以设置窗口属性
//window.open(&amp;apos;http://www.baidu.com&amp;apos;,&amp;apos;baidu&amp;apos;,&amp;apos;width=300,height=400,top=500,left=300,location=true,menubar=true&amp;apos;);  
// 250
// //怎么用循环的方式获取到每位的值
// (250 / 100)
// (250 % 100) / 10
// 250 % 10  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Array内置方法&quot;&gt;&lt;a href=&quot;#Array内置方法&quot; class=&quot;headerlink&quot; title=&quot;Array内置方法&quot;&gt;&lt;/a&gt;Array内置方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var list1 = [3,4,1,2,5,7,6];
var list2 = [7,8,9,10,11,12];
//获取数组值
// var result = list1.valueOf();
// console.log(result);//[3,4,1,2,5,7,6]
//分割成指定分隔符的字符串
// var result = list1.join(&amp;apos;!&amp;apos;);
// console.log(result);//3!4!1!2!5!7!6
//在前面添加一个元素,返回的是数组的长度
// list1.unshift(0);
// console.log(list1);//[0, 3, 4, 1, 2, 5, 7, 6]
//在前面删除一个元素
// list1.shift(0);
// console.log(list1);
//颠倒位置
//var result = list1.reverse();
//console.log(result);
//sort排序, 正向排序
// var result = list2.sort();
// console.log(result);//[10, 11, 12, 7, 8, 9]
//连接数组
// var result = list1.concat(list2);
// console.log(result);//[3, 4, 1, 2, 5, 7, 6, 7, 8, 9, 10, 11, 12]
//删除或者替换数组内容
//splice(位置,删除的个数,替换的内容)
// var result = list1.splice(0,2,10);
// console.log(list1);//[10, 1, 2, 5, 7, 6]  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;date对象的学习&quot;&gt;&lt;a href=&quot;#date对象的学习&quot; class=&quot;headerlink&quot; title=&quot;date对象的学习&quot;&gt;&lt;/a&gt;date对象的学习&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var today = new Date();
//获取当前时间的毫秒数
var hm = today.getTime();
console.log(hm);
var year = today.getFullYear();
console.log(year);
var month = today.getMonth();
console.log(month);
//获取日期
var day = today.getDate();
console.log(day);
var week = today.getDay();
console.log(week);
var hour = today.getHours();
console.log(hour);
var min = today.getMinutes();
console.log(min);
var second = today.getSeconds();
console.log(second);
//获取毫秒
var milsecond = today.getMilliseconds();
console.log(milsecond);  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;string类型内置方法&quot;&gt;&lt;a href=&quot;#string类型内置方法&quot; class=&quot;headerlink&quot; title=&quot;string类型内置方法&quot;&gt;&lt;/a&gt;string类型内置方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var str1 = &amp;apos;我是新创建的第一个字符串&amp;apos;;
var str2 = &amp;apos;我是创建的第二个字符串&amp;apos;;
// var result = [];
// for(var i=0;i&amp;lt;str1.length;i++){

//     //选取每一个字符对应的数组下标
//     var index = i;
//     result.push(str1[index] + &amp;apos;0&amp;apos;);
// }
// alert(result);
// alert(str1);

// // 返回指定位置的字符
// var result = str1.charAt(2);
// console.log(result);
// //返回指定位置的字符，但是是以unicode格式返回的
// var result = str1.charCodeAt(2);
// console.log(result);
// //连接字符串的
// result = str1.concat(str2);
// console.log(result);
// //三个截取字符串的函数slice,substring,substr
// //一个参数的情况
// var result = str1.slice(2);
// console.log(result);
// var result = str1.substring(2);
// console.log(result);
// var result = str1.substr(2);
// console.log(result);
// var result = str1.slice(-1);
// console.log(result);
// var result = str1.substr(-1);
// console.log(result);
// //substring负数情况不允许
// var result = str1.substring(-3);
// console.log(result);

//两个参数的情况
//slice和substring是截取的从N开始M结束之间的字符串
//substr它是截取从N开始,M个字符串
var result = str1.slice(1,4);
console.log(result);
var result = str1.substring(1,4);
console.log(result);
//从1开始，截取四个
var result = str1.substr(0,4);
console.log(result);
//返回索引值
var result = str1.indexOf(&amp;apos;的&amp;apos;);
console.log(result);
//lastIndexOf返回最后一个字符串出现的位置
var result = str1.lastIndexOf(&amp;apos;的&amp;apos;);
console.log(result);
//tolowercase,touppercase分别是转化大小写的
var str3 = &amp;apos;HELLO&amp;apos;;
var str4 = &amp;apos;world&amp;apos;;
console.log(str3.toLowerCase());
document.write(str4.toUpperCase());
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js位置篇之窗口&quot;&gt;&lt;a href=&quot;#js位置篇之窗口&quot; class=&quot;headerlink&quot; title=&quot;js位置篇之窗口&quot;&gt;&lt;/a&gt;js位置篇之窗口&lt;/h3&gt;
    
    </summary>
    
    
      <category term="js笔记" scheme="http://blog.newbug.xyz/tags/js%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>angularjs</title>
    <link href="http://blog.newbug.xyz/2016/03/06/angularjs/"/>
    <id>http://blog.newbug.xyz/2016/03/06/angularjs/</id>
    <published>2016-03-06T10:22:39.000Z</published>
    <updated>2016-07-14T12:14:22.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;jQuery：用更少的代码，实现更强悍的功能&quot;&gt;&lt;a href=&quot;#jQuery：用更少的代码，实现更强悍的功能&quot; class=&quot;headerlink&quot; title=&quot;jQuery：用更少的代码，实现更强悍的功能&quot;&gt;&lt;/a&gt;jQuery：用更少的代码，实现更强悍的功能&lt;/h2&gt;&lt;p&gt;托互联网日新月异发展的福，浏览器变成了人们接入互联网的入口，而JavaScript 这个曾经的小语种，终于成功地站到了舞台的中央，唤起了开发者的兴趣。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;浏览器里原生的JavaScript有点像汇编语言，不同的浏览器就像不同的CPU架构， 汇编语言各有千秋，这让前端开发者很恼火。聪明人很快发现了这个痛点，于是， 抹平浏览器差异的jQuery库出现了。&lt;br&gt;jQuery由一小撮对浏览器极其熟稔的极客负责抹平不同浏览器的差异，其他开发 者只需要基于jQuery进行开发，可以更好地关注业务实现，而不是把时间花在 适配不同的浏览器上。&lt;br&gt;这样的分工符合经济学原理，开启了一个不可忽视的jQuery时代&lt;/p&gt;
&lt;h2 id=&quot;满眼的全是DOM&quot;&gt;&lt;a href=&quot;#满眼的全是DOM&quot; class=&quot;headerlink&quot; title=&quot;满眼的全是DOM&quot;&gt;&lt;/a&gt;满眼的全是DOM&lt;/h2&gt;&lt;p&gt;jQuery使得开发无刷新动态页面（AJAX）或者单页应用（SPA）变得 相当简单。&lt;br&gt;标准的HTML页面是静态的，被浏览器渲染后就产生了一个DOM树：&lt;br&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;jQuery让静态的文档动起来，通过提供一系列的选择符，jQuery使开发者能够 极其方便地选中一组DOM节点，对其进行操作。&lt;br&gt;这就是jQuery的开发范式。jQuery没有引入什么新的概念，只是朴素地，让你能够更简单 地、低成本地操作DOM：&lt;br&gt;1.用选择符选定一组DOM节点&lt;br&gt;2.操作选中的DOM节点，比如：修改文本、改变属性、挂接事件监听函数、变换DOM等等。&lt;br&gt;3.基本不用考虑跨浏览器的兼容性&lt;/p&gt;
&lt;p&gt;jQuery的API符合大多数开发者的预期，因此，很容易上手。&lt;/p&gt;
&lt;h2 id=&quot;jQuery缺失的环节&quot;&gt;&lt;a href=&quot;#jQuery缺失的环节&quot; class=&quot;headerlink&quot; title=&quot;jQuery缺失的环节&quot;&gt;&lt;/a&gt;jQuery缺失的环节&lt;/h2&gt;&lt;p&gt;jQuery有点像C语言，威力很大，不过要弄出点像样的前端界面，还得花不少功夫 处理琐碎的事情。&lt;br&gt;还能再简单些吗？Misko Hevery认为在某些应用场景下可以。于是，AngularJS诞生了：&lt;/p&gt;
&lt;p&gt;AngularJS引入了三个主要的概念，期望让前端开发更系统化一些：&lt;br&gt;&lt;b&gt;1.声明式界面开发&lt;br&gt;2.双向数据绑定&lt;br&gt;3.使用依赖注入解耦  &lt;/b&gt;&lt;br&gt;很多人在初次接触AngularJS时，都有些吃惊，因为它把前端开发搞的突然严肃起来 了。考虑到Misko曾经是一个Java程序员，这一切就好理解了。&lt;br&gt;Java程序员擅长引入复杂的架构来解决简单的问题，对吧？&lt;br&gt;&lt;!---more---&gt;&lt;/p&gt;
&lt;h2 id=&quot;库-vs-框架&quot;&gt;&lt;a href=&quot;#库-vs-框架&quot; class=&quot;headerlink&quot; title=&quot;库 vs. 框架&quot;&gt;&lt;/a&gt;库 vs. 框架&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;jQuery是一个库，库总是被动的，就像工具，应用的开发逻辑是你的，在 某一点上需要用一下工具，就用好了。&lt;br&gt;框架则非常不同，这意味着AngularJS为应用已经搭起了一个架子，约定了 一些组成部分，并且实现了这些部分的拼装运行。换句话说， 应用的开发逻辑是AngularJS的，你得跟着它走。&lt;br&gt;所以，AngularJS难学一些，因为它有一个架子在那，你不了解这个架子， 基本没法下手。  &lt;/p&gt;
&lt;h2 id=&quot;重写示例：模板、指令和视图&quot;&gt;&lt;a href=&quot;#重写示例：模板、指令和视图&quot; class=&quot;headerlink&quot; title=&quot;重写示例：模板、指令和视图&quot;&gt;&lt;/a&gt;重写示例：模板、指令和视图&lt;/h2&gt;&lt;p&gt;AngularJS最显著的特点是用静态的HTML文档，就可以生成具有动态行为的页面。&lt;br&gt;还是前面的小时钟示例，我们使用AngularJS模板来重写，示例已经嵌入→_→：&lt;br&gt;HTML文件看起来像普通的HTML，只是其中多了一些特别的标记 （比如：ng-app,ez-clock等等）。在Angular中，这个HTML文件被称为模板。&lt;br&gt;ng-app这样的标记我们称之为指令。模板通过指令指示AngularJS进行必要的操作。 比如：ng-app指令用来通知AngularJS自动引导应用；ez-clock 指令用来通知AngularJS生成指定的时钟组件。&lt;br&gt;当AngularJS启动应用时，它会通过一个编译器解析处理这个模板文件，生成的结果就是： 视图：&lt;br&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们定义了两个部件：模板（包含指令的HTML文件）和指令实现 （JavaScript文件），AngularJS将这两部分拼装起来，生成了最终的视图。&lt;br&gt;有点理解框架的含义了吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;angular.module(&amp;quot;ezstuff&amp;quot;,[])//创建模块ezstuff
.directive(&amp;quot;ezClock&amp;quot;,function(){//在模块上注册指令ezClock的类工厂
    return {
        restrict : &amp;quot;E&amp;quot;,
        replace : true,
        template : &amp;quot;&amp;lt;div class=&amp;apos;clock&amp;apos;&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;,
        link : function(scope,element,attrs){
            setInterval(function(){
                //获取当前时间
                var d = new Date();

                //element对应引用该指令的DOM对象的jqLite封装
                element.text(d.toString());
            },1000);
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用指令封装JavaScript代码&quot;&gt;&lt;a href=&quot;#使用指令封装JavaScript代码&quot; class=&quot;headerlink&quot; title=&quot;使用指令封装JavaScript代码&quot;&gt;&lt;/a&gt;使用指令封装JavaScript代码&lt;/h2&gt;&lt;p&gt;我们在模板中使用了一个自定义的标签ez-clock，而他变成了一个会动的时钟，这期间发生了什么呢？&lt;/p&gt;
&lt;p&gt;可以肯定的是这肯定不是浏览器干的，他不认识ez-block是什么东西，angularjs引入了基本的angularjs库，他会在浏览器载入html文档并且建立好DOM树后，执行以下操作：&lt;/p&gt;
&lt;p&gt;1，找到有ng-app属性的DOM节点&lt;/p&gt;
&lt;p&gt;2，以这个节点为根节点，搜索自定义指令，发现ez-clock&lt;/p&gt;
&lt;p&gt;3，调用ez-clock指令的实现函数（指令类工厂）进行展开我们的定义，ez-clock的展开操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 使用一个div元素替换这个自定义标签
2 创建一个定时器，在定时器触发时刷新div元素的innerText
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ez-clock这样的非html标准的标签，在angularjs中之所以称之为指令/directive，就是只看到它时，基础框架需要对其进行解释，以便展开成浏览器可以理解的东西，而这个解释的过程称之为：编译。&lt;/p&gt;
&lt;p&gt;可见，angularjs框架要求将HTML文档和JavaScript代码分割的更清晰，通常混杂在HTML文档中的JavaScript代码，需要一直领的形式进行封装，而模板、指令实现代码这两个不见，则有基础框架负责拼装运行。&lt;/p&gt;
&lt;h2 id=&quot;起点：声明化&quot;&gt;&lt;a href=&quot;#起点：声明化&quot; class=&quot;headerlink&quot; title=&quot;起点：声明化&quot;&gt;&lt;/a&gt;起点：声明化&lt;/h2&gt;&lt;p&gt;基于前面的实例，我们很容易感受到angularjs进行应用开发的一个重要的思维模式：葱构造声明式界面入手。&lt;/p&gt;
&lt;p&gt;事实上，这也是misko开发angularjs最初的动机吧。&lt;br&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用angularjs进行开发时，始终应该从构造函数声明式界面模板开始，如果现在的指令不够，那么就定义自己的指令，实现自己的指令、实现自己的指令。这是一个选代的过程。&lt;/p&gt;
&lt;p&gt;记住：指令是新型的API，用界面的声明化作为需求，来指导我们的代码封装。&lt;/p&gt;
&lt;h2 id=&quot;层级的作用域&quot;&gt;&lt;a href=&quot;#层级的作用域&quot; class=&quot;headerlink&quot; title=&quot;层级的作用域&quot;&gt;&lt;/a&gt;层级的作用域&lt;/h2&gt;&lt;p&gt;在angularjs中，ng-app开始的DOM子树上，每个DOM对象都有一个对应的scope对象。比如，在我们的实例中，body对象对应一个scope对象，因为body这时候有ng-app属性，所以这个scope就是$rootscope对象，ez-clock对象也对应有一个scope对象……..&lt;br&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在默认情况下，一个DOM子元素不会创建新的作用域，也就是说，这个子元素所对应的scope对象，其实就是它的最近一级的祖先对象对应的scope对象。比如，在我们的例子上，ez-namecard对应的scope对象，就是它的父对象即body对象的scope对象，恰好也就是$rootScope对象；而ez-namecard有三个div子元素对应的scope对象，也就是$rootScope对象。&lt;/p&gt;
&lt;p&gt;有些指令会导致创建新的作用域，比如ng-controller。如果在一个DOM对象上创建了新的作用域，那么这个scope对象的原型是其最近一级的组件对象的scope对象。&lt;/p&gt;
&lt;p&gt;比如在我们的例子中，如果在ez-namecard上使用ng-controller指令，那么ez-namecard对应的scope对象就不会是body对应的$rootScope对象，但是由于原型继承，所以通过这个scope依然可以访问sb变量。&lt;/p&gt;
&lt;h2 id=&quot;监听数据的变化&quot;&gt;&lt;a href=&quot;#监听数据的变化&quot; class=&quot;headerlink&quot; title=&quot;监听数据的变化&quot;&gt;&lt;/a&gt;监听数据的变化&lt;/h2&gt;&lt;p&gt;我们已经实现了将数据显示到界面上，不过这还不够。&lt;br&gt;由于编译仅仅在启动引导时执行一次，这就意味着我们的link函数只会被调用一次，那么，如果数据变化，在界面上将不会有任何反馈，所以我们要监听数据的变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$watch(watchExpression listener ,[objecEquality])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;$watch 方法又三个参数：&lt;br&gt;    1，watchExpression - 要监听的表达式&lt;br&gt;    2，listener - 变化发生时的回调函数，angularjs将这个函数传入新值和旧值&lt;br&gt;    3，objectEquality - 如果要监听表达式的值是一个对象，应当将这个参数置为true&lt;/p&gt;
&lt;h2 id=&quot;数据变化的传播&quot;&gt;&lt;a href=&quot;#数据变化的传播&quot; class=&quot;headerlink&quot; title=&quot;数据变化的传播&quot;&gt;&lt;/a&gt;数据变化的传播&lt;/h2&gt;&lt;p&gt;数据绑定有两个方向：&lt;/p&gt;
&lt;p&gt;数据到界面：我们使用scope对象的$watch()方法监听数据的变化，来更新界面。&lt;/p&gt;
&lt;p&gt;界面到数据：我们在界面的DOM对象上监听变化时间，来更新数据，并通过$apply()方法传播变化。&lt;br&gt;&lt;img src=&quot;http://o9xxj2r73.bkt.clouddn.com/angularjs/6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;上面的图中，我们把ez-namecard和ez-namecard-editor都绑定到同一个sb对象上，那么在 ez-namecard-editor上进行编辑，将导致sb对象发生变化；由于ez-namecard监听了这个变化， 所以，ez-namecard的显示也应该变化。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jQuery：用更少的代码，实现更强悍的功能&quot;&gt;&lt;a href=&quot;#jQuery：用更少的代码，实现更强悍的功能&quot; class=&quot;headerlink&quot; title=&quot;jQuery：用更少的代码，实现更强悍的功能&quot;&gt;&lt;/a&gt;jQuery：用更少的代码，实现更强悍的功能&lt;/h2&gt;&lt;p&gt;托互联网日新月异发展的福，浏览器变成了人们接入互联网的入口，而JavaScript 这个曾经的小语种，终于成功地站到了舞台的中央，唤起了开发者的兴趣。
    
    </summary>
    
    
      <category term="angular" scheme="http://blog.newbug.xyz/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>JS全局污染</title>
    <link href="http://blog.newbug.xyz/2016/02/16/JS%E5%85%A8%E5%B1%80%E6%B1%A1%E6%9F%93/"/>
    <id>http://blog.newbug.xyz/2016/02/16/JS全局污染/</id>
    <published>2016-02-16T03:37:45.000Z</published>
    <updated>2016-10-10T09:04:16.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h2&gt;&lt;p&gt;1.用匿名函数将脚本包起来；&lt;/p&gt;
&lt;p&gt;2.使用多级命名空间。&lt;/p&gt;
&lt;p&gt;这第二条“使用多级命名空间”这个，我觉得并不是很完美的好主意。因为如果级数太多的话会造成变量名字变得长的一逼。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;改进过程&quot;&gt;&lt;a href=&quot;#改进过程&quot; class=&quot;headerlink&quot; title=&quot;改进过程&quot;&gt;&lt;/a&gt;改进过程&lt;/h2&gt;&lt;h3 id=&quot;原始代码&quot;&gt;&lt;a href=&quot;#原始代码&quot; class=&quot;headerlink&quot; title=&quot;原始代码&quot;&gt;&lt;/a&gt;原始代码&lt;/h3&gt;&lt;p&gt;没有做过任何优化的满目疮痍的代码。a.js 和 b.js 都有全局变量 window.a ，导致冲突，全局变量属于 window 作用域下的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//a.js
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    //都什么时代了，script标签还写type属性呢？黄牌警告！下次绝逼不写了。
    var a = 123, b = &amp;quot;hello world&amp;quot;;
&amp;lt;/script&amp;gt;

//b.js
&amp;lt;script&amp;gt;
    //看！这把没有写了吧~就是这么任性，上面的那个写了的也绝逼不改！
    var a, c = &amp;quot;abc&amp;quot;;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用匿名函数&quot;&gt;&lt;a href=&quot;#使用匿名函数&quot; class=&quot;headerlink&quot; title=&quot;使用匿名函数&quot;&gt;&lt;/a&gt;使用匿名函数&lt;/h3&gt;&lt;p&gt;通过匿名函数改变了a.js 和 b.js 中的变量 a 的作用域，使得他们都不再是全局变量了，但是在 b.js 中无法访问在 a.js 中的变量 a， 换而言之，他们之间没办法通信了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//a.js
(function() {
    var a = 123, b = &amp;quot;hello world&amp;quot;;
})();

//b.js
(function() {
    var a, c = &amp;quot;abc&amp;quot;;
})();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用全局变量进行通信&quot;&gt;&lt;a href=&quot;#使用全局变量进行通信&quot; class=&quot;headerlink&quot; title=&quot;使用全局变量进行通信&quot;&gt;&lt;/a&gt;使用全局变量进行通信&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var str;
//a.js
(function() {
    var a = 123,
    b = &amp;quot;hello world&amp;quot;;
    window.str = a;
})();

//b.js
(function() {
    var a, c = &amp;quot;abc&amp;quot;;
    alert(window.str);
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 window.str 这种全局全局变量作为通信的媒介其实并不是一个好办法，这样做会导致全局变量越来越多，反而不好维护。&lt;/p&gt;
&lt;h3 id=&quot;使用命名空间&quot;&gt;&lt;a href=&quot;#使用命名空间&quot; class=&quot;headerlink&quot; title=&quot;使用命名空间&quot;&gt;&lt;/a&gt;使用命名空间&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var GLOBAL = {};
//a.js
(function() {
    var a = 123,
    b = &amp;quot;hello world&amp;quot;;
    GLOBAL.A.a = a;
})();

//b.js
(function() {
    var a, c = &amp;quot;abc&amp;quot;;
    alert(GLOBAL.A.a);
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用单一的全局变量 GlOBAL ，匿名空间里需要保存的属性都在全局变量 GLOBAL 的基础上使用命名空间的方式进行拓展。这里给命名空间起名字也需要很讲究，好的命名规则会对团队协同合作有很大的帮助&lt;/p&gt;
&lt;h2 id=&quot;js一些常用的封装&quot;&gt;&lt;a href=&quot;#js一些常用的封装&quot; class=&quot;headerlink&quot; title=&quot;js一些常用的封装&quot;&gt;&lt;/a&gt;js一些常用的封装&lt;/h2&gt;&lt;p&gt;———————-解决兼容性方法———————–  &lt;/p&gt;
&lt;h3 id=&quot;获取元素的计算后样式属性&quot;&gt;&lt;a href=&quot;#获取元素的计算后样式属性&quot; class=&quot;headerlink&quot; title=&quot;获取元素的计算后样式属性&quot;&gt;&lt;/a&gt;获取元素的计算后样式属性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function getStyle(element,attr) {
    if (element.currentStyle) {
        return element.currentStyle[attr];
    }else{
        return window.getComputedStyle(element,null){
            return window.getComputedStyle(element,null)[attr];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;scroll-top-or-scroll-left获取已经滚动到元素的左边界或上边界的像素数&quot;&gt;&lt;a href=&quot;#scroll-top-or-scroll-left获取已经滚动到元素的左边界或上边界的像素数&quot; class=&quot;headerlink&quot; title=&quot;scroll().top or scroll().left获取已经滚动到元素的左边界或上边界的像素数&quot;&gt;&lt;/a&gt;scroll().top or scroll().left获取已经滚动到元素的左边界或上边界的像素数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function scroll() {
        return {
            top:window.pageYOffset || document.documentElement.scrollTop || document.body.scrollLeft || 0,
            left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
        };
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取可视窗口的大小&quot;&gt;&lt;a href=&quot;#获取可视窗口的大小&quot; class=&quot;headerlink&quot; title=&quot;获取可视窗口的大小&quot;&gt;&lt;/a&gt;获取可视窗口的大小&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function client() {
    return {
        width:window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth ||0,
        height:window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;event兼容&quot;&gt;&lt;a href=&quot;#event兼容&quot; class=&quot;headerlink&quot; title=&quot;event兼容&quot;&gt;&lt;/a&gt;event兼容&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//event兼容
var eventCompatible = {
    //event兼容
    getEvent: function(event) {
        return event || window.event;
    },

    //阻止冒泡事件
    stopPropagation: function(event) {
        var event = event || window.event;
        if(event &amp;amp;&amp;amp; event.stopPropagation) {
            return event.stopPropagation();
        } else {
            return event.cancelBubble = true;
        }
    },

    //event.target 事件的目标 (事件委托)
    getTarget: function(event) {
        var event = event || window.event;
        return event.target ? event.target : event.srcElement;
    },

    //鼠标页面坐标
    page: function(event) {
        var event = event || window.event;
        return {
            x: event.pageX || event.clientX + document.documentElement.scrollLeft,
            y: event.pageY || event.clientY + document.documentElement.scrollTop
        };
    },

    //阻止默认行为
    prevent: function(event){
        var event = event || window.event;
        if (event.preventDefault) {
            return event.preventDefault();
        }else{
            return event.returnValue = false;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;监听事件兼容处理&quot;&gt;&lt;a href=&quot;#监听事件兼容处理&quot; class=&quot;headerlink&quot; title=&quot;监听事件兼容处理&quot;&gt;&lt;/a&gt;监听事件兼容处理&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function eventListener(obj, type, handler, unbind) {
    if(unbind === true) {
        if(obj.removeEventListener) {
            obj.removeEventListener(type, handler);
        } else {
            obj.detachEvent(&amp;quot;on&amp;quot; + type, handler);
        };
    } else {
        if(obj.addEventListener) {
            obj.addEventListener(type, handler);
        } else {
            obj.attachEvent(&amp;quot;on&amp;quot; + type, handler);
        };
    };
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;清楚选择&quot;&gt;&lt;a href=&quot;#清楚选择&quot; class=&quot;headerlink&quot; title=&quot;清楚选择&quot;&gt;&lt;/a&gt;清楚选择&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function clearSelection() {
    return window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##——————-自定义的方法—————————&lt;/p&gt;
&lt;h3 id=&quot;trim去掉字符串两端的空格&quot;&gt;&lt;a href=&quot;#trim去掉字符串两端的空格&quot; class=&quot;headerlink&quot; title=&quot;trim去掉字符串两端的空格&quot;&gt;&lt;/a&gt;trim去掉字符串两端的空格&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function trim(str) {
    return str.replace(/^\s+|\s+$/g, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;十进制转其他进制-type类型有”bit”、”oct”、”hex”&quot;&gt;&lt;a href=&quot;#十进制转其他进制-type类型有”bit”、”oct”、”hex”&quot; class=&quot;headerlink&quot; title=&quot;十进制转其他进制 type类型有”bit”、”oct”、”hex”&quot;&gt;&lt;/a&gt;十进制转其他进制 type类型有”bit”、”oct”、”hex”&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function changeFromDec(type, value) {
    var arr = [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;F&amp;quot;]    
    var scale = 0;
    var sys = &amp;quot;&amp;quot;;
    if(!/^[\d]*$/g.test(value)) {
        return &amp;quot;&amp;quot;;
    }
    if(!value) {
        return &amp;quot;&amp;quot;;
    }
    if(type === &amp;quot;bit&amp;quot;) {
        scale = 2;
    } else if(type === &amp;quot;oct&amp;quot;) {
        scale = 8;
    } else if(type === &amp;quot;hex&amp;quot;) {
        scale = 16;
        while(true) {
            sys = arr[value % 16] + sys;
            value = parseInt(value / 16);
            if(!value) {
                break;
            }
        }
        return sys;
    }
    while(true) {
        sys = value % scale + sys;
        value = parseInt(value / scale);
        if(!value) {
            break;
        }
    }
    return sys;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二进制、八进制、十六进制转十进制&quot;&gt;&lt;a href=&quot;#二进制、八进制、十六进制转十进制&quot; class=&quot;headerlink&quot; title=&quot;二进制、八进制、十六进制转十进制;&quot;&gt;&lt;/a&gt;二进制、八进制、十六进制转十进制;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function toDec(type, value) {
    if(typeof value === &amp;quot;number&amp;quot;) value += &amp;quot;&amp;quot;;
    var scale = 0;
    var flag = false;
    if(type === &amp;quot;bit&amp;quot;) {
        flag = /^[01]*$/g.test(value);
        scale = 2;
    } else if(type === &amp;quot;oct&amp;quot;) {
        flag = /^[0-7]*$/g.test(value)
        scale = 8;
    } else if(type === &amp;quot;hex&amp;quot;) {
        flag = /^[0-9a-fA-F]*$/g.test(value)
        scale = 16;
    }
    if(!flag || !value) return;
    var arr = value.split(&amp;quot;&amp;quot;);
    var dec = 0;
    for(var i = 0; i &amp;lt; arr.length; i++) {
        if(isNaN(parseInt(arr[i]))) {
            var charCode = arr[i].charCodeAt(0);
            if(charCode &amp;gt; 64 &amp;amp;&amp;amp; charCode &amp;lt; 71) {
                dec += (charCode - 55) * Math.pow(scale, arr.length - 1 - i)
            } else if(charCode &amp;gt; 96 &amp;amp;&amp;amp; charCode &amp;lt; 103) {
                dec += (charCode - 87) * Math.pow(scale, arr.length - 1 - i)
            }
        } else {
            dec += arr[i] * Math.pow(scale, arr.length - 1 - i);
        }
    }
    return dec;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;转动时钟&quot;&gt;&lt;a href=&quot;#转动时钟&quot; class=&quot;headerlink&quot; title=&quot;转动时钟&quot;&gt;&lt;/a&gt;转动时钟&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function clock() {
    var d = new Date();
    var ms = d.getMilliseconds();
    var s = d.getSeconds() + ms / 1000;
    var m = d.getMinutes() + s / 60;
    var h = d.getHours() + m / 60;
    second.style.transform = &amp;quot;rotate(&amp;quot; + s * 6 + &amp;quot;deg)&amp;quot;;
    minute.style.transform = &amp;quot;rotate(&amp;quot; + m * 6 + &amp;quot;deg)&amp;quot;;
    hour.style.transform = &amp;quot;rotate(&amp;quot; + h * 30 + &amp;quot;deg)&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;匀速动画&quot;&gt;&lt;a href=&quot;#匀速动画&quot; class=&quot;headerlink&quot; title=&quot;匀速动画&quot;&gt;&lt;/a&gt;匀速动画&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function animate(obj, attr, distance) {
    var step = 20;
    var leader = parseInt(getStyle(obj, attr)) || 0
    clearInterval(obj.atimer);
    obj.atimer = setInterval(function() {
        distance &amp;gt; leader ? leader += step : leader -= step;
        if(Math.abs(distance - leader) &amp;gt; step) {
            obj.style[attr] = leader + &amp;quot;px&amp;quot;;
        } else {
            obj.style[attr] = distance + &amp;quot;px&amp;quot;;
            clearInterval(obj.atimer);
        }
    }, 15);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;缓动动画-单个数值属性&quot;&gt;&lt;a href=&quot;#缓动动画-单个数值属性&quot; class=&quot;headerlink&quot; title=&quot;缓动动画(单个数值属性)&quot;&gt;&lt;/a&gt;缓动动画(单个数值属性)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function slowSpeedAnimate(element, attr, distance) {
    clearInterval(element.timer);
    element.timer = setInterval(function() {
        var removing = parseInt(getStyle(element, attr)) || 0; //element.offsetLeft;
        var step = (distance - removing) / 20;
        step = step &amp;gt; 0 ? Math.ceil(step) : Math.floor(step);
        removing = removing + step;
        element.style[attr] = removing + &amp;quot;px&amp;quot;;
        if(removing == distance) {
            clearInterval(element.timer);
        }
    }, 15)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;缓动动画-多个数值属性&quot;&gt;&lt;a href=&quot;#缓动动画-多个数值属性&quot; class=&quot;headerlink&quot; title=&quot;缓动动画(多个数值属性)&quot;&gt;&lt;/a&gt;缓动动画(多个数值属性)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function moreAnimate(element, json, interval, fn) {
    clearInterval(element.timer);
    element.timer = setInterval(function() {
        var flag = true;
        for(var k in json) {
            if(k === &amp;quot;opacity&amp;quot;) {
                var removing = getStyle(element, k) * 100; //element.offsetLeft;
                var distance = json[k] * 100;
                var step = (distance - removing) / interval;
                step = step &amp;gt; 0 ? Math.ceil(step) : Math.floor(step);
                removing = removing + step;
                element.style[k] = removing / 100;
            } else {
                var removing = parseInt(getStyle(element, k)) || 0; //element.offsetLeft;
                var distance = json[k];
                var step = (distance - removing) / interval;
                step = step &amp;gt; 0 ? Math.ceil(step) : Math.floor(step);
                removing = removing + step;
                element.style[k] = removing + &amp;quot;px&amp;quot;;
            }
            if(removing != distance) {
                flag = false;
            }
        }
        if(flag) {
            clearInterval(element.timer);
            if(fn) {
                fn();
            }
        }

    }, 15)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;进度条&quot;&gt;&lt;a href=&quot;#进度条&quot; class=&quot;headerlink&quot; title=&quot;进度条&quot;&gt;&lt;/a&gt;进度条&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;    function Progress(id, width, height, outClass, inClass) {
    this.width = width;
    this.height = height;
    this.color = &amp;quot;#fff&amp;quot;;
    this.progress = document.createElement(&amp;quot;div&amp;quot;);
    this.percentage = document.createElement(&amp;quot;div&amp;quot;);
    this.filler = document.createElement(&amp;quot;div&amp;quot;);
    var element = document.getElementById(id);
    if(width) {
        this.progress.style.width = this.width + &amp;quot;px&amp;quot;;
    } else {
        this.progress.style.width = &amp;quot;200px&amp;quot;;
    }
    if(height) {
        this.progress.style.height = this.height + &amp;quot;px&amp;quot;;
    } else {
        this.progress.style.height = &amp;quot;20px&amp;quot;;
    }
    if(typeof outClass === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; (/^[a-zA-Z](\w|[-])+$/g.test(outClass))) {
        this.progress.className = outClass;
    } else {
        this.progress.style.border = &amp;quot;1px solid #cccccc&amp;quot;;
        this.progress.style.backgroundImage = &amp;quot;linear-gradient(to bottom, #ccc 0%, #fff 40%, #ccc 100%)&amp;quot;;
        this.progress.style.borderRadius = &amp;quot;10px&amp;quot;;
    }
    this.progress.style.overflow = &amp;quot;hidden&amp;quot;;
    this.progress.style.position = &amp;quot;relative&amp;quot;;
    element.appendChild(this.progress);
    //
    this.progress.appendChild(this.percentage);
    this.percentage.style.width = &amp;quot;100%&amp;quot;;
    this.percentage.style.height = &amp;quot;100%&amp;quot;;
    this.percentage.style.textAlign = &amp;quot;center&amp;quot;;
    this.percentage.style.position = &amp;quot;absolute&amp;quot;;
    this.percentage.innerHTML = &amp;quot;0%&amp;quot;;
    //
    this.progress.appendChild(this.filler);
    this.filler.style.height = &amp;quot;100%&amp;quot;;
    this.filler.style.width = 0;
    if(typeof inClass === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; (/^[a-zA-Z](\w|[-])+$/g.test(inClass))) {
        this.filler.className = inClass;
    } else {
        this.filler.style.backgroundColor = &amp;quot;#DC7BBE&amp;quot;;
        this.filler.style.backgroundImage = &amp;quot;linear-gradient(to bottom, #0AF 0%, #0ff 40%, #0AF 100%)&amp;quot;;
    }
}
Progress.prototype.fill = function(value) {
    if(value) {
        this.percentage.innerHTML = value + &amp;quot;%&amp;quot;;
        this.percentage.style.color = this.color;
        value = (this.progress.offsetWidth - 2) / 100 * value;
        this.filler.style.width = value + &amp;quot;px&amp;quot;;
    } else {
        this.filler.style.width = 0;
        this.percentage.innerHTML = &amp;quot;0%&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ajax封装&quot;&gt;&lt;a href=&quot;#ajax封装&quot; class=&quot;headerlink&quot; title=&quot;ajax封装&quot;&gt;&lt;/a&gt;ajax封装&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function ajax(a, b) { 
    //type, url, async, dataType, data, fn
    var xhr = null,
        type = &amp;quot;get&amp;quot;,
        url = &amp;quot;#&amp;quot;,
        async = true,
        dataType = &amp;quot;text&amp;quot;,
        data = &amp;quot;&amp;quot;,
        jsonp = &amp;quot;&amp;quot;,
        jsonpCallback = &amp;quot;&amp;quot;,
        methodName = &amp;quot;&amp;quot;,
        c = null;
    if(typeof a === &amp;quot;string&amp;quot;) {
        url = a;
    }
    if(typeof a === &amp;quot;object&amp;quot;) {
        c = a;
    } else if(typeof b == &amp;quot;object&amp;quot;) {
        c = b;
    }
    if(c) {
        if(c.type &amp;amp;&amp;amp; typeof c.type === &amp;quot;string&amp;quot;) {
            type = c.type;
        };
        if(c.url &amp;amp;&amp;amp; typeof c.url === &amp;quot;string&amp;quot;) {
            url = c.url;
        };
        if(c.async &amp;amp;&amp;amp; typeof c.async === &amp;quot;boolean&amp;quot;) {
            async = c.async;
        };
        if(c.dataType &amp;amp;&amp;amp; typeof c.dataType === &amp;quot;string&amp;quot;) {
            dataType = c.dataType;
        };
        if(c.data &amp;amp;&amp;amp; typeof c.data === &amp;quot;object&amp;quot;) {
            var arr = [];
            for(k in c.data) {
                arr.push(k + &amp;quot;=&amp;quot; + c.data[k]);
            }
            data = arr.join(&amp;quot;&amp;amp;&amp;quot;);
        };
        if(c.jsonp &amp;amp;&amp;amp; typeof c.jsonp === &amp;quot;string&amp;quot;) {
            if(!c.dataType) {
                dataType = &amp;quot;jsonp&amp;quot;;
            }
            jsonp = c.jsonp;
            if(data) {
                data += &amp;quot;&amp;amp;&amp;quot;;
            }
        } else {
            jsonp = &amp;quot;callback&amp;quot;;
        }
        if(c.jsonpCallback &amp;amp;&amp;amp; typeof c.jsonpCallback === &amp;quot;string&amp;quot;) {
            methodName = c.jsonpCallback;
        } else {
            methodName = &amp;quot;jquery&amp;quot; + new Date().getTime() + &amp;quot;_&amp;quot; + (Math.random() + &amp;quot;&amp;quot;).substr(2);
        }
    };
    if(dataType == &amp;quot;jsonp&amp;quot;) {
        data += jsonp + &amp;quot;=&amp;quot; + methodName;
        window[methodName] = function(data) {
            c.success(data);
        }
        var script = document.createElement(&amp;quot;script&amp;quot;);
        script.src = url + &amp;quot;?&amp;quot; + data;
        var head = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
        head.appendChild(script);
    } else {
        //ajax部分
        if(window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
        } else {
            xhr = ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;);
        }
        if(type == &amp;quot;get&amp;quot;) {
            if(data) {
                url += encodeURI(&amp;quot;?&amp;quot; + data);
            }
            data = null;
        };
        xhr.open(type, url, async);
        if(type == &amp;quot;post&amp;quot;) {
            xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;);
        };
        xhr.send(data);
        xhr.onreadystatechange = function() {
            if(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
                var obj = {
                    text: xhr.responseText,
                    json: JSON.parse(xhr.responseText),
                };
                var data = obj[dataType];
                if(typeof c.success === &amp;quot;function&amp;quot;) {
                    c.success(data);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;millisec是距离-GMT-时间-1970-年-1-月-1-日午夜的毫秒数-解析通过ajax返回的数据中的毫秒数值的日期&quot;&gt;&lt;a href=&quot;#millisec是距离-GMT-时间-1970-年-1-月-1-日午夜的毫秒数-解析通过ajax返回的数据中的毫秒数值的日期&quot; class=&quot;headerlink&quot; title=&quot;millisec是距离 GMT 时间 1970 年 1 月 1 日午夜的毫秒数 (解析通过ajax返回的数据中的毫秒数值的日期)&quot;&gt;&lt;/a&gt;millisec是距离 GMT 时间 1970 年 1 月 1 日午夜的毫秒数 (解析通过ajax返回的数据中的毫秒数值的日期)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function getFullDate(millisec, lang) {
    var data = new Date();
    data.setTime(millisec);
    var year = data.getFullYear(),
        month = data.getMonth(),
        day = data.getDate(),
        week = data.getDay(),
        hour = data.getHours(),
        minute = data.getMinutes(),
        second = data.getSeconds(),
        am = &amp;quot;am&amp;quot;,
        pm = &amp;quot;pm&amp;quot;,
        enWeek = [&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;],
        cnWeek = [&amp;quot;星期天&amp;quot;, &amp;quot;星期一&amp;quot;, &amp;quot;星期二&amp;quot;, &amp;quot;星期三&amp;quot;, &amp;quot;星期四&amp;quot;, &amp;quot;星期五&amp;quot;, &amp;quot;星期六&amp;quot;],
        enMonth = [&amp;quot;January&amp;quot;, &amp;quot;February&amp;quot;, &amp;quot;March&amp;quot;, &amp;quot;April&amp;quot;, &amp;quot;May&amp;quot;, &amp;quot;June&amp;quot;, &amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;, &amp;quot;October&amp;quot;, &amp;quot;November&amp;quot;, &amp;quot;December&amp;quot;],
        cnMonth = [&amp;quot;一月&amp;quot;, &amp;quot;二月&amp;quot;, &amp;quot;三月&amp;quot;, &amp;quot;四月&amp;quot;, &amp;quot;五月&amp;quot;, &amp;quot;六月&amp;quot;, &amp;quot;七月&amp;quot;, &amp;quot;八月&amp;quot;, &amp;quot;九月&amp;quot;, &amp;quot;十月&amp;quot;, &amp;quot;十一月&amp;quot;, &amp;quot;十二月&amp;quot;],
        cnDay = [&amp;quot;廿&amp;quot;, &amp;quot;一&amp;quot;, &amp;quot;二&amp;quot;, &amp;quot;三&amp;quot;, &amp;quot;四&amp;quot;, &amp;quot;五&amp;quot;, &amp;quot;六&amp;quot;, &amp;quot;七&amp;quot;, &amp;quot;八&amp;quot;, &amp;quot;九&amp;quot;, &amp;quot;十&amp;quot;]    if(lang == &amp;quot;cn&amp;quot;) {
        am = &amp;quot;上午&amp;quot;;
        pm = &amp;quot;下午&amp;quot;;
    };
    day = day &amp;lt; 10 ? &amp;quot;0&amp;quot; + day : day;
    var obj = {
        year: year,
        month: lang ? (lang == &amp;quot;cn&amp;quot; ? cnMonth[month] : enMonth[month]) : (month &amp;lt; 10 ? &amp;quot;0&amp;quot; + (month + 1) : (month + 1)),
        day: day,
        week: lang == &amp;quot;en&amp;quot; ? enWeek[week] : cnWeek[week],
        hour: hour &amp;lt; 10 ? &amp;quot;0&amp;quot; + hour : hour,
        minute: minute &amp;lt; 10 ? &amp;quot;0&amp;quot; + minute : minute,
        second: second &amp;lt; 10 ? &amp;quot;0&amp;quot; + second : second,
        ms: data.getMilliseconds(),
        am: am,
        pm: pm,
        Hour: hour + minute / 60 &amp;gt; 12 ? (hour == 12 ? pm + hour : pm + hour % 12) : am + hour,
    };
    return obj;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;右键菜单&quot;&gt;&lt;a href=&quot;#右键菜单&quot; class=&quot;headerlink&quot; title=&quot;右键菜单&quot;&gt;&lt;/a&gt;右键菜单&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function RightMenu(area) {
    this.area = area;
    this.menu = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;根据传入的值获取目标&quot;&gt;&lt;a href=&quot;#根据传入的值获取目标&quot; class=&quot;headerlink&quot; title=&quot;根据传入的值获取目标&quot;&gt;&lt;/a&gt;根据传入的值获取目标&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;RightMenu.prototype.target = function(area) {
    if(typeof area === &amp;quot;string&amp;quot;) {
        return document.getElementById(area);
    } else if(typeof area === &amp;quot;object&amp;quot;) {
        return area;
    }
}

RightMenu.prototype.init = function(data,defaultStyle, userStyle, hoverStyle) {
    this.createMenu(data, defaultStyle, userStyle, hoverStyle);
    this.showMenu();
}

RightMenu.prototype.createMenu = function(data, defaultStyle, userStyle, hoverStyle) {
    if(typeof defaultStyle == &amp;quot;string&amp;quot; &amp;amp;&amp;amp; !defaultStyle) {
        hoverStyle = userStyle;
        userStyle = defaultStyle;
        defaultStyle = true;
    }
    //创建菜单及样式
    this.menu = document.createElement(&amp;quot;ul&amp;quot;);
    this.menu.style.position = &amp;quot;absolute&amp;quot;;
    this.menu.style.margin = 0;
    this.menu.style.padding = &amp;quot;2px&amp;quot;;
    this.menu.style.listStyle = &amp;quot;none&amp;quot;;
    this.menu.style.display = &amp;quot;none&amp;quot;;
    if(!defaultStyle) {
        this.menu.style.border = &amp;quot;1px solid #DDDDDD&amp;quot;;
        this.menu.style.backgroundColor = &amp;quot;#CCCCCC&amp;quot;;
        this.menu.style.boxShadow = &amp;quot;5px 5px 5px #ccc&amp;quot;;
    } else {
        this.menu.className = userStyle;
    }
    //选中项样式
    var hover = document.createElement(&amp;quot;span&amp;quot;);
    hover.style.display = &amp;quot;block&amp;quot;;
    hover.style.position = &amp;quot;absolute&amp;quot;
    hover.style.top = 0;
    hover.style.left = 0;
    hover.style.boxSizing = &amp;quot;border-box&amp;quot;;
    hover.style.width = &amp;quot;100%&amp;quot;;
    hover.style.height = &amp;quot;100%&amp;quot;;
    if((!defaultStyle) || (defaultStyle &amp;amp;&amp;amp; !hoverStyle)) {
        hover.style.border = &amp;quot;1px solid #aaa&amp;quot;;
        hover.style.borderRadius = &amp;quot;5px&amp;quot;;
        hover.style.backgroundImage = &amp;quot;linear-gradient(to bottom,rgba(255,255,255,0.5)0%,rgba(255,255,255,0.1)50%,rgba(255,255,255,0.1)100%)&amp;quot;;

    } else {
        hover.className = hoverStyle;
    }
    //创建菜单项
    for(var item in data) {
        var li = document.createElement(&amp;quot;li&amp;quot;);
        li.style.position = &amp;quot;relative&amp;quot;;
        li.style.padding = &amp;quot;5px 10px&amp;quot;;
        li.style.cursor = &amp;quot;pointer&amp;quot;;
        //绑定事件
        li.addEventListener(&amp;quot;mouseenter&amp;quot;, function() {
            this.appendChild(hover);
        });
        li.addEventListener(&amp;quot;mouseleave&amp;quot;, function() {
            this.removeChild(hover);
        });
        var itemData = data[item]        for(var obj in itemData) {
            if(typeof itemData[obj] === &amp;quot;string&amp;quot;) {
                li.innerHTML = itemData[obj];
            } else if(typeof itemData[obj] === &amp;quot;object&amp;quot;) {
                var handlerData = itemData[obj];
                for(var type in handlerData) {
                    li.addEventListener(type, handlerData[type]);
                }
            }
        }
        this.menu.appendChild(li);
    }
    this.target(this.area).appendChild(this.menu);
}

RightMenu.prototype.showMenu = function() {
    var that = this;
    this.menu.parentNode.oncontextmenu = function(ev) {
        that.menu.style.display = &amp;quot;block&amp;quot;;
        that.menu.style.left = ev.pageX + &amp;quot;px&amp;quot;;
        that.menu.style.top = ev.pageY + &amp;quot;px&amp;quot;;
        if(that.menu.parentNode.offsetWidth &amp;lt; that.menu.offsetLeft + that.menu.offsetWidth) {
            that.menu.style.left = ev.pageX - that.menu.offsetWidth + &amp;quot;px&amp;quot;;
        };
        if(that.menu.parentNode.offsetHeight &amp;lt; that.menu.offsetTop + that.menu.offsetHeight) {
            that.menu.style.top = ev.pageY - that.menu.offsetHeight + &amp;quot;px&amp;quot;;
        };
        return false;
    }
    this.menu.parentNode.onclick = function() {
        that.menu.style.display = &amp;quot;none&amp;quot;;
    }
    document.onkeydown = function(e) {
        if(e.keyCode == 18 || e.keyCode == 27) {
            that.menu.style.display = &amp;quot;none&amp;quot;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;拖拽&quot;&gt;&lt;a href=&quot;#拖拽&quot; class=&quot;headerlink&quot; title=&quot;拖拽&quot;&gt;&lt;/a&gt;拖拽&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function Drag(target, area) {
    this.target = target;
    this.area = area;
}

//根据传入的值获取目标
Drag.prototype.dragTarget = function(target) {
    if(typeof target === &amp;quot;string&amp;quot;) {
        return document.getElementById(target);
    } else if(typeof target === &amp;quot;object&amp;quot;) {
        return target;
    }
}

Drag.prototype.init = function() {
    this.target = this.dragTarget(this.target);
    this.target.style.position = &amp;quot;absolute&amp;quot;;
    this.target.setAttribute(&amp;quot;draggable&amp;quot;,&amp;quot;true&amp;quot;);
    this.dragEvent();
}

Drag.prototype.dragEvent = function() {
    var that = this;
    this.target.onmousedown = function(e) {
        e = e || window.event;
        that.disX = e.clientX - that.target.offsetLeft;
        that.disY = e.clientY - that.target.offsetTop;
        document.onmousemove = function(e) {
            that.moveEvent(e);
        }
        document.onmouseup = function(){
            that.target.style.opacity = &amp;quot;1&amp;quot;;
            document.onmousemove = document.onmouseup = null;
        }
        return false;
    }
}
Drag.prototype.moveEvent = function(e) {
    var limitX = e.clientX - this.disX;
    var limitY = e.clientY - this.disY;
    //没有指定区域则用document

    if (!this.area) {
        this.area = document.documentElement;
    }
    if(limitX &amp;lt; this.area.offsetLeft) {
        limitX = this.area.offsetLeft;
    } else if(limitX &amp;gt; this.area.clientWidth + this.area.offsetLeft - this.target.offsetWidth) {
        limitX =  this.area.clientWidth + this.area.offsetLeft - this.target.offsetWidth;
    }
    if(limitY &amp;lt; this.area.offsetTop) {
        limitY = this.area.offsetTop;
    } else if(limitY &amp;gt; this.area.clientHeight + this.area.offsetTop - this.target.offsetHeight) {
        limitY = this.area.clientHeight + this.area.offsetTop - this.target.offsetHeight;
    }
    this.target.style.left = limitX + &amp;quot;px&amp;quot;;
    this.target.style.top = limitY + &amp;quot;px&amp;quot;;
    this.target.style.opacity = &amp;quot;0.8&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h2&gt;&lt;p&gt;1.用匿名函数将脚本包起来；&lt;/p&gt;
&lt;p&gt;2.使用多级命名空间。&lt;/p&gt;
&lt;p&gt;这第二条“使用多级命名空间”这个，我觉得并不是很完美的好主意。因为如果级数太多的话会造成变量名字变得长的一逼。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.newbug.xyz/categories/js/"/>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>seo优优化</title>
    <link href="http://blog.newbug.xyz/2016/01/24/seo%E4%BC%98%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.newbug.xyz/2016/01/24/seo优优化/</id>
    <published>2016-01-24T13:56:49.000Z</published>
    <updated>2016-07-24T14:03:52.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SEO要点：&lt;br&gt;1.语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。&lt;/p&gt;
&lt;p&gt;2.重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面&lt;/p&gt;
&lt;p&gt;3.重要内容要写在html架构里面，蜘蛛不会抓取js的内容，&lt;/p&gt;
&lt;p&gt;4.尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。&lt;/p&gt;
&lt;p&gt;5.为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。&lt;/p&gt;
&lt;p&gt;6.需要强调的地方加上title，本页面内跳转a标签内也要加title。&lt;/p&gt;
&lt;p&gt;7.重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息&lt;/p&gt;
&lt;p&gt;8.尽量做到js、css、html的分离，不要在html中写样式代码。&lt;/p&gt;
&lt;p&gt;9.注释的东西能去掉应该去掉，对搜索引擎更加友好&lt;/p&gt;
&lt;p&gt;10.css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩&lt;/p&gt;
&lt;p&gt;11.减少http的请求，使页面更快加载。&lt;/p&gt;
&lt;p&gt;12.使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。&lt;/p&gt;
&lt;p&gt;13.使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大&lt;/p&gt;
&lt;p&gt;关键一点是头部的title，description，keyword的设置。&lt;/p&gt;
&lt;p&gt;1.title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复&lt;/p&gt;
&lt;p&gt;2.keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复&lt;/p&gt;
&lt;p&gt;3.description，50个字内描述你的网站&lt;/p&gt;
&lt;p&gt;description写原创的话，并包含2-3个关键词比较好&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。&lt;br&gt;
    
    </summary>
    
      <category term="前端总结" scheme="http://blog.newbug.xyz/categories/%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>MarkDown语法小记</title>
    <link href="http://blog.newbug.xyz/2015/07/14/MarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/"/>
    <id>http://blog.newbug.xyz/2015/07/14/MarkDown语法小记/</id>
    <published>2015-07-14T11:53:22.000Z</published>
    <updated>2016-07-14T12:14:12.000Z</updated>
    
    <content type="html">&lt;p&gt;刚开始不介绍下作者，内心都说不过去啊，那我就百度科普下。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Markdown？&quot;&gt;&lt;a href=&quot;#什么是-Markdown？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown？&quot;&gt;&lt;/a&gt;什么是 Markdown？&lt;/h2&gt;&lt;p&gt;Markdown 最初是由 John Gruber 和 Aaron Swartz 于 2004 年共同设计的（在这里插一句，Aaron Swartz 是一个富有传奇性的人物，绝对值得大家了解一下。他曾经利用麻省理工学院网络，伪造身份，侵入收费不菲的 JSTOR 论文数据库，总共下载480万篇论文，以供公众免费下载，他也因此被联邦政府起诉逮捕。他于 2013 年自杀，年仅 27 岁）。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;它是一种用来标记文字的语法，这种语法十分简单，十分钟左右的时间就可以完全掌握。只要使用少量的几个特殊字符（常用的有「#」和「*」）就可以完成一些加粗、斜体、引用等排版工作，因其易学性和便捷性而受到越来越多人的欢迎。使用 Markdown 进行排版可以大大地节省你在排版中所花费的时间，让你更加专注于写作。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&quot;Markdown-基本语法&quot;&gt;&lt;a href=&quot;#Markdown-基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 基本语法&quot;&gt;&lt;/a&gt;Markdown 基本语法&lt;/h1&gt;&lt;h2 id=&quot;1-设置标题&quot;&gt;&lt;a href=&quot;#1-设置标题&quot; class=&quot;headerlink&quot; title=&quot;1. 设置标题&quot;&gt;&lt;/a&gt;1. 设置标题&lt;/h2&gt;&lt;p&gt;Markdown 最多支持六个级别的标题设置，设置标题也十分简单，只要在在每一行的开始使用井号「#」就可以创建标题，「#」的数量决定了标题的级别。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 我是小美

## 我是小小美

### 我是小小小美
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-斜体&quot;&gt;&lt;a href=&quot;#2-斜体&quot; class=&quot;headerlink&quot; title=&quot;2. 斜体&quot;&gt;&lt;/a&gt;2. 斜体&lt;/h2&gt;&lt;p&gt;在想要变斜体的文本两旁各加一个星号「*」就可以将该文本变为斜体了。例如：&lt;/p&gt;
&lt;p&gt;你们知道没有喝脉动的小美长什么样子么？&lt;/p&gt;
&lt;p&gt;长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*小美*
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;3-加粗&quot;&gt;&lt;a href=&quot;#3-加粗&quot; class=&quot;headerlink&quot; title=&quot;3.加粗&quot;&gt;&lt;/a&gt;3.加粗&lt;/h2&gt;&lt;p&gt;在想要加粗的文本两旁各加两个星号「**」就可以将该文本加粗了。例如：&lt;/p&gt;
&lt;p&gt;你们知道成天吃肉的小美长什么样子么？&lt;/p&gt;
&lt;p&gt;长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**小美**
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你又想加粗这个文本又想把这个文本变斜体的话，在该文本的两旁各加三个星号「&lt;em&gt;*&lt;/em&gt;」就可以了。比如说：&lt;/p&gt;
&lt;p&gt;你们知道没有喝脉动又成天吃肉的小美长什么样子么？&lt;/p&gt;
&lt;p&gt;长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***小美***
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;4-引用&quot;&gt;&lt;a href=&quot;#4-引用&quot; class=&quot;headerlink&quot; title=&quot;4.引用&quot;&gt;&lt;/a&gt;4.引用&lt;/h2&gt;&lt;p&gt;如果想要显示出别人说的话或者是引用其他人的观点的话，只需要在这段话的开头加一个大于号「&amp;gt;」即可。例如：&lt;/p&gt;
&lt;p&gt;有一天，小最对正在疯狂减肥的小美说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 你快别减肥了，肉没减下来多少，胸倒是快减没了。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果说想要在引用内再次引用的话，只需要敲下回车然后加两个大于号「&amp;gt;&amp;gt;」就好了，如果想要在引用内的引用继续引用的话（喘口气先）那就加三个大于号「&amp;gt;&amp;gt;&amp;gt;」。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;有一天小美睡不着，她就缠着小最给她讲故事，于是小最就给她讲了一个故事：

&amp;gt; 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事：

&amp;gt;&amp;gt; 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事：

&amp;gt;&amp;gt;&amp;gt; ……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;有一天小美睡不着，她就缠着小最给她讲故事，于是小最就给她讲了一个故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5-列表&quot;&gt;&lt;a href=&quot;#5-列表&quot; class=&quot;headerlink&quot; title=&quot;5.列表&quot;&gt;&lt;/a&gt;5.列表&lt;/h2&gt;&lt;p&gt;Markdown 支持无序列表和有序列表两种列表。无序列表只需要在列表项加一个减号「-」就可以了。此外，加一个星号「*」或者是一个加号「+」也会有同样的效果。建立有序列表也很简单，一个数字加一个英文句号「.」就可以搞定。如果你想在一个列表项中下设一个子列表的话，我建议大家在子列表前加两个空格，更有区分度。下面就给大家举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**本周小最要干的事情**

- 继续赚好多钱给小美花！

- 和小美一起去看 Zootopia！

- 超市大采购！

1. 搓衣板

2. 一箱，不，两箱袋装泡面

3. 遥控器

4. 护膝/哭/

- 给小美洗外套洗衬衫洗睡衣洗裙子洗毛衣洗内裤洗袜子……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周小最要干的事情&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;继续赚好多钱给小美花！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;和小美一起去看 Zootopia！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;超市大采购！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;搓衣板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一箱，不，两箱袋装泡面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遥控器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;护膝/哭/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;给小美洗外套洗衬衫洗睡衣洗裙子洗毛衣洗内裤洗袜子……&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始不介绍下作者，内心都说不过去啊，那我就百度科普下。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Markdown？&quot;&gt;&lt;a href=&quot;#什么是-Markdown？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown？&quot;&gt;&lt;/a&gt;什么是 Markdown？&lt;/h2&gt;&lt;p&gt;Markdown 最初是由 John Gruber 和 Aaron Swartz 于 2004 年共同设计的（在这里插一句，Aaron Swartz 是一个富有传奇性的人物，绝对值得大家了解一下。他曾经利用麻省理工学院网络，伪造身份，侵入收费不菲的 JSTOR 论文数据库，总共下载480万篇论文，以供公众免费下载，他也因此被联邦政府起诉逮捕。他于 2013 年自杀，年仅 27 岁）。
    
    </summary>
    
    
      <category term="MarkDown" scheme="http://blog.newbug.xyz/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客填坑记</title>
    <link href="http://blog.newbug.xyz/2015/03/06/Hexo%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91%E8%AE%B0/"/>
    <id>http://blog.newbug.xyz/2015/03/06/Hexo博客填坑记/</id>
    <published>2015-03-06T13:59:34.000Z</published>
    <updated>2016-07-14T12:14:00.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;　　博客搭建的流程这里就不多说了，都是各种填坑吧，网上的教程数不胜数，但是都是千篇一律，这里主要写下我自己的填坑过程吧。&lt;br&gt;ps：本人不是文科生，也不是什么作家，写作水平有限，就是简单的当个日记，记录下曾经填过的坑！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hexo在hexo上面的托管&quot;&gt;&lt;a href=&quot;#hexo在hexo上面的托管&quot; class=&quot;headerlink&quot; title=&quot;hexo在hexo上面的托管&quot;&gt;&lt;/a&gt;hexo在hexo上面的托管&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;　　刚开始在本地搭建博客之后，是直接托管到hexo上面的，但是由于博客多了在github上面的文件越来越多，不便于管理，所以要在创建一个分支，专门用来托管hexo的配置文件，这样就算是换了电脑，也可以进行clone操作，直接操作我们的博客了。  &lt;/p&gt;
&lt;p&gt;　　Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。&lt;br&gt;其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。　　　　　&lt;br&gt;但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦。&lt;br&gt;所以，我利用了分支！！！&lt;br&gt;简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。&lt;br&gt;下面以我的博客作为例子详细地讲述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我的博客搭建流程&quot;&gt;&lt;a href=&quot;#我的博客搭建流程&quot; class=&quot;headerlink&quot; title=&quot;我的博客搭建流程&quot;&gt;&lt;/a&gt;我的博客搭建流程&lt;/h2&gt;&lt;h4 id=&quot;本地搭建流程&quot;&gt;&lt;a href=&quot;#本地搭建流程&quot; class=&quot;headerlink&quot; title=&quot;本地搭建流程&quot;&gt;&lt;/a&gt;本地搭建流程&lt;/h4&gt;&lt;p&gt;首先确定你的电脑上安装了Node.js和git，然后用npm进行安装hexo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g hexo-cli
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面就是建站了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo init
$ npm install
$ hexo generate
$ hexo server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在打开本地的localhost:4000就可以看到hexo的界面了。&lt;/p&gt;
&lt;h4 id=&quot;github网站流程&quot;&gt;&lt;a href=&quot;#github网站流程&quot; class=&quot;headerlink&quot; title=&quot;github网站流程&quot;&gt;&lt;/a&gt;github网站流程&lt;/h4&gt;&lt;p&gt;1,创建仓库，wu529778790.github.io；&lt;br&gt;2,创建两个分支：master 与 hexo；&lt;br&gt;3,设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；&lt;br&gt;4,使用git clone git@github.com:wu529778790/wu529778790.github.io.git拷贝仓库；&lt;br&gt;5,在本地wu529778790.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;&lt;br&gt;6,修改_config.yml中的deploy参数，分支应为master；&lt;br&gt;7,依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；&lt;br&gt;8,执行hexo generate -d生成网站并部署到GitHub上。&lt;br&gt;9,这样一来，在GitHub上的wu529778790.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！&lt;/p&gt;
&lt;h3 id=&quot;填坑记录&quot;&gt;&lt;a href=&quot;#填坑记录&quot; class=&quot;headerlink&quot; title=&quot;填坑记录&quot;&gt;&lt;/a&gt;填坑记录&lt;/h3&gt;&lt;p&gt;首先是没有安装git部署的插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后执行下面的指令即可完成部署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo generate
$ hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后要说的是git提交的时候遇见的问题了，不得不总结一下，这次的坑太大，当天应是没解决。提交hexo分支到github上的时候一直报错，百度了各种解决办法还是不行，按照下面的办法终于实现了把配置上传到hexo分支，而自己的文章页面在master分支。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin git@github.com:wu529778790/wu529778790.github.io.git
git add *
git push origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，此次博客就更新到这吧，感觉也没人可以看懂吧，就是我自己的笔记，啥时候忘了自己来看看，O(∩_∩)O哈哈~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;　　博客搭建的流程这里就不多说了，都是各种填坑吧，网上的教程数不胜数，但是都是千篇一律，这里主要写下我自己的填坑过程吧。&lt;br&gt;ps：本人不是文科生，也不是什么作家，写作水平有限，就是简单的当个日记，记录下曾经填过的坑！&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.newbug.xyz/tags/hexo/"/>
    
  </entry>
  
</feed>
