<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神族九帝</title>
  <subtitle>永不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.newbug.xyz/"/>
  <updated>2017-06-20T08:42:10.793Z</updated>
  <id>http://blog.newbug.xyz/</id>
  
  <author>
    <name>wu529778790</name>
    <email>529778790@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>typeof(undefined) == undefined 成立吗？</title>
    <link href="http://blog.newbug.xyz/2017/06/20/typeof-undefined-undefined-%E6%88%90%E7%AB%8B%E5%90%97%EF%BC%9F/"/>
    <id>http://blog.newbug.xyz/2017/06/20/typeof-undefined-undefined-成立吗？/</id>
    <published>2017-06-20T08:36:14.000Z</published>
    <updated>2017-06-20T08:42:10.793Z</updated>
    
    <content type="html">&lt;p&gt;工作中一直没用到的面试常常拍死，好吧，还是自己菜，不是面试官吹毛求疵。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1、问题：在JavaScript中，typeof(undefined) == undefined成立吗？&lt;br&gt;答案：不成立，全局函数 typeof()返回值类型为字符串类型，六个可能值： “number”， “string”， “boolean”， “object” ，”function”， 和 “undefined”。&lt;/p&gt;
&lt;p&gt;只有&lt;/p&gt;
&lt;p&gt;typeof(undefined) ==”undefined”;&lt;/p&gt;
&lt;p&gt;才是成立的。&lt;br&gt;2、typeof(null) == ‘undefined’成立吗？&lt;/p&gt;
&lt;p&gt;答案：不成立，null是Object类型的数据，故typeof(null) == ‘object’成立。&lt;br&gt;3、typeof([1,2]) == ‘array’成立吗？&lt;/p&gt;
&lt;p&gt;答案：不成立，typeof()返回值没有”array” 类型，同样也没有“date”类型。”object”&lt;br&gt;4、undefined == undefined成立吗？&lt;/p&gt;
&lt;p&gt;答案：成立。&lt;br&gt;5、null == null成立吗？&lt;/p&gt;
&lt;p&gt;答案：成立。&lt;br&gt;6、NaN == NaN成立吗？&lt;/p&gt;
&lt;p&gt;答案：不成立。NaN 不与任何值相等，包括其本身。要检测值是否为 NaN，请使用 isNaN 函数。&lt;br&gt;7、typeof(NaN) == ‘number’成立吗？&lt;/p&gt;
&lt;p&gt;答案：成立。NaN是属于Number类型的数据。&lt;br&gt;终上所述，null是Object类型的数据，NaN是Number类型的数据，undefined则是undefined类型的数据，即没有定义，找不到该对象或对象的属性和方法。  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;工作中一直没用到的面试常常拍死，好吧，还是自己菜，不是面试官吹毛求疵。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>移动端rem布局(阿里)</title>
    <link href="http://blog.newbug.xyz/2017/05/07/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80-%E9%98%BF%E9%87%8C/"/>
    <id>http://blog.newbug.xyz/2017/05/07/移动端rem布局-阿里/</id>
    <published>2017-05-07T09:42:14.000Z</published>
    <updated>2017-05-07T14:31:36.399Z</updated>
    
    <content type="html">&lt;p&gt;一直在用阿里的flexible布局，但是从来没总结过，今天看到一篇总结的不错就搬过来记录下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用起来很简单，把下面的js直接引入就好了&lt;br&gt;&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/amfe/lib-flexible&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;代码原理&quot;&gt;&lt;a href=&quot;#代码原理&quot; class=&quot;headerlink&quot; title=&quot;代码原理&quot;&gt;&lt;/a&gt;代码原理&lt;/h2&gt;&lt;p&gt;这是阿里团队的高清方案布局，所谓高清方案就是根据设备屏幕的DPR（设备像素比，又称DPPX，比如dpr=2时，表示一个css像素由四个物理像素点组成。）&lt;br&gt;动态设置html的font-size，同时根据设备的DPR调整页面的缩放值，进而达到效果。 &lt;/p&gt;
&lt;h2 id=&quot;有何优势&quot;&gt;&lt;a href=&quot;#有何优势&quot; class=&quot;headerlink&quot; title=&quot;有何优势&quot;&gt;&lt;/a&gt;有何优势&lt;/h2&gt;&lt;p&gt;引用简单，布局简单&lt;br&gt;根据设备屏幕的DPR，自动设置最合适的高清缩放。&lt;br&gt;保证了不同设备下的视觉体验的一致性。&lt;br&gt;有效解决移动端真实1px问题（这里的1px时设备屏幕下的物理像素）  &lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h2&gt;&lt;p&gt;重要的事情说三遍！&lt;br&gt;绝不是每个地方都要用rem，rem只适用于固定尺寸！&lt;br&gt;绝不是每个地方都要用rem，rem只适用于固定尺寸！&lt;br&gt;绝不是每个地方都要用rem，rem只适用于固定尺寸！  &lt;/p&gt;
&lt;p&gt;在相当数量的布局情境中（比如底部导航元素平分屏幕宽，大尺寸元素），你必须使用百分比或者flex才能完美布局！  &lt;/p&gt;
&lt;p&gt;此方案也是默认 1rem = 100px，所以你布局的时候，完全可以按照设计师给你的效果图写各种尺寸啦。&lt;br&gt;比如你在效果图上量取的某个按钮元素长 55px, 宽37px ，那你直接可以这样写样式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.myBtn {
   width: 0.55rem;
   height: 0.37rem;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;常见问题说明&quot;&gt;&lt;a href=&quot;#常见问题说明&quot; class=&quot;headerlink&quot; title=&quot;常见问题说明&quot;&gt;&lt;/a&gt;常见问题说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为啥手机网页效果图宽度是要640或者750的，我非得弄个666的不行咩？&lt;br&gt;答：老实说当然可以，不过为了规范，640或者750是相对合适的。&lt;br&gt;拿Iphone 5s 举例，它的css像素宽度是320px，由于它的dpr=2，所以它的物理像素宽度为320 × 2 = 640px，这也就是为什么，你在5s上截了一张图，在电脑上打开，它的原始宽度是640px的原因。&lt;br&gt;那 iphone 6 的截图宽度呢？ 375 × 2 = 750&lt;br&gt;那 iphone 6 sp 的截图宽度呢？ 414 × 3 = 1242&lt;br&gt;以此类推，你现在能明白效果图为什么一般是 640 ，750 甚至是 1242 的原因了么？（真没有歧视安卓机的意思。。。）  &lt;/li&gt;
&lt;li&gt;宽度用rem写的情况下， 在 iphone6 上没问题， 在 iphone5上会有横向滚动条，何解？&lt;br&gt;答：假设你的效果图宽度是750，在这个效果图上可能有一个宽度为7rem（高清方案默认 1rem = 100px）的元素。我们知道，高清方案的特点就是几乎完美还原效果图，也就是说，你写了一个宽度为 7rem 的元素，那么在目前主流移动设备上都是7rem。然而，iphone 5 的宽度为640，也就是6.4rem。于是横向滚动条不可避免的出现了。&lt;br&gt;怎么办呢？ 这是我目前推荐的比较安全的方式：如果元素的宽度超过效果图宽度的一半（效果图宽为640或750），果断使用百分比宽度，或者flex布局。就像把等屏宽的图片宽度设为100%一样。  &lt;/li&gt;
&lt;li&gt;不是 1rem = 100px吗，为什么我的代码写了一个宽度为3rem的元素，在电脑端的谷歌浏览器上宽度只有150px?&lt;br&gt;答：先说高清方案代码，再次强调咱们的高清方案代码是根据设备的dpr动态设置html 的 font-size，&lt;br&gt;如果dpr=1(如电脑端），则html的font-size为50px，此时 1rem = 50px&lt;br&gt;如果dpr=2(如iphone 5 和 6），则html的font-size为100px，此时 1rem = 100px&lt;br&gt;如果dpr=3(如iphone 6 sp），则html的font-size为150px，此时 1rem = 150px&lt;br&gt;如果dpr为其他值，即便不是整数，如3.4 , 也是一样直接将dpr 乘以 50 。&lt;br&gt;再来说说效果图，一般来讲，我们的效果图宽度要么是640，要么是750，无论哪一个，它们对应设备的dpr=2，此时，1 rem = 50 × 2 = 100px。这也就是为什么高清方案默认1rem = 100px。而将1rem默认100px也是好处多多，可以帮你快速换算单位，比如在750宽度下的效果图，某元素宽度为53px，那么css宽度直接设为53/100=0.53rem了。&lt;br&gt;然而极少情况下，有设计师将效果图宽定为1242px，因为他手里只有一个iphone 6 sp (dpr = 3)，设计完效果图刚好可以在他的iphone 6 sp里查看调整。一切完毕之后，他将这个效果图交给你来切图。由于这个效果图对应设备的dpr=3，也就是1rem = 50 × 3 = 150px。所以如果你量取了一个宽度为90px的元素，它的css宽度应该为 90/150=0.6rem。由于咱们的高清方案默认1rem=100px，为了还原效果图，你需要这样换算。当然，一个技巧就是你可以直接修改咱们的高清方案的默认设置。在代码的最后 你会看到 flex(100, 1) ，将其修改成flex(66.66667, 1)就不用那么麻烦的换算了，此时那个90px的直接写成0.9rem就可以了。  &lt;/li&gt;
&lt;li&gt;高清方案在微信上，有时候字体会不受控制变的很大，怎么办？&lt;br&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design-mobile/issues/732&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ant-design/ant-design-mobile/issues/732&lt;/a&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题原因：&lt;br&gt;在X5新内核Blink中，在排版页面的时候，会主动对字体进行放大，会检测页面中的主字体，当某一块字体在&lt;br&gt;我们的判定规则中，认为字号较小，并且是页面中的主要字体，就会采取主动放大的操作。然而这不是我们想要的，可以采取给最大高度解决    &lt;/p&gt;
&lt;p&gt;后续：经过项目实践，还是决定给 max-height 一个具体数值比较好，之前给的是 100% ，但有自身的局限性，比如 antd 的轮播组件在 max-height:100% 的情况下就不能正常显示。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我在底部导航用的flex感觉更合适一些，请问这样子混着用可以吗？&lt;br&gt;咱们的rem适合写固定尺寸。其余的根据需要换成flex或者百分比。源码示例中就有这三种的综合运用。  &lt;/li&gt;
&lt;li&gt;在高清方案下，一个标准的，较为理想的宽度为640的页面效果图应该是怎样的？  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.attach.qdfuns.com/notes/pics/201705/05/165046bsdbcb1frrhfnbpp.png&quot; alt=&quot;参考布局&quot;&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;源码：&lt;br&gt; ‘use strict’;&lt;/p&gt;
&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@param {Number} [baseFontSize = 100] - 基础fontSize, 默认100px;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@param {Number} [fontscale = 1] - 有的业务希望能放大一定比例的字体;&lt;br&gt;*/&lt;br&gt;const win = window;&lt;br&gt;export default win.flex = (baseFontSize, fontscale) =&amp;gt; {&lt;br&gt;const _baseFontSize = baseFontSize || 100;&lt;br&gt;const _fontscale = fontscale || 1;&lt;/p&gt;
&lt;p&gt;const doc = win.document;&lt;br&gt;const ua = navigator.userAgent;&lt;br&gt;const matches = ua.match(/Android[\S\s]+AppleWebkit\/(\d{3})/i);&lt;br&gt;const UCversion = ua.match(/U3\/((\d+|.){5,})/i);&lt;br&gt;const isUCHd = UCversion &amp;amp;&amp;amp; parseInt(UCversion[1].split(‘.’).join(‘’), 10) &amp;gt;= 80;&lt;br&gt;const isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi);&lt;br&gt;let dpr = win.devicePixelRatio || 1;&lt;br&gt;if (!isIos &amp;amp;&amp;amp; !(matches &amp;amp;&amp;amp; matches[1] &amp;gt; 534) &amp;amp;&amp;amp; !isUCHd) {&lt;br&gt; // 如果非iOS, 非Android4.3以上, 非UC内核, 就不执行高清, dpr设为1;&lt;br&gt; dpr = 1;&lt;br&gt;}&lt;br&gt;const scale = 1 / dpr;&lt;/p&gt;
&lt;p&gt;let metaEl = doc.querySelector(‘meta[name=”viewport”]’);&lt;br&gt;if (!metaEl) {&lt;br&gt; metaEl = doc.createElement(‘meta’);&lt;br&gt; metaEl.setAttribute(‘name’, ‘viewport’);&lt;br&gt; doc.head.appendChild(metaEl);&lt;br&gt;}&lt;br&gt;metaEl.setAttribute(‘content’, &lt;code&gt;width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}&lt;/code&gt;);&lt;br&gt;doc.documentElement.style.fontSize = &lt;code&gt;${_baseFontSize / 2 * dpr * _fontscale}px&lt;/code&gt;;&lt;br&gt;};  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;demo：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;

    &amp;lt;!-- 阿里高清方案 --&amp;gt;
    &amp;lt;script&amp;gt;!function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=&amp;quot;&amp;quot;,t(0)}([function(e,t){&amp;quot;use strict&amp;quot;;Object.defineProperty(t,&amp;quot;__esModule&amp;quot;,{value:!0});var i=window;t[&amp;quot;default&amp;quot;]=i.flex=function(e,t){var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d{3})/i),l=o.match(/U3\/((\d+|\.){5,})/i),c=l&amp;amp;&amp;amp;parseInt(l[1].split(&amp;quot;.&amp;quot;).join(&amp;quot;&amp;quot;),10)&amp;gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;amp;&amp;amp;d[1]&amp;gt;534||c||(s=1);var u=1/s,m=r.querySelector(&amp;apos;meta[name=&amp;quot;viewport&amp;quot;]&amp;apos;);m||(m=r.createElement(&amp;quot;meta&amp;quot;),m.setAttribute(&amp;quot;name&amp;quot;,&amp;quot;viewport&amp;quot;),r.head.appendChild(m)),m.setAttribute(&amp;quot;content&amp;quot;,&amp;quot;width=device-width,user-scalable=no,initial-scale=&amp;quot;+u+&amp;quot;,maximum-scale=&amp;quot;+u+&amp;quot;,minimum-scale=&amp;quot;+u),r.documentElement.style.fontSize=a/2*s*n+&amp;quot;px&amp;quot;},e.exports=t[&amp;quot;default&amp;quot;]}]);
    flex(100, 1);&amp;lt;/script&amp;gt;
    &amp;lt;!-- 字形图标 --&amp;gt;
    &amp;lt;script src=&amp;quot;https://use.fontawesome.com/f47f4563cb.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            box-sizing: border-box;
        }

        *:before, *:after {
            box-sizing: border-box;
        }

        *, *:before, *:after {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }

        html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp, small, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td {
            border: 0 none;
            font-size: inherit;
            color: inherit;
            margin: 0;
            padding: 0;
            vertical-align: baseline;

            /* 在X5新内核Blink中，在排版页面的时候，会主动对字体进行放大，会检测页面中的主字体，当某一块字体在我们的判定规则中，认为字号较小，并且是页面中的主要字体，就会采取主动放大的操作。然而这不是我们想要的，可以采取给最大高度解决 */
            max-height: 100000px;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: normal;
        }

        em, strong {
            font-style: normal;
        }

        ul, ol, li {
            list-style: none;
        }

        body {
            font-family: &amp;quot;Helvetica Neue&amp;quot;,Helvetica,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;\5FAE\8F6F\96C5\9ED1&amp;quot;,Arial,sans-serif;
            line-height: 1.5;
            color: #333;
            background-color: #f2f2f2;
            font-size: 0.24rem;
        }

        a {
            text-decoration: none;
        }
        .box {
            position: relative;
            max-width: 10rem;
            margin: 0 auto;
        }

        .navRoot {
            position: fixed;
            z-index: 50;
            bottom: 0;
            left:0;
            width: 100%;
            height: 1rem;
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            border-top: 0.01rem solid #ccc;
            background:#f2f2f2;
        }

        .navLink {
            font-size: 0.42rem;
            -webkit-box-flex: 1;
            -ms-flex: auto;
            flex: auto;
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -webkit-box-orient: vertical;
            -webkit-box-direction: normal;
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -webkit-box-pack: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-box-align: center;
            -ms-flex-align: center;
            align-items: center;
            line-height: 1;
            color: #666;
        }
        .navLink.active {
            color: #1abc9c
        }
        .navLinkIco {
            display: block;
            margin-bottom: 0.1rem;
        }

        .navLinkText {
            display: block;
            line-height: 1;
            font-size: 0.24rem;
        }

        .img-responsive {
            width: 100%;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
   &amp;lt;div class=&amp;quot;box-content&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;http://temp.im/640x260/444/fff&amp;quot; class=&amp;quot;img-responsive&amp;quot;&amp;gt;
    &amp;lt;ul style=&amp;quot;font-size:0.3rem; padding: 0.2rem&amp;quot;&amp;gt;
        &amp;lt;li style=&amp;quot;font-size:0.4rem&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;http://www.jianshu.com/p/985d26b40199&amp;quot;&amp;gt;rem布局（进阶版）的一些说明&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;1，大家先把这个页面在不同设备模式下浏览下，感受下。&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;2，一般来说我们的手机端效果图是640px或750px。&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;3，对于上图这类需要等屏宽的图片，只需让其宽度设为 100% 即可。&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;4，该布局方案要求凡是涉及尺寸的，单位都是rem，比如，height width margin paddint top border-radius 等等。你只需要按照效果图上标注的尺寸布局即可。&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;

   &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;navRoot&amp;quot;&amp;gt;
        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navLink active&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;fa fa-home navLinkIco&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;span class=&amp;quot;navLinkText&amp;quot;&amp;gt;首页&amp;lt;/span&amp;gt;
        &amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navLink&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;fa fa-home navLinkIco&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;span class=&amp;quot;navLinkText&amp;quot;&amp;gt;好店&amp;lt;/span&amp;gt;
        &amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navLink&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;fa fa-home navLinkIco&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;span class=&amp;quot;navLinkText&amp;quot;&amp;gt;简单&amp;lt;/span&amp;gt;
        &amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navLink&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;fa fa-home navLinkIco&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;span class=&amp;quot;navLinkText&amp;quot;&amp;gt;复杂&amp;lt;/span&amp;gt;
        &amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navLink&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;fa fa-home navLinkIco&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;span class=&amp;quot;navLinkText&amp;quot;&amp;gt;异步&amp;lt;/span&amp;gt;
        &amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考： &lt;a href=&quot;http://www.jianshu.com/p/985d26b40199&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/985d26b40199&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html&lt;/a&gt;  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直在用阿里的flexible布局，但是从来没总结过，今天看到一篇总结的不错就搬过来记录下。&lt;br&gt;
    
    </summary>
    
    
      <category term="移动端 rem" scheme="http://blog.newbug.xyz/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF-rem/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的this</title>
    <link href="http://blog.newbug.xyz/2017/04/23/javascript%E4%B8%AD%E7%9A%84this/"/>
    <id>http://blog.newbug.xyz/2017/04/23/javascript中的this/</id>
    <published>2017-04-23T08:09:09.000Z</published>
    <updated>2017-04-25T09:40:43.762Z</updated>
    
    <content type="html">&lt;p&gt;this是函数内部的一个特殊对象，他引用的是函数据以执行的环境对象。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;全局环境下的this&quot;&gt;&lt;a href=&quot;#全局环境下的this&quot; class=&quot;headerlink&quot; title=&quot;全局环境下的this&quot;&gt;&lt;/a&gt;全局环境下的this&lt;/h2&gt;&lt;p&gt;当在网页的全局作用域中调用函数时，this对象引用的就是window&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(this);//window

function f() {
    return this;
}
f();//window  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数f()定义在全局作用域中，引用了this对象，调用函数之前，this的值并不确定，可能会在代码执行过程中饮用不同的对象，在全局环境中调用函数f()时，this引用的就是全局对象window.  &lt;/p&gt;
&lt;h2 id=&quot;对象中的this&quot;&gt;&lt;a href=&quot;#对象中的this&quot; class=&quot;headerlink&quot; title=&quot;对象中的this&quot;&gt;&lt;/a&gt;对象中的this&lt;/h2&gt;&lt;p&gt;将一个函数赋给对象，通过对象调用这个函数，他们的this是调用该函数的对象&lt;br&gt;    var o = {&lt;br&gt;        color: ‘blue’,&lt;br&gt;        sayColor: function () {&lt;br&gt;            return this.color;&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;o.sayColor();//blue  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将函数sayColor赋值给对象o,o.sayColor()被调用时，函数内部的this就被绑定到o，我们也可以用如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var o = {color:&amp;apos;blue&amp;apos;};
function sayColor(){
    return this.color;
}
o.sayColor = sayColor;
o.sayColor();//blue  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数的名字仅仅是一个包含着指针的变量，在何处定义调用函数不会影响到this的行为，全局的sayColor()与o.sayColor()指向的是同一个函数。  &lt;/p&gt;
&lt;h2 id=&quot;函数构造中的this&quot;&gt;&lt;a href=&quot;#函数构造中的this&quot; class=&quot;headerlink&quot; title=&quot;函数构造中的this&quot;&gt;&lt;/a&gt;函数构造中的this&lt;/h2&gt;&lt;p&gt;函数或方法之前带有关键字new，他就构成了构造函数调用。通过构造函数生成一个新的对象，this指向新对象&lt;br&gt;    function person(){&lt;br&gt;        this.name = ‘wuwei’;&lt;br&gt;    }&lt;br&gt;    var o = new person();&lt;br&gt;    console.log(o.name);//wuwei  &lt;/p&gt;
&lt;h2 id=&quot;applly和call&quot;&gt;&lt;a href=&quot;#applly和call&quot; class=&quot;headerlink&quot; title=&quot;applly和call&quot;&gt;&lt;/a&gt;applly和call&lt;/h2&gt;&lt;p&gt;每个函数都包含两个非继承而来的方法，apply()和call().这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先apply()方法接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以使Array实例，也可以是arguments对象。&lt;br&gt;    function sum(num1, num2) {&lt;br&gt;        return num1 + num2;&lt;br&gt;    };&lt;br&gt;    function callSum1(num1,num2){&lt;br&gt;        return sum.apply(this, arguments);&lt;br&gt;    };&lt;br&gt;    function callSum2(num1, num2){&lt;br&gt;        return sum.apply(this, [num1, num2]);&lt;br&gt;    };&lt;br&gt;    console.log(callSum1(10, 10));//20&lt;br&gt;    console.log(callSum2(10, 10));//20&lt;/p&gt;
&lt;p&gt;上边这个例子中，callSum1()在执行sum()函数时传入了this作为this值(再作用域中调用的，传入的就是window对象)和arguments对象.而callSum2()也调用了sum()函数，但传入的是this和一个参数数组。  &lt;/p&gt;
&lt;p&gt;注：在严格模式下，未指定环境对象而调用函数，则this值不会被转型为window，除非明确把函数添加到某个对象或者抵用apply()或call(),否则this值是undefined.  &lt;/p&gt;
&lt;p&gt;call()和apply()方法作用相同，区别仅仅在于接受参数方式不同，对call()而言，第一个参数是this没有变化，不同的是其余参数都是直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须诸葛列举出来。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function sum(num1, num2){
    return num1 + num2;
};
function callSum(num1, num2){
    return sum.call(this, num1, num2);
};
console.log(callSum(10, 10));//20  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;call()和apply()真正强大的地方在于能扩充函数赖以运行的作用域。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.color = &amp;apos;red&amp;apos;;
var o = { color:&amp;apos;blue&amp;apos;};
function sayColor(){
    console.log(this.color);
};
sayColor();//red
sayColor.call(this);//red
sayColor.call(window);//red
sayColor.call(o);//blue  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用call()或者apply()扩充作用域最大的好处，就是对象不需要与方法有人和耦合关系。  &lt;/p&gt;
&lt;h2 id=&quot;bind&quot;&gt;&lt;a href=&quot;#bind&quot; class=&quot;headerlink&quot; title=&quot;bind&quot;&gt;&lt;/a&gt;bind&lt;/h2&gt;&lt;p&gt;es5还定义了bind，这个方法会创建一个函数的实例，其this值会被绑定传给bind()函数的值&lt;br&gt;    window.color = ‘red’;&lt;br&gt;    var o = { color:’blue’ };&lt;br&gt;    function sayColor() {&lt;br&gt;        console.log(this.color);&lt;br&gt;    }&lt;br&gt;    var objectSayColor = sayColor.bind(o);&lt;br&gt;    objectSayColor();//blue&lt;br&gt;在sayColor()调用bind()并传入对象o,创建了objectSayColor()函数，该函数的this等于o，因此即使在全局作用域中调用这个函数，也会看到blue  &lt;/p&gt;
&lt;h2 id=&quot;闭包中的this&quot;&gt;&lt;a href=&quot;#闭包中的this&quot; class=&quot;headerlink&quot; title=&quot;闭包中的this&quot;&gt;&lt;/a&gt;闭包中的this&lt;/h2&gt;&lt;p&gt;闭包中使用this对象可能会导致一些问题，this对象在运行时是基于函数的执行环境对象的：在全局函数中，this等于window，二挡函数被作为某个对象方法调用时，this等于那个对象，匿名函数的执行环境具有全局性，因此其this对象通常指向window&lt;br&gt;    var color = ‘red’;&lt;br&gt;    var o = {&lt;br&gt;        name:’blue’,&lt;br&gt;        sayColor: function(){&lt;br&gt;            return function(){&lt;br&gt;                return this.color;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    console.log(o.sayColor()());//red&lt;br&gt;    //改进&lt;br&gt;    var o = {&lt;br&gt;        color:’blue’,&lt;br&gt;        sayColor: function(){&lt;br&gt;            var that = this;&lt;br&gt;            return function(){&lt;br&gt;                return that.color;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    console.log(o.sayColor()());//blue  &lt;/p&gt;
&lt;h2 id=&quot;es6中箭头函数的this&quot;&gt;&lt;a href=&quot;#es6中箭头函数的this&quot; class=&quot;headerlink&quot; title=&quot;es6中箭头函数的this&quot;&gt;&lt;/a&gt;es6中箭头函数的this&lt;/h2&gt;&lt;p&gt;this引用的是函数据以执行的环境对象。但是在使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数的使用参考：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://es6.ruanyifeng.com/#docs/function&lt;/a&gt;&lt;br&gt;    function foo(){&lt;br&gt;        setTimeout(() =&amp;gt; {&lt;br&gt;            console.log(‘id:’, this.id);&lt;br&gt;        }, 100)&lt;br&gt;    }&lt;br&gt;    var id = 21;&lt;br&gt;    foo.call({ id: 42 });//id: 42  &lt;/p&gt;
&lt;p&gt;箭头函数中的this指向foo的this，箭头函数中也不存在arguments，指向外层函数foo对象的arguments&lt;br&gt;由于箭头函数没有自己的this，所以也不能用call()、apply()、bind()改变this的指向。  &lt;/p&gt;
&lt;h2 id=&quot;绑定this&quot;&gt;&lt;a href=&quot;#绑定this&quot; class=&quot;headerlink&quot; title=&quot;绑定this&quot;&gt;&lt;/a&gt;绑定this&lt;/h2&gt;&lt;p&gt;函数绑定运算符是::,双冒号是左边是一个对象，右边是一个函数，该运算符会自动将左边的对象作为上下文环境(this对象)，绑定到右边的函数上。可参考阮老师的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://es6.ruanyifeng.com/#docs/function&lt;/a&gt;&lt;br&gt;    foo::bar;&lt;br&gt;    //等同于&lt;br&gt;    bar.bind(foo);&lt;/p&gt;
&lt;p&gt;在判断this指向时，要记住，在没有绑定this的情况下，this动态绑定，指向运行时的环境，而非代码中的位置，只有箭头函数才是静态绑定，将this绑定到代码中的位置。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;this是函数内部的一个特殊对象，他引用的是函数据以执行的环境对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>css十八般武艺</title>
    <link href="http://blog.newbug.xyz/2017/04/22/css%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/"/>
    <id>http://blog.newbug.xyz/2017/04/22/css十八般武艺/</id>
    <published>2017-04-22T11:11:28.000Z</published>
    <updated>2017-04-25T08:02:14.732Z</updated>
    
    <content type="html">&lt;p&gt;水平居中，垂直居中，单列布局，多列布局&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用居中方法&quot;&gt;&lt;a href=&quot;#常用居中方法&quot; class=&quot;headerlink&quot; title=&quot;常用居中方法&quot;&gt;&lt;/a&gt;常用居中方法&lt;/h2&gt;&lt;p&gt;居中在布局中很常见，我们假设DOM文档节后如下，子元素要在父元素中居中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; title=&quot;水平居中&quot;&gt;&lt;/a&gt;水平居中&lt;/h3&gt;&lt;p&gt;子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同&lt;/p&gt;
&lt;p&gt;子元素为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行内元素：对父元素设置text-align:center,
&lt;/strong&gt;定宽块状元素：设置左右margin值为auto，&lt;br&gt;&lt;strong&gt;不定宽块状元素：设置子元素为display：inline,然后在父元素上设置text-align:center,
&lt;/strong&gt;通用方案：flex布局，对父元素设置display:flex;justify-content:center;&lt;/p&gt;
&lt;h3 id=&quot;垂直居中：&quot;&gt;&lt;a href=&quot;#垂直居中：&quot; class=&quot;headerlink&quot; title=&quot;垂直居中：&quot;&gt;&lt;/a&gt;垂直居中：&lt;/h3&gt;&lt;p&gt;垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父元素一定，子元素为单行内联文本：&lt;br&gt;设置父元素的height等于行高line-height
&lt;/strong&gt;父元素一定，子元素为多行内联文本：&lt;br&gt;设置父元素的display：table-cell或inline-block，在设置vertical-align：middle；&lt;br&gt;&lt;strong&gt;块状元素：&lt;br&gt;设置子元素篇position:absolute并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;
&lt;/strong&gt;通用方案：&lt;br&gt;flex布局，对父元素设置display：flex；align-items:center；&lt;/p&gt;
&lt;h2 id=&quot;单列布局&quot;&gt;&lt;a href=&quot;#单列布局&quot; class=&quot;headerlink&quot; title=&quot;单列布局&quot;&gt;&lt;/a&gt;单列布局&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12cd0eddc97721987b9f6e41e5a1fc4b_b.png&quot; alt=&quot;单行布局的两种形式&quot;&gt;&lt;/p&gt;
&lt;p&gt;特征： 定宽、水平居中&lt;/p&gt;
&lt;p&gt;常见的单列布局有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 一种是header、content、footer宽度都相同，期一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于最大宽度时，宽度会自适应。
* 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。&lt;/p&gt;
&lt;h3 id=&quot;DOM文档&quot;&gt;&lt;a href=&quot;#DOM文档&quot; class=&quot;headerlink&quot; title=&quot;DOM文档&quot;&gt;&lt;/a&gt;DOM文档&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;layout&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;header&amp;quot;&amp;gt;头部&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;内容&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;尾部&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;css清单&quot;&gt;&lt;a href=&quot;#css清单&quot; class=&quot;headerlink&quot; title=&quot;css清单&quot;&gt;&lt;/a&gt;css清单&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;.layout{
/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/
max-width: 960px;
margin: 0 auto;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于第二种，header，footer的内容宽度为100%，单header，footer的内容区以及content统一设置为width或者max-width，并通过margin：auto实现。&lt;/p&gt;
&lt;h3 id=&quot;DOM文档-1&quot;&gt;&lt;a href=&quot;#DOM文档-1&quot; class=&quot;headerlink&quot; title=&quot;DOM文档&quot;&gt;&lt;/a&gt;DOM文档&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;header&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;layout&amp;quot;&amp;gt;头部&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;content&amp;quot; class=&amp;quot;layout&amp;quot;&amp;gt;内容&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;layout&amp;quot;&amp;gt;尾部&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;css清单-1&quot;&gt;&lt;a href=&quot;#css清单-1&quot; class=&quot;headerlink&quot; title=&quot;css清单&quot;&gt;&lt;/a&gt;css清单&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;.layout{
/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/
max-width: 960px;
margin: 0 auto;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二列-amp-三列布局&quot;&gt;&lt;a href=&quot;#二列-amp-三列布局&quot; class=&quot;headerlink&quot; title=&quot;二列&amp;amp;三列布局&quot;&gt;&lt;/a&gt;二列&amp;amp;三列布局&lt;/h2&gt;&lt;p&gt;1&lt;a href=&quot;https://pic2.zhimg.com/v2-784022577a47ea5fc449b06de53c4651_b.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二列三列布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。&lt;/p&gt;
&lt;p&gt;之所以将二列布局和三列布局写在一起，是因为二列布局可以看做是去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。&lt;/p&gt;
&lt;h3 id=&quot;a-float-margin&quot;&gt;&lt;a href=&quot;#a-float-margin&quot; class=&quot;headerlink&quot; title=&quot;a.float+margin&quot;&gt;&lt;/a&gt;a.float+margin&lt;/h3&gt;&lt;p&gt;**原理说明： 设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。&lt;/p&gt;
&lt;h4 id=&quot;DOM文档-2&quot;&gt;&lt;a href=&quot;#DOM文档-2&quot; class=&quot;headerlink&quot; title=&quot;DOM文档&quot;&gt;&lt;/a&gt;DOM文档&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;sub&amp;quot;&amp;gt;sub&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;extra&amp;quot;&amp;gt;extra&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;main&amp;quot;&amp;gt;main&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;布局步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对两边侧栏分别设置宽度，并对左侧栏添加左浮动，右侧栏添加右浮动。&lt;/li&gt;
&lt;li&gt;对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为有侧栏的宽度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;css清单-2&quot;&gt;&lt;a href=&quot;#css清单-2&quot; class=&quot;headerlink&quot; title=&quot;css清单&quot;&gt;&lt;/a&gt;css清单&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.sub{
    width: 100px;
    float: left;
}
.extra{
    width: 200px;
    float: right;
}
.main{
    margin-left: 100px; 
    margin-right: 200px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;注意dom文档的书写顺序，先写两侧栏，在写主面板，更换后则侧栏会被挤到下一列.&lt;/li&gt;
&lt;li&gt;这种布局方式比较简单明了，单缺点是渲染师先渲染了侧边栏，而不是比较重要的主面板。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;两列的实现方法&quot;&gt;&lt;a href=&quot;#两列的实现方法&quot; class=&quot;headerlink&quot; title=&quot;两列的实现方法&quot;&gt;&lt;/a&gt;两列的实现方法&lt;/h4&gt;&lt;p&gt;如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;b-position-margin&quot;&gt;&lt;a href=&quot;#b-position-margin&quot; class=&quot;headerlink&quot; title=&quot;b.position+margin&quot;&gt;&lt;/a&gt;b.position+margin&lt;/h3&gt;&lt;p&gt;*原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。&lt;/p&gt;
&lt;h4 id=&quot;DOM文档-3&quot;&gt;&lt;a href=&quot;#DOM文档-3&quot; class=&quot;headerlink&quot; title=&quot;DOM文档&quot;&gt;&lt;/a&gt;DOM文档&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;sub&amp;quot;&amp;gt;left&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;main&amp;quot;&amp;gt;main&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;extra&amp;quot;&amp;gt;right&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;布局步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 对两边侧栏分别设置宽度，设置定位方式为绝对定位。
2. 设置两侧栏的top值都为0，设置左侧栏的left值为0，右侧栏的right为0.
3. 对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为有侧栏的宽度。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;css清单-3&quot;&gt;&lt;a href=&quot;#css清单-3&quot; class=&quot;headerlink&quot; title=&quot;css清单&quot;&gt;&lt;/a&gt;css清单&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.sub, .extra {
    position: absolute;
    top: 0; 
    width: 200px;
}
.sub { 
    left: 0;
}
.extra { 
    right: 0; 
}
.main { 
    margin: 0 200px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;二列的实现方法&quot;&gt;&lt;a href=&quot;#二列的实现方法&quot; class=&quot;headerlink&quot; title=&quot;二列的实现方法&quot;&gt;&lt;/a&gt;二列的实现方法&lt;/h4&gt;&lt;p&gt;如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;c-圣杯布局-float-负margin&quot;&gt;&lt;a href=&quot;#c-圣杯布局-float-负margin&quot; class=&quot;headerlink&quot; title=&quot;c.圣杯布局(float + 负margin)&quot;&gt;&lt;/a&gt;c.圣杯布局(float + 负margin)&lt;/h3&gt;&lt;h4 id=&quot;原理说明：&quot;&gt;&lt;a href=&quot;#原理说明：&quot; class=&quot;headerlink&quot; title=&quot;原理说明：&quot;&gt;&lt;/a&gt;原理说明：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对其的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡住面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们想象中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;DOM文档-4&quot;&gt;&lt;a href=&quot;#DOM文档-4&quot; class=&quot;headerlink&quot; title=&quot;DOM文档&quot;&gt;&lt;/a&gt;DOM文档&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;bd&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;main&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;sub&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;extra&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;布局步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三者都设置想左浮动&lt;br&gt;2.设置main宽度为100%，设置两侧栏的宽度&lt;br&gt;3.设置负边距，sub设置负左边距100%，extra设置负左边距为负的自身高度&lt;br&gt;4.设置mian的padding值给左右两个子面板留出空间&lt;br&gt;5.设置两个字面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;css清单-4&quot;&gt;&lt;a href=&quot;#css清单-4&quot; class=&quot;headerlink&quot; title=&quot;css清单&quot;&gt;&lt;/a&gt;css清单&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.main {        
float: left;       
width: 100%;   
}  
.sub {       
float: left;        
width: 190px;        
margin-left: -100%;               
position: relative;  
left: -190px;  
}   
.extra {        
float: left;        
width: 230px;        
margin-left: -230px; 
position: relative; 
right: -230px;  
}
#bd {        
padding: 0 230px 0 190px;   
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;说明-1&quot;&gt;&lt;a href=&quot;#说明-1&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;dom元素的书写顺序不得更改&lt;/li&gt;
&lt;li&gt;主面板部分优先渲染(一般主面板回避侧栏内容重要)&lt;/li&gt;
&lt;li&gt;当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉，可以通过设置main的mian-width属性或者使用双飞翼布局避免问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;二列的实现方法-1&quot;&gt;&lt;a href=&quot;#二列的实现方法-1&quot; class=&quot;headerlink&quot; title=&quot;二列的实现方法&quot;&gt;&lt;/a&gt;二列的实现方法&lt;/h4&gt;&lt;p&gt;如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的padding-right值，其他操作相同。反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;d-flex布局，&quot;&gt;&lt;a href=&quot;#d-flex布局，&quot; class=&quot;headerlink&quot; title=&quot;d flex布局，&quot;&gt;&lt;/a&gt;d flex布局，&lt;/h3&gt;&lt;p&gt;这个主要看阮一峰老师的教程&lt;/p&gt;
&lt;p&gt;语法篇： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实例篇： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结： 统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25565751&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zhuanlan.zhihu.com/p/25565751&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;水平居中，垂直居中，单列布局，多列布局&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://blog.newbug.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="http://blog.newbug.xyz/2017/04/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.newbug.xyz/2017/04/21/浏览器缓存机制/</id>
    <published>2017-04-21T02:39:44.000Z</published>
    <updated>2017-04-21T07:24:51.912Z</updated>
    
    <content type="html">&lt;p&gt;缓存一直是前端优化的主战场，利用好缓存就成功了一半。本篇从http请求和响应的头域入手, 让你对浏览器缓存有个整体的概念. 最终你会发现强缓存, 协商缓存 和 启发式缓存是如此的简单.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为存储策略, 过期策略, 协商策略, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用. 流程图如下所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/6941baebly1feplaog919j20t00enjs7.jpg&quot; alt=&quot;缓存图片&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;http-header-中与缓存有关的key&quot;&gt;&lt;a href=&quot;#http-header-中与缓存有关的key&quot; class=&quot;headerlink&quot; title=&quot;http header 中与缓存有关的key&quot;&gt;&lt;/a&gt;http header 中与缓存有关的key&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;key&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;存储策略&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;过期策略&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;协商策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Cache-Control&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指定缓存机制,覆盖其它设置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Pragma&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;http1.0字段,指定缓存机制&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Expires&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;http1.0字段,指定缓存的过期时间&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Last-Modified&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源最后一次的修改时间&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ETag&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;唯一标识请求资源的字符串&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;缓存协商策略用于重新验证缓存资源是否有效-有关的key如下&quot;&gt;&lt;a href=&quot;#缓存协商策略用于重新验证缓存资源是否有效-有关的key如下&quot; class=&quot;headerlink&quot; title=&quot;缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下&quot;&gt;&lt;/a&gt;缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;key&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;If-Modified-Since&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;同上, 处理方式与之相反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;If-Match&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;If-None-Match&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;同上, 处理方式与之相反&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;各个头域-key-的作用&quot;&gt;&lt;a href=&quot;#各个头域-key-的作用&quot; class=&quot;headerlink&quot; title=&quot;各个头域(key)的作用&quot;&gt;&lt;/a&gt;各个头域(key)的作用&lt;/h3&gt;&lt;h4 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h4&gt;&lt;p&gt;浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.&lt;/p&gt;
&lt;p&gt;不仅如此, 它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置&lt;/p&gt;
&lt;p&gt;语法为: “Cache-Control : cache-directive”.&lt;/p&gt;
&lt;p&gt;Cache-directive共有如下12种(其中请求中指令7种, 响应中指令9种):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Cache-directive&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;存储策略&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;过期策略&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;请求字段&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;响应字段&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;public&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源将被客户端和代理服务器缓存&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;private&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源仅被客户端缓存, 代理服务器不缓存&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;no-store&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;请求和响应都不缓存&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;no-cache&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;相当于max-age:0,must-revalidate即资源被缓存, 但是缓存立刻过期, 同时下次访问时强制验证资源有效性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;max-age&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缓存资源, 但是在指定时间(单位为秒)后缓存过期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;s-maxage&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;同上, 依赖public设置, 覆盖max-age, 且只在代理服务器上有效.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;max-stale&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指定时间内, 即使缓存过时, 资源依然有效&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;min-fresh&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缓存的资源至少要保持指定时间的新鲜期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;must-revalidation / proxy-revalidation&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;如果缓存失效, 强制重新向服务器(或代理)发起验证(因为max-stale等字段可能改变缓存的失效时间)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;only-if-cached&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;仅仅返回已经缓存的资源, 不访问网络, 若无缓存则返回504&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;no-transform&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type字段的修改(因此代理的gzip压缩将不被允许)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设所请求资源于4月5日缓存, 且在4月12日过期.&lt;/p&gt;
&lt;p&gt;当max-age 与 max-stale 和 min-fresh 同时使用时, 它们的设置相互之间独立生效, 最为保守的缓存策略总是有效. 这意味着, 如果max-age=10 days, max-stale=2 days, min-fresh=3 days, 那么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据max-age的设置, 覆盖原缓存周期, 缓存资源将在4月15日失效(5+10=15);&lt;/li&gt;
&lt;li&gt;根据max-stale的设置, 缓存过期后两天依然有效, 此时响应将返回110(Response is stale)状态码, 缓存资源将在4月14日失效(12+2=14);&lt;/li&gt;
&lt;li&gt;根据min-fresh的设置, 至少要留有3天的新鲜期, 缓存资源将在4月9日失效(12-3=9);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于客户端总是采用最保守的缓存策略, 因此, 4月9日后, 对于该资源的请求将重新向服务器发起验证.&lt;/p&gt;
&lt;h4 id=&quot;Pragma&quot;&gt;&lt;a href=&quot;#Pragma&quot; class=&quot;headerlink&quot; title=&quot;Pragma&quot;&gt;&lt;/a&gt;Pragma&lt;/h4&gt;&lt;p&gt;http1.0字段, 通常设置为Pragma:no-cache, 作用同Cache-Control:no-cache. 当一个no-cache请求发送给一个不遵循HTTP/1.1的服务器时, 客户端应该包含pragma指令. 为此, 勾选☑️ 上disable cache时, 浏览器自动带上了pragma字段. 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/26b2c70ed25ebd9b44da04b9f2968773.png&quot; alt=&quot;Pragma&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Expires&quot;&gt;&lt;a href=&quot;#Expires&quot; class=&quot;headerlink&quot; title=&quot;Expires&quot;&gt;&lt;/a&gt;Expires&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;Expires:Wed, 05 Apr 2017 00:55:35 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即到期时间, 以服务器时间为参考系, 其优先级比 Cache-Control:max-age 低, 两者同时出现在响应头时, Expires将被后者覆盖. 如果Expires, Cache-Control: max-age, 或 Cache-Control:s-maxage 都没有在响应头中出现, 并且也没有其它缓存的设置, 那么浏览器默认会采用一个启发式的算法, 通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间.&lt;/p&gt;
&lt;p&gt;如下资源便采取了启发式缓存算法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/7d6c0e73063761cb6e9cac3ba956446d.png&quot; alt=&quot;启发式缓存算法&quot;&gt;&lt;/p&gt;
&lt;p&gt;其缓存时间为 (Date_value - Last-Modified_value) * 10%, 计算如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Date_value = new Date(&amp;apos;Thu, 06 Apr 2017 01:30:56 GMT&amp;apos;).getTime();
const LastModified_value = new Date(&amp;apos;Thu, 01 Dec 2016 06:23:23 GMT&amp;apos;).getTime();
const cacheTime = (Date_value - LastModified_value) / 10;
const Expires_timestamp = Date_value + cacheTime;
const Expires_value = new Date(Expires_timestamp);
console.log(&amp;apos;Expires:&amp;apos;, Expires_value); // Expires: Tue Apr 18 2017 23:25:41 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见该资源将于2017年4月18日23点25分41秒过期, 尝试以下两步进行验证:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;试着把本地时间修改为2017年4月18日23点25分40秒, 迅速刷新页面, 发现强缓存依然有效(依旧是200 OK (from disk cache)).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后又修改本地时间为2017年4月18日23点26分40秒(即往后拨1分钟), 刷新页面, 发现缓存已过期, 此时浏览器重新向服务器发起了验证, 且命中了304协商缓存, 如下所示.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/d289583ed4b52aaf0b64d10820b714f9.png&quot; alt=&quot;304协商缓存&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将本地时间恢复正常(即 2017-04-06 09:54:19). 刷新页面, 发现Date依然是4月18日, 如下所示.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/2554e461ec747e0bdb102c2941c287f8.png&quot; alt=&quot;304协商缓存&quot;&gt;&lt;/p&gt;
&lt;p&gt;从⚠️ Provisional headers are shown 和Date字段可以看出来, 浏览器并未发出请求, 缓存依然有效, 只不过此时Status Code显示为200 OK. (甚至我还专门打开了charles, 也没有发现该资源的任何请求, 可见这个200 OK多少有些误导人的意味)&lt;/p&gt;
&lt;p&gt;可见, 启发式缓存算法采用的缓存时间可长可短, 因此对于常规资源, 建议明确设置缓存时间(如指定max-age 或 expires).&lt;/p&gt;
&lt;h4 id=&quot;ETag&quot;&gt;&lt;a href=&quot;#ETag&quot; class=&quot;headerlink&quot; title=&quot;ETag&quot;&gt;&lt;/a&gt;ETag&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ETag:&amp;quot;fcb82312d92970bdf0d18a4eca08ebc7efede4fe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.&lt;/p&gt;
&lt;h4 id=&quot;If-Match&quot;&gt;&lt;a href=&quot;#If-Match&quot; class=&quot;headerlink&quot; title=&quot;If-Match&quot;&gt;&lt;/a&gt;If-Match&lt;/h4&gt;&lt;p&gt;语法: If-Match: ETag_value 或者 If-Match: ETag_value, ETag_value, …&lt;/p&gt;
&lt;p&gt;缓存校验字段, 其值为上次收到的一个或多个etag 值. 常用于判断条件是否满足, 如下两种场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 GET 或 HEAD 请求, 结合 Range 头字段, 它可以保证新范围的请求和前一个来自相同的源, 如果不匹配, 服务器将返回一个416(Range Not Satisfiable)状态码的响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 PUT 或者其他不安全的请求, If-Match 可用于阻止错误的更新操作, 如果不匹配, 服务器将返回一个412(Precondition Failed)状态码的响应.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;If-None-Match&quot;&gt;&lt;a href=&quot;#If-None-Match&quot; class=&quot;headerlink&quot; title=&quot;If-None-Match&quot;&gt;&lt;/a&gt;If-None-Match&lt;/h4&gt;&lt;p&gt;语法: If-None-Match: ETag_value 或者 If-None-Match: ETag_value, ETag_value, …&lt;/p&gt;
&lt;p&gt;缓存校验字段, 结合ETag字段, 常用于判断缓存资源是否有效, 优先级比If-Modified-Since高.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 GET 或 HEAD 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回 Cache-Control, Content-Location, Date, ETag, Expires, and Vary 中之一的字段.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(Precondition Failed)状态码的响应.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Last-Modified&quot;&gt;&lt;a href=&quot;#Last-Modified&quot; class=&quot;headerlink&quot; title=&quot;Last-Modified&quot;&gt;&lt;/a&gt;Last-Modified&lt;/h4&gt;&lt;p&gt;语法: Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Last-Modified: Tue, 04 Apr 2017 10:01:15 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 new Date().toGMTString()获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况.&lt;/p&gt;
&lt;h4 id=&quot;If-Modified-Since&quot;&gt;&lt;a href=&quot;#If-Modified-Since&quot; class=&quot;headerlink&quot; title=&quot;If-Modified-Since&quot;&gt;&lt;/a&gt;If-Modified-Since&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;If-Modified-Since: Tue, 04 Apr 2017 10:12:27 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应.&lt;/p&gt;
&lt;h4 id=&quot;If-Unmodified-Since&quot;&gt;&lt;a href=&quot;#If-Unmodified-Since&quot; class=&quot;headerlink&quot; title=&quot;If-Unmodified-Since&quot;&gt;&lt;/a&gt;If-Unmodified-Since&lt;/h4&gt;&lt;p&gt;缓存校验字段, 语法同上. 表示资源未修改则正常执行更新, 否则返回412(Precondition Failed)状态码的响应. 常用于如下两种场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不安全的请求, 比如说使用post请求更新wiki文档, 文档未修改时才执行更新.&lt;/li&gt;
&lt;li&gt;与 If-Range 字段同时使用时, 可以用来保证新的片段请求来自一个未修改的文档.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;强缓存&quot;&gt;&lt;a href=&quot;#强缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存&quot;&gt;&lt;/a&gt;强缓存&lt;/h4&gt;&lt;p&gt;一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存. Chrome下的现象是 200 OK (from disk cache) 或者 200 OK (from memory cache). 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/f49cbe88b4443356b3307146f4b8eed7.png&quot; alt=&quot;强缓存&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于常规请求, 只要存在该资源的缓存, 且Cache-Control:max-age 或者expires没有过期, 那么就能命中强缓存.&lt;/p&gt;
&lt;h4 id=&quot;协商缓存&quot;&gt;&lt;a href=&quot;#协商缓存&quot; class=&quot;headerlink&quot; title=&quot;协商缓存&quot;&gt;&lt;/a&gt;协商缓存&lt;/h4&gt;&lt;p&gt;缓存过期后, 继续请求该资源, 对于现代浏览器, 拥有如下两种做法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据上次响应中的ETag_value, 自动往request header中添加If-None-Match字段. 服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较, 若相同, 则命中协商缓存, 返回304响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据上次响应中的Last-Modified_value, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上, ETag优先级比Last-Modified高, 同时存在时, 前者覆盖后者. 下面通过实例来理解下强缓存和协商缓存.&lt;/p&gt;
&lt;p&gt;如下忽略首次访问, 第二次通过 If-Modified-Since 命中了304协商缓存.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/fb153efd63224a5173b481291d609467.png&quot; alt=&quot;协商缓存&quot;&gt;&lt;/p&gt;
&lt;p&gt;协商缓存的响应结果, 不仅验证了资源的有效性, 同时还更新了浏览器缓存. 主要更新内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Age:0
Cache-Control:max-age=600
Date: Wed, 05 Apr 2017 13:09:36 GMT
Expires:Wed, 05 Apr 2017 00:55:35 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Age:0 表示命中了代理服务器的缓存, age值为0表示代理服务器刚刚刷新了一次缓存.&lt;/p&gt;
&lt;p&gt;Cache-Control:max-age=600 覆盖 Expires 字段, 表示从Date_value, 即 Wed, 05 Apr 2017 13:09:36 GMT 起, 10分钟之后缓存过期. 因此10分钟之内访问, 将会命中强缓存, 如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2017/04/cb04b000985d98bad312929c3f0521c6.png&quot; alt=&quot;强缓存&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然, 除了上述与缓存直接相关的字段外, http header中还包括如下间接相关的字段.&lt;/p&gt;
&lt;h4 id=&quot;Age&quot;&gt;&lt;a href=&quot;#Age&quot; class=&quot;headerlink&quot; title=&quot;Age&quot;&gt;&lt;/a&gt;Age&lt;/h4&gt;&lt;p&gt;出现此字段, 表示命中代理服务器的缓存. 它指的是代理服务器对于请求资源的已缓存时间, 单位为秒. 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Age:2383321
Date:Wed, 08 Mar 2017 16:12:42 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上指的是, 代理服务器在2017年3月8日16:12:42时向源服务器发起了对该资源的请求, 目前已缓存了该资源2383321秒.&lt;/p&gt;
&lt;h4 id=&quot;Date&quot;&gt;&lt;a href=&quot;#Date&quot; class=&quot;headerlink&quot; title=&quot;Date&quot;&gt;&lt;/a&gt;Date&lt;/h4&gt;&lt;p&gt;指的是响应生成的时间. 请求经过代理服务器时, 返回的Date未必是最新的, 通常这个时候, 代理服务器将增加一个Age字段告知该资源已缓存了多久.&lt;/p&gt;
&lt;h4 id=&quot;Vary&quot;&gt;&lt;a href=&quot;#Vary&quot; class=&quot;headerlink&quot; title=&quot;Vary&quot;&gt;&lt;/a&gt;Vary&lt;/h4&gt;&lt;p&gt;对于服务器而言，资源文件可能不止一个版本，比如说压缩和未压缩，针对不同的客户端，通常需要返回不同的资源版本，比如说老式的浏览器可能不支持解压缩, 这个时候, 就需要返回一个未压缩的版本; 对于新的浏览器, 支持压缩, 返回一个压缩的版本, 有利于节省带宽, 提升体验. 那么怎么区分这个版本呢, 这个时候就需要Vary了.&lt;/p&gt;
&lt;p&gt;服务器通过指定Vary: Accept-Encoding, 告知代理服务器, 对于这个资源, 需要缓存两个版本: 压缩和未压缩. 这样老式浏览器和新的浏览器, 通过代理, 就分别拿到了未压缩和压缩版本的资源, 避免了都拿同一个资源的尴尬.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vary:Accept-Encoding,User-Agent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上设置, 代理服务器将针对是否压缩和浏览器类型两个维度去缓存资源. 如此一来, 同一个url, 就能针对PC和Mobile返回不同的缓存内容.&lt;/p&gt;
&lt;h4 id=&quot;怎么让浏览器不缓存静态资源&quot;&gt;&lt;a href=&quot;#怎么让浏览器不缓存静态资源&quot; class=&quot;headerlink&quot; title=&quot;怎么让浏览器不缓存静态资源&quot;&gt;&lt;/a&gt;怎么让浏览器不缓存静态资源&lt;/h4&gt;&lt;p&gt;实际上, 工作中很多场景都需要避免浏览器缓存, 除了浏览器隐私模式, 请求时想要禁用缓存, 还可以设置请求头: Cache-Control: no-cache, no-store, must-revalidate .&lt;/p&gt;
&lt;p&gt;当然, 还有一种常用做法: 即给请求的资源增加一个版本号, 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;../css/style.css?version=1.8.9&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样做的好处就是你可以自由控制什么时候加载最新的资源.&lt;/p&gt;
&lt;p&gt;不仅如此, HTML也可以禁用缓存, 即在页面的&lt;/p&gt;
&lt;p&gt;节点中加入标签, 代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Cache-Control&amp;quot; content=&amp;quot;no-cache, no-store, must-revalidate&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述虽能禁用缓存, 但只有部分浏览器支持, 而且由于代理不解析HTML文档, 故代理服务器也不支持这种方式.&lt;/p&gt;
&lt;h4 id=&quot;IE8的异常表现&quot;&gt;&lt;a href=&quot;#IE8的异常表现&quot; class=&quot;headerlink&quot; title=&quot;IE8的异常表现&quot;&gt;&lt;/a&gt;IE8的异常表现&lt;/h4&gt;&lt;p&gt;实际上, 上述缓存有关的规律, 并非所有浏览器都完全遵循. 比如说IE8.&lt;/p&gt;
&lt;p&gt;资源缓存是否有效相关.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;浏览器&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;前提&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;操作&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表现&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;正常表现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IE8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源缓存有效&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;新开一个窗口加载网页&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;重新发送请求(返回200)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;展示缓存的页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IE8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源缓存失效&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;原浏览器窗口中单击 Enter 按钮&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;展示缓存的页面&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;重新发送请求(返回200)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Last-Modified / E-Tag 相关.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;浏览器&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;前提&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;操作&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表现&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;正常表现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IE8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源内容没有修改&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;新开一个窗口加载网页&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;浏览器重新发送请求(返回200)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;重新发送请求(返回304)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IE8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;资源内容已修改&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;原浏览器窗口中单击 Enter 按钮&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;浏览器展示缓存的页面&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;重新发送请求(返回200)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;转自： &lt;a href=&quot;http://web.jobbole.com/91084/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://web.jobbole.com/91084/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;缓存一直是前端优化的主战场，利用好缓存就成功了一半。本篇从http请求和响应的头域入手, 让你对浏览器缓存有个整体的概念. 最终你会发现强缓存, 协商缓存 和 启发式缓存是如此的简单.&lt;br&gt;
    
    </summary>
    
    
      <category term="缓存" scheme="http://blog.newbug.xyz/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6常用基础集合</title>
    <link href="http://blog.newbug.xyz/2017/04/21/ES6%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88/"/>
    <id>http://blog.newbug.xyz/2017/04/21/ES6常用基础集合/</id>
    <published>2017-04-21T01:42:19.000Z</published>
    <updated>2017-04-21T02:07:57.487Z</updated>
    
    <content type="html">&lt;p&gt;ES6彻底改变了前端的编码风格，可以说对于前端的影响非常巨大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在学习之前，推荐大家使用babel官方提供的在线编译工具，编写自己的demo，会在右侧实时显示出编译之后的代码，以供参考学习 &lt;a href=&quot;http://babeljs.io/repl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://babeljs.io/repl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;新的变量声明方式-let-const&quot;&gt;&lt;a href=&quot;#新的变量声明方式-let-const&quot; class=&quot;headerlink&quot; title=&quot;新的变量声明方式 let/const&quot;&gt;&lt;/a&gt;新的变量声明方式 let/const&lt;/h2&gt;&lt;p&gt;与var不同，新的变量声明方式带来了一些不一样的特性，其中最重要的两个特性就是提供了块级作用域与不再具备变量提升。&lt;/p&gt;
&lt;p&gt;通过2个简单的例子来说明这两点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    let a = 20;
}

console.log(a);  // a is not defined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这个简单的例子，会被编译为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    let _a = 20;
}

console.log(a);  // a is not defined


// ES5
console.log(a);   // undefined
var a = 20;

// ES6
console.log(a); // a is not defined
let a = 20;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，如果你的代码编译成为了ES5之后，仍然会存在变量提升，因此这一点只需要我们记住即可。我们在实际使用中，也需要尽量避免使用变量提升的特性带来的负面影响。对于变量提升的滥用，只存在与面试题中。&lt;/p&gt;
&lt;p&gt;使用ES6，我们需要全面使用let/const替换var，那么什么时候用let，什么时候用const就成为了一个大家要熟练区分的一个知识点。&lt;/p&gt;
&lt;h3 id=&quot;我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量&quot;&gt;&lt;a href=&quot;#我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量&quot; class=&quot;headerlink&quot; title=&quot;我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量&quot;&gt;&lt;/a&gt;我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量&lt;/h3&gt;&lt;p&gt;当值为基础数据类型时，那么这里的值，就是指值本身。&lt;br&gt;而当值对应的为引用数据类型时，那么我这里说的值，则表示指向该对象的引用。这里需要注意，正因为该值为一个引用，重要保证引用不变就可以，我们仍然可以改变该引用所指向的对象。&lt;/p&gt;
&lt;p&gt;当我们试图改变const声明的变量时，则会报错:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = null;
a = 20;


const obDev = {
    a: 20,
    b: 30
}


obDev.a = 30;

console.log(obDev); // Object {a: 30, b: 30}


const fn = function() {}
const a = obDev.a;
... ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要抓住上面我说的特性，那么在使用let/const时就会显得游刃有余。&lt;br&gt;根据我自己的经验，使用const的场景要比使用let的场景多很多。&lt;/p&gt;
&lt;h2 id=&quot;箭头函数的使用&quot;&gt;&lt;a href=&quot;#箭头函数的使用&quot; class=&quot;headerlink&quot; title=&quot;箭头函数的使用&quot;&gt;&lt;/a&gt;箭头函数的使用&lt;/h2&gt;&lt;p&gt;之前我说ES6颠覆了js的编码习惯，箭头函数的使用占了很大一部分。&lt;/p&gt;
&lt;p&gt;首先是写法上的不同:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// es5
var fn = function(a, b) {
    return a + b;
}

// es6 箭头函数写法，当函数直接被return时
const fn = (a, b) =&amp;gt; a + b;

// es5
var foo = function() {
    var a = 20；
    var b = 30;
    return a + b;
}

// es6
const foo = () =&amp;gt; {
   const a = 20;
   const b = 30;
   return a + b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;箭头函数可以替换函数表达式，但是不能替换函数声明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其次还有一个至关重要的一点，那就是箭头函数中，没有this。如果你在箭头函数中使用了this，那么该this一定就是外层的this。&lt;/p&gt;
&lt;p&gt;也正是因为箭头函数中没有this，因此我们也就无从谈起用call/apply/bind来改变this指向。记住这个特性，能让你在react组件之间传值时少走无数弯路。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var person = {
    name: &amp;apos;tom&amp;apos;,
    getName: function() {
        return this.name;
    }
}

// 我们试图用ES6的写法来重构上面的对象
const person = {
    name: &amp;apos;tom&amp;apos;,
    getName: () =&amp;gt; this.name
}

// 但是编译结果却是
var person = {
    name: &amp;apos;tom&amp;apos;,
    getName: function getName() {
        return undefined.name;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在ES6中，会默认采用严格模式，因此this也不会自动指向window对象了，而箭头函数本身并没有this，因此this就只能是undefined，这一点，在使用的时候，一定要慎重慎重再慎重，不然踩了坑你都不知道自己错在哪！这种情况，如果你还想用this，就不用使用箭头函数的写法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 可以稍做改动
const person = {
    name: &amp;apos;tom&amp;apos;,
    getName: function() {
        return setTimeout(() =&amp;gt; this.name, 1000);
    }
}

// 编译之后变成
var person = {
    name: &amp;apos;tom&amp;apos;,
    getName: function getName() {
        var _this = this;  // 使用了我们在es5时常用的方式保存this引用

        return setTimeout(function () {
            return _this.name;
        }, 1000);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先记住箭头函数的写法，并留意箭头函数中关于this的特殊性，更过实践与注意事项我们在封装react组件时再慢慢来感受&lt;/p&gt;
&lt;h2 id=&quot;模板字符串&quot;&gt;&lt;a href=&quot;#模板字符串&quot; class=&quot;headerlink&quot; title=&quot;模板字符串&quot;&gt;&lt;/a&gt;模板字符串&lt;/h2&gt;&lt;p&gt;模板字符串是为了解决使用+号拼接字符串的不便利而出现的。它的功能非常强大，但是我们大多数时候使用它则非常简单。看一个例子大家就明白怎么使用了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// es6
const a = 20;
const b = 30;
const string = `${a}+${b}=${a+b}`;

// es5
var a = 20;
var b = 30;
var string = a + &amp;quot;+&amp;quot; + b + &amp;quot;=&amp;quot; + (a + b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 整个字符串包裹起来，而在其中使用 ${} 来包裹一个变量或者一个表达式。&lt;/p&gt;
&lt;p&gt;当然模板字符串还支持换行等强大的功能，更多的大家可通过参考资料进一步学习&lt;/p&gt;
&lt;h2 id=&quot;解析结构&quot;&gt;&lt;a href=&quot;#解析结构&quot; class=&quot;headerlink&quot; title=&quot;解析结构&quot;&gt;&lt;/a&gt;解析结构&lt;/h2&gt;&lt;p&gt;解析结构是一种全新的写法，我们只需要使用一个例子，大家就能够明白解析结构到底是怎么一回事儿。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 首先有这么一个对象
const props = {
    className: &amp;apos;tiger-button&amp;apos;,
    loading: false,
    clicked: true,
    disabled: &amp;apos;disabled&amp;apos;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们想要取得其中的2个值：loading与clicked时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// es5
var loading = props.loading;
var clicked = props.clicked;

// es6
const { loading, clicked } = props;

// 给一个默认值，当props对象中找不到loading时，loading就等于该默认值
const { loading = false, clicked } = props;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是简单了许多？正是由于解析结构大大减少了代码量，因此它大受欢迎，在很多代码中它的影子随处可见。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 比如
// section1 
import React, { Component } from &amp;apos;react&amp;apos;;

// section2
export { default } from &amp;apos;./Button&amp;apos;;

// section3
const { click, loading } = this.props;
const { isCheck } = this.state;

// more  任何获取对象属性值的场景都可以使用解析结构来减少我们的代码量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，数组也有属于自己的解析结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// es6
const arr = [1, 2, 3];
const [a, b, c] = arr;

// es5
var arr = [1, 2, 3];
var a = arr[0];
var b = arr[1];
var c = arr[2];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数组以序列号一一对应，这是一个有序的对应关系。&lt;br&gt;而对象根据属性名一一对应，这是一个无序的对应关系。&lt;br&gt;根据这个特性，使用解析结构从对象中获取属性值更加具有可用性。&lt;/p&gt;
&lt;h2 id=&quot;函数默认参数&quot;&gt;&lt;a href=&quot;#函数默认参数&quot; class=&quot;headerlink&quot; title=&quot;函数默认参数&quot;&gt;&lt;/a&gt;函数默认参数&lt;/h2&gt;&lt;p&gt;之前我们不能直接为函数指定默认参数，因此很多时候为了保证传入的参数具备一个默认值，我们常常使用如下的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(x, y) {
    var x = x || 20;
    var y = y || 30;
    return x + y;
}

console.log(add()); // 50
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式并不是没有缺点，比如当我传入一个x值为false，这个时候任然会取到默认值，就不是我们的本意了。&lt;/p&gt;
&lt;p&gt;来看看ES6的默认值写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(x = 20, y = 30) {
    return x + y;
}

console.log(add());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在实际开发中给参数添加适当的默认值，可以让我们堆函数的参数类型有一个直观的认知&lt;/p&gt;
&lt;p&gt;const ButtonGroupProps = {&lt;br&gt;    size: ‘normal’,&lt;br&gt;    className: ‘xxxx-button-group’,&lt;br&gt;    borderColor: ‘#333’&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;export default function ButtonGroup(props = ButtonGroupProps) {&lt;br&gt;    … …&lt;br&gt;}&lt;/p&gt;
&lt;h2 id=&quot;展开运算符&quot;&gt;&lt;a href=&quot;#展开运算符&quot; class=&quot;headerlink&quot; title=&quot;展开运算符&quot;&gt;&lt;/a&gt;展开运算符&lt;/h2&gt;&lt;p&gt;在ES6中用…来表示展开运算符，它可以将数组方法或者对象进行展开。先来看一个例子它是如何使用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 3];
const arr2 = [...arr1, 10, 20, 30];

// 这样，arr2 就变成了[1, 2, 3, 10, 20, 30];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，展开对象数据也是可以得到类似的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj1 = {
  a: 1,
  b: 2, 
  c: 3
}

const obj2 = {
  ...obj1,
  d: 4,
  e: 5,
  f: 6
}

// 结果类似于 const obj2 = Object.assign({}, obj1, {d: 4})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;展开运算符还常常运用在解析结构之中，例如我们在Raect封装组件的时候常常不确定props到底还有多少数据会传进来，就会利用展开运算符来处理剩余的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这种方式在react中十分常用
const props = {
  size: 1,
  src: &amp;apos;xxxx&amp;apos;,
  mode: &amp;apos;si&amp;apos;
}


const { size, ...others } = props;

console.log(others)

// 然后再利用暂开运算符传递给下一个元素，再以后封装react组件时会大量使用到这种方式，正在学习react的同学一定要搞懂这种使用方式
&amp;lt;button&amp;gt;&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;展开运算符还用在函数的参数中，来表示函数的不定参。只有放在最后才能作为函数的不定参，否则会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 所有参数之和
const add = (a, b, ...more) =&amp;gt; {
    return more.reduce((m, n) =&amp;gt; m + n) + a + b
}

console.log(add(1, 23, 1, 2, 3, 4, 5)) // 39
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;展开运算符的运用可以大大提高我们的代码效率，但是在刚开始使用的时候比较绕脑，掌握好了用起来还是非常爽的，记住这些使用场景，平时在用的时候可以刻意多运用就行了。&lt;/p&gt;
&lt;p&gt;更多信息参考阮一峰老师的入门教程：&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://es6.ruanyifeng.com/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ES6彻底改变了前端的编码风格，可以说对于前端的影响非常巨大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在学习之前，推荐大家使用babel官方提供的在线编译工具，编写自己的demo，会在右侧实时显示出编译之后的代码，以供参考学习 &lt;a href=&quot;http://babeljs.io/repl/&quot;&gt;http://babeljs.io/repl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://blog.newbug.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>stylus中文文档</title>
    <link href="http://blog.newbug.xyz/2017/04/20/stylus%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    <id>http://blog.newbug.xyz/2017/04/20/stylus中文文档/</id>
    <published>2017-04-20T01:52:55.000Z</published>
    <updated>2017-04-20T01:58:36.212Z</updated>
    
    <content type="html">&lt;p&gt;Stylus - 富有表现力的、动态的、健壮的CSS&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常见的css&quot;&gt;&lt;a href=&quot;#常见的css&quot; class=&quot;headerlink&quot; title=&quot;常见的css&quot;&gt;&lt;/a&gt;常见的css&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;body {
  font: 12px Helvetica, Arial, sans-serif;
}
a.button {
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;花括号去掉&quot;&gt;&lt;a href=&quot;#花括号去掉&quot; class=&quot;headerlink&quot; title=&quot;花括号去掉&quot;&gt;&lt;/a&gt;花括号去掉&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;body
  font: 12px Helvetica, Arial, sans-serif;

a.button
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;分号去掉&quot;&gt;&lt;a href=&quot;#分号去掉&quot; class=&quot;headerlink&quot; title=&quot;分号去掉&quot;&gt;&lt;/a&gt;分号去掉&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;body
  font: 12px Helvetica, Arial, sans-serif

a.button
  -webkit-border-radius: 5px
  -moz-border-radius: 5px
  border-radius: 5px
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;冒号去掉&quot;&gt;&lt;a href=&quot;#冒号去掉&quot; class=&quot;headerlink&quot; title=&quot;冒号去掉&quot;&gt;&lt;/a&gt;冒号去掉&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;body
  font 12px Helvetica, Arial, sans-serif

a.button
  -webkit-border-radius 5px
  -moz-border-radius 5px
  border-radius 5px
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;函数类&quot;&gt;&lt;a href=&quot;#函数类&quot; class=&quot;headerlink&quot; title=&quot;函数类&quot;&gt;&lt;/a&gt;函数类&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;border-radius()
  -webkit-border-radius arguments
  -moz-border-radius arguments
  border-radius arguments

body
  font 12px Helvetica, Arial, sans-serif

a.button
  border-radius(5px)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;混合书写&quot;&gt;&lt;a href=&quot;#混合书写&quot; class=&quot;headerlink&quot; title=&quot;混合书写&quot;&gt;&lt;/a&gt;混合书写&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;border-radius()
  -webkit-border-radius arguments
  -moz-border-radius arguments
  border-radius arguments

body
  font 12px Helvetica, Arial, sans-serif

a.button
  border-radius 5px
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;@import &amp;apos;vendor&amp;apos;

body
  font 12px Helvetica, Arial, sans-serif

a.button
  border-radius 5px
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语言函数&quot;&gt;&lt;a href=&quot;#语言函数&quot; class=&quot;headerlink&quot; title=&quot;语言函数&quot;&gt;&lt;/a&gt;语言函数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;sum(nums...)
  sum = 0
  sum += n for n in nums

sum(1 2 3 4)
// =&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;所有的都是可以选择的&quot;&gt;&lt;a href=&quot;#所有的都是可以选择的&quot; class=&quot;headerlink&quot; title=&quot;所有的都是可以选择的&quot;&gt;&lt;/a&gt;所有的都是可以选择的&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;fonts = helvetica, arial, sans-serif

body {
  padding: 50px;
  font: 14px/1.4 fonts;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Stylus获取、安装&quot;&gt;&lt;a href=&quot;#Stylus获取、安装&quot; class=&quot;headerlink&quot; title=&quot;Stylus获取、安装&quot;&gt;&lt;/a&gt;Stylus获取、安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ npm install stylus
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Stylus的特征&quot;&gt;&lt;a href=&quot;#Stylus的特征&quot; class=&quot;headerlink&quot; title=&quot;Stylus的特征&quot;&gt;&lt;/a&gt;Stylus的特征&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;冒号可选
分号可选
逗号可选
括号可选
变量
插值
混合书写
算术
强制类型转换
动态导入
条件
迭代
嵌套选择
父级参考
变量函数调用
词法作用域
内置函数(&amp;gt;25)
内部语言函数
压缩可选
图像内联可选
可执行Stylus
健壮的错误报告
单行和多行注释
CSS字面量
字符转义
TextMate捆绑
以及其他更多
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多信息github：&lt;a href=&quot;https://github.com/stylus/stylus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/stylus/stylus&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Stylus - 富有表现力的、动态的、健壮的CSS&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js判断移动端是否安装app，若安装，则打开，未安装则跳转到下载页面</title>
    <link href="http://blog.newbug.xyz/2017/04/19/js%E5%88%A4%E6%96%AD%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85app%EF%BC%8C%E8%8B%A5%E5%AE%89%E8%A3%85%EF%BC%8C%E5%88%99%E6%89%93%E5%BC%80%EF%BC%8C%E6%9C%AA%E5%AE%89%E8%A3%85%E5%88%99%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%8B%E8%BD%BD%E9%A1%B5%E9%9D%A2/"/>
    <id>http://blog.newbug.xyz/2017/04/19/js判断移动端是否安装app，若安装，则打开，未安装则跳转到下载页面/</id>
    <published>2017-04-19T09:29:48.000Z</published>
    <updated>2017-04-20T06:17:04.467Z</updated>
    
    <content type="html">&lt;p&gt;近期公司需要针对分享流程进行优化，其中一点就是前端H5检测是否安装应用，来进行不同的判断（下载或直接跳转到app中）。原理很简单：创建一个iframe去打开uri。如果打开app成功网页进入后台，再切换回来时间会超过2.5s。利用时间去检测。下面来看具体实现过程：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;你可能会遇到的问题&quot;&gt;&lt;a href=&quot;#你可能会遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;你可能会遇到的问题&quot;&gt;&lt;/a&gt;你可能会遇到的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是uri，获取uri需要哪些帮助？&lt;/li&gt;
&lt;li&gt;安卓中应用切换到后台， 计时器仍会不断运行有什么解决方法？&lt;/li&gt;
&lt;li&gt;微信中不支持第三方uri,下载应用。怎么解决来完成跳转到自身app。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;uri获取&quot;&gt;&lt;a href=&quot;#uri获取&quot; class=&quot;headerlink&quot; title=&quot;uri获取&quot;&gt;&lt;/a&gt;uri获取&lt;/h2&gt;&lt;p&gt;这里的uri,指得就是通过 Url scheme 来实现的H5与安卓、苹果应用之间的跳转链接。&lt;/p&gt;
&lt;p&gt;我们需要找到客户端的同事，来获取如下格式的链接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xx://&amp;apos;跳转页面&amp;apos;/&amp;apos;携带参数&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;url 就是我们平常理解的链接。&lt;br&gt;scheme 是指url链接中的最初位置，就是上边链接中 ‘xx’的位置。&lt;br&gt;详细介绍可以看这里：&lt;a href=&quot;https://sspai.com/post/31500&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://sspai.com/post/31500&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用这个链接我们可以跳转到 应用中的某个页面,并可以携带一定的参数。这个是我们实现这个功能的前提哟。&lt;/p&gt;
&lt;h2 id=&quot;具体实现&quot;&gt;&lt;a href=&quot;#具体实现&quot; class=&quot;headerlink&quot; title=&quot;具体实现&quot;&gt;&lt;/a&gt;具体实现&lt;/h2&gt;&lt;h3 id=&quot;第一步：通过iframe打开App&quot;&gt;&lt;a href=&quot;#第一步：通过iframe打开App&quot; class=&quot;headerlink&quot; title=&quot;第一步：通过iframe打开App&quot;&gt;&lt;/a&gt;第一步：通过iframe打开App&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Android平台则各个app厂商差异很大，比如Chrome从25及以后就不再支持通过js触发（非用户点击），所以这里使用iframe src地址等来触发scheme。

//在iframe 中打开APP
var ifr = document.createElement(&amp;apos;iframe&amp;apos;);
ifr.src = openUrl;
ifr.style.display = &amp;apos;none&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第二步：判断是否安装某应用&quot;&gt;&lt;a href=&quot;#第二步：判断是否安装某应用&quot; class=&quot;headerlink&quot; title=&quot;第二步：判断是否安装某应用&quot;&gt;&lt;/a&gt;第二步：判断是否安装某应用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;原理：若通过url scheme 打开app成功，那么当前h5会进入后台，通过计时器会有明显延迟。利用时间来判断。

//检查app是否打开
function checkOpen(cb){
    var _clickTime = +(new Date());
    function check(elsTime) {
        if ( elsTime &amp;gt; 3000 || document.hidden || document.webkitHidden) {
            cb(1);
        } else {
            cb(0);
        }
    }
    //启动间隔20ms运行的定时器，并检测累计消耗时间是否超过3000ms，超过则结束
    var _count = 0, intHandle;
    intHandle = setInterval(function(){
        _count++;        
        var elsTime = +(new Date()) - _clickTime;
        if (_count&amp;gt;=100 || elsTime &amp;gt; 3000 ) {
            clearInterval(intHandle);
            check(elsTime);
        }
    }, 20);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 由于安卓手机,页面进入后台，定时器setTimeout仍会不断运行，所以这里使用setInterval,较小间隔时间重复多次。来根据累计时间判断
* cb为回调函数，根据返回0 or 1来判断是否安装。
* document.hidden对大于4.4webview支持很好，为页面可见性api。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第三步：微信中实现打开or下载应用效果&quot;&gt;&lt;a href=&quot;#第三步：微信中实现打开or下载应用效果&quot; class=&quot;headerlink&quot; title=&quot;第三步：微信中实现打开or下载应用效果&quot;&gt;&lt;/a&gt;第三步：微信中实现打开or下载应用效果&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;这里使用的是应用宝微链接实现。

if (callback) {
  //客户端检测微信直接跳应用宝链接
  var browser = BrowserInfo();
  //使用微链接
  var encodeUri = encodeURIComponent(&amp;apos;你的uri&amp;apos;);

  if (browser.isWeixin) {
    window.location.href = &amp;apos;你的微链url&amp;amp;android_schema=&amp;apos;+encodeUri;

  }else{
    checkOpen(function(opened){
        callback &amp;amp;&amp;amp; callback(opened);
    });

  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 微链接是应用宝提供的，可以在后台获取。
* 使用微链接必须做encodeURIComponent转义。
* 链接地址在微链接后拼接一个android_schema参数加你的uri。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完整函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export const openApp = function(openUrl, callback) {
    //检查app是否打开
    function checkOpen(cb){
        var _clickTime = +(new Date());
        function check(elsTime) {
            if ( elsTime &amp;gt; 3000 || document.hidden || document.webkitHidden) {
                cb(1);
            } else {
                cb(0);
            }
        }
        //启动间隔20ms运行的定时器，并检测累计消耗时间是否超过3000ms，超过则结束
        var _count = 0, intHandle;
        intHandle = setInterval(function(){
            _count++;        
            var elsTime = +(new Date()) - _clickTime;
            if (_count&amp;gt;=100 || elsTime &amp;gt; 3000 ) {
                clearInterval(intHandle);
                check(elsTime);
            }
        }, 20);
    }

    //在iframe 中打开APP
    var ifr = document.createElement(&amp;apos;iframe&amp;apos;);
    ifr.src = openUrl;
    ifr.style.display = &amp;apos;none&amp;apos;;

    if (callback) {
      //客户端检测微信直接跳应用宝链接
      var browser = BrowserInfo();
      //使用微链接
      var encodeUri = encodeURIComponent(openUrl);

      if (browser.isWeixin) {
        window.location.href = &amp;apos;你的微链url&amp;amp;android_schema=&amp;apos;+encodeUri;
      }else{
        checkOpen(function(opened){
            callback &amp;amp;&amp;amp; callback(opened);
        });

      }
    }

    document.body.appendChild(ifr);      
    setTimeout(function() {
        document.body.removeChild(ifr);
    }, 2000);  

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他：&lt;br&gt;    函数中调用的BrowserInfo是一个简单的客户端检测。具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 客户端检测
 */
export const BrowserInfo = function() {
  var json = {
    userAgent: navigator.userAgent.toLowerCase(),
    isAndroid: Boolean(navigator.userAgent.match(/android/ig)),
    isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/ig)),
    isIpad: Boolean(navigator.userAgent.match(/ipad/ig)),
    isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/ig)),
  }

  return json;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回调函数的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;页面中可以通过传递回调函数，来获取返回值；并通过是否传这个参数来做进入页面检测。









&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;initial-scale=1.0,user-scalable=no&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Js判定移动端是否安装app,若已安装，则打开，未安装则跳转到下载页面&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&amp;apos;apple-itunes-app&amp;apos; content=&amp;apos;app-id=1221201728&amp;apos;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:;&amp;quot; id=&amp;quot;openApp&amp;quot;&amp;gt;点击打开安装app&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    document.getElementById(&amp;apos;openApp&amp;apos;).onclick = function(e){

        if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i))
           {
            window.location.href = &amp;quot;com.baidu.tieba://&amp;quot;;//ios app协议(如：com.baidu.tieba://)
            window.setTimeout(function() {
                window.location.href = &amp;quot;https://itunes.apple.com/cn/app/id477927812&amp;quot;; //跳转到App store
            }, 2000)
           }
        if(navigator.userAgent.match(/android/i))
        {
            window.location.href = &amp;quot;com.baidu.tieba://app&amp;quot;;//android app协议(如：com.baidu.tieba://app)
            window.setTimeout(function() {
                window.location.href = &amp;quot;https://****.apk&amp;quot;;//android 下载地址
            }, 2000)    
        }
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;近期公司需要针对分享流程进行优化，其中一点就是前端H5检测是否安装应用，来进行不同的判断（下载或直接跳转到app中）。原理很简单：创建一个iframe去打开uri。如果打开app成功网页进入后台，再切换回来时间会超过2.5s。利用时间去检测。下面来看具体实现过程：&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>jquery知识点归纳--dom篇</title>
    <link href="http://blog.newbug.xyz/2017/04/18/jquery%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3-dom%E7%AF%87/"/>
    <id>http://blog.newbug.xyz/2017/04/18/jquery知识点归纳-dom篇/</id>
    <published>2017-04-18T06:00:01.000Z</published>
    <updated>2017-04-18T06:07:11.117Z</updated>
    
    <content type="html">&lt;p&gt;jquery——dom篇&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;创建节点和节点属性&quot;&gt;&lt;a href=&quot;#创建节点和节点属性&quot; class=&quot;headerlink&quot; title=&quot;创建节点和节点属性&quot;&gt;&lt;/a&gt;创建节点和节点属性&lt;/h2&gt;&lt;p&gt;通过JavaScript可以很方便的获取DOM节点，从而进行一系列的DOM操作。但实际上一般开发者都习惯性的先定义好HTML结构，但这样就非常不灵活了。&lt;br&gt;试想下这样的情况：如果我们通过AJAX获取到数据之后然后才能确定结构的话，这种情况就需要动态的处理节点了&lt;br&gt;流程中涉及的一点方法：&lt;br&gt;创建元素：document.createElement&lt;br&gt;设置属性：setAttribute&lt;br&gt;添加文本：innerHTML&lt;br&gt;加入文档：appendChild&lt;br&gt;jquery创建节点&lt;br&gt;$(“html结构”)就是$(“&lt;div&gt;&lt;/div&gt;“)／$(“&lt;div&gt;我是文本节点&lt;/div&gt;“)／$(“&lt;div id=&quot;test&quot; class=&quot;aaron&quot;&gt;我是文本节点&lt;/div&gt;“)&lt;/p&gt;
&lt;h2 id=&quot;dom节点的插入&quot;&gt;&lt;a href=&quot;#dom节点的插入&quot; class=&quot;headerlink&quot; title=&quot;dom节点的插入&quot;&gt;&lt;/a&gt;dom节点的插入&lt;/h2&gt;&lt;h3 id=&quot;append-和appendTo&quot;&gt;&lt;a href=&quot;#append-和appendTo&quot; class=&quot;headerlink&quot; title=&quot;append()和appendTo()&quot;&gt;&lt;/a&gt;append()和appendTo()&lt;/h3&gt;&lt;p&gt;动态创建的元素是不够的，它只是临时存放在内存中，最终我们需要放到页面文档并呈现出来。那么问题来了，怎么放到文档上？这里就涉及到一个位置关系，常见的就是把这个新创建的元素，当作页面某一个元素的子元素放到其内部。针对这样的处理，jQuery就定义2个操作的方法&lt;br&gt;append()前面是被插入的对象，后面是要在对象内插入的元素内容&lt;br&gt;appendTo()前面是要插入的元素内容，而后面是被插入的对象&lt;/p&gt;
&lt;p&gt;###　after()与before()&lt;/p&gt;
&lt;p&gt;before与after都是用来对相对选中元素外部增加相邻的兄弟节点&lt;br&gt;2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面&lt;br&gt;2个方法都支持多个参数传递after(div1,div2,….)&lt;/p&gt;
&lt;h3 id=&quot;prepend-与prependTo&quot;&gt;&lt;a href=&quot;#prepend-与prependTo&quot; class=&quot;headerlink&quot; title=&quot;prepend()与prependTo()&quot;&gt;&lt;/a&gt;prepend()与prependTo()&lt;/h3&gt;&lt;p&gt;.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append()).&lt;/p&gt;
&lt;p&gt;.prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同&lt;br&gt;对于.prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数&lt;/p&gt;
&lt;p&gt;而.prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。&lt;/p&gt;
&lt;h3 id=&quot;insertAfter-与insertBefore&quot;&gt;&lt;a href=&quot;#insertAfter-与insertBefore&quot; class=&quot;headerlink&quot; title=&quot;insertAfter()与insertBefore()&quot;&gt;&lt;/a&gt;insertAfter()与insertBefore()&lt;/h3&gt;&lt;p&gt;.before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面&lt;/p&gt;
&lt;p&gt;.after()和.insertAfter() &lt;/p&gt;
&lt;p&gt;实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面&lt;br&gt;before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理&lt;/p&gt;
&lt;h2 id=&quot;dom结点的删除&quot;&gt;&lt;a href=&quot;#dom结点的删除&quot; class=&quot;headerlink&quot; title=&quot;dom结点的删除&quot;&gt;&lt;/a&gt;dom结点的删除&lt;/h2&gt;&lt;h3 id=&quot;empty&quot;&gt;&lt;a href=&quot;#empty&quot; class=&quot;headerlink&quot; title=&quot;empty()&quot;&gt;&lt;/a&gt;empty()&lt;/h3&gt;&lt;p&gt;empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。&lt;/p&gt;
&lt;h3 id=&quot;remove&quot;&gt;&lt;a href=&quot;#remove&quot; class=&quot;headerlink&quot; title=&quot;remove()&quot;&gt;&lt;/a&gt;remove()&lt;/h3&gt;&lt;p&gt;remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。&lt;/p&gt;
&lt;h3 id=&quot;保留数据的删除操作detach&quot;&gt;&lt;a href=&quot;#保留数据的删除操作detach&quot; class=&quot;headerlink&quot; title=&quot;保留数据的删除操作detach()&quot;&gt;&lt;/a&gt;保留数据的删除操作detach()&lt;/h3&gt;&lt;p&gt;这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。&lt;/p&gt;
&lt;h2 id=&quot;DOM节点的复制与替换&quot;&gt;&lt;a href=&quot;#DOM节点的复制与替换&quot; class=&quot;headerlink&quot; title=&quot;DOM节点的复制与替换&quot;&gt;&lt;/a&gt;DOM节点的复制与替换&lt;/h2&gt;&lt;h3 id=&quot;clone&quot;&gt;&lt;a href=&quot;#clone&quot; class=&quot;headerlink&quot; title=&quot;clone()&quot;&gt;&lt;/a&gt;clone()&lt;/h3&gt;&lt;p&gt;.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。&lt;br&gt;clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了&lt;/p&gt;
&lt;h3 id=&quot;replaceWith-和replaceAll&quot;&gt;&lt;a href=&quot;#replaceWith-和replaceAll&quot; class=&quot;headerlink&quot; title=&quot;replaceWith()和replaceAll()&quot;&gt;&lt;/a&gt;replaceWith()和replaceAll()&lt;/h3&gt;&lt;p&gt;.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合&lt;br&gt;$(“p:eq(1)”).replaceWith(‘&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;‘)&lt;br&gt;$(‘&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;‘).replaceAll(‘p:eq(1)’)&lt;/p&gt;
&lt;h3 id=&quot;包裹wrap-方法&quot;&gt;&lt;a href=&quot;#包裹wrap-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrap()方法&quot;&gt;&lt;/a&gt;包裹wrap()方法&lt;/h3&gt;&lt;p&gt;.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构&lt;br&gt;.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。&lt;/p&gt;
&lt;h3 id=&quot;包裹wrapAll-方法&quot;&gt;&lt;a href=&quot;#包裹wrapAll-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrapAll()方法&quot;&gt;&lt;/a&gt;包裹wrapAll()方法&lt;/h3&gt;&lt;p&gt;.wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构&lt;br&gt;.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。&lt;/p&gt;
&lt;h3 id=&quot;包裹wrapInner-方法&quot;&gt;&lt;a href=&quot;#包裹wrapInner-方法&quot; class=&quot;headerlink&quot; title=&quot;包裹wrapInner()方法&quot;&gt;&lt;/a&gt;包裹wrapInner()方法&lt;/h3&gt;&lt;p&gt;.wrapInner( wrappingElement )：给集合中匹配的元素的内部，增加包裹的HTML结构&lt;/p&gt;
&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;h3 id=&quot;children-方法&quot;&gt;&lt;a href=&quot;#children-方法&quot; class=&quot;headerlink&quot; title=&quot;children()方法&quot;&gt;&lt;/a&gt;children()方法&lt;/h3&gt;&lt;p&gt;代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。&lt;/p&gt;
&lt;h3 id=&quot;find-方法&quot;&gt;&lt;a href=&quot;#find-方法&quot; class=&quot;headerlink&quot; title=&quot;find()方法&quot;&gt;&lt;/a&gt;find()方法&lt;/h3&gt;&lt;p&gt;此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）&lt;/p&gt;
&lt;h3 id=&quot;parent-方法&quot;&gt;&lt;a href=&quot;#parent-方法&quot; class=&quot;headerlink&quot; title=&quot;parent()方法&quot;&gt;&lt;/a&gt;parent()方法&lt;/h3&gt;&lt;p&gt;parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象&lt;/p&gt;
&lt;h3 id=&quot;parents-方法&quot;&gt;&lt;a href=&quot;#parents-方法&quot; class=&quot;headerlink&quot; title=&quot;parents()方法&quot;&gt;&lt;/a&gt;parents()方法&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法&lt;br&gt;其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点&lt;/p&gt;
&lt;h3 id=&quot;closest-方法&quot;&gt;&lt;a href=&quot;#closest-方法&quot; class=&quot;headerlink&quot; title=&quot;closest()方法&quot;&gt;&lt;/a&gt;closest()方法&lt;/h3&gt;&lt;p&gt;从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素&lt;br&gt;起始位置不同：.closest开始于当前元素 .parents开始于父元素&lt;br&gt;遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合&lt;br&gt;结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象&lt;/p&gt;
&lt;h3 id=&quot;next&quot;&gt;&lt;a href=&quot;#next&quot; class=&quot;headerlink&quot; title=&quot;next()&quot;&gt;&lt;/a&gt;next()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法&lt;/p&gt;
&lt;h3 id=&quot;prev-方法&quot;&gt;&lt;a href=&quot;#prev-方法&quot; class=&quot;headerlink&quot; title=&quot;prev()方法&quot;&gt;&lt;/a&gt;prev()方法&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法&lt;/p&gt;
&lt;h3 id=&quot;siblings&quot;&gt;&lt;a href=&quot;#siblings&quot; class=&quot;headerlink&quot; title=&quot;siblings()&quot;&gt;&lt;/a&gt;siblings()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法&lt;/p&gt;
&lt;h3 id=&quot;add&quot;&gt;&lt;a href=&quot;#add&quot; class=&quot;headerlink&quot; title=&quot;add()&quot;&gt;&lt;/a&gt;add()&lt;/h3&gt;&lt;p&gt;jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中&lt;/p&gt;
&lt;h3 id=&quot;each&quot;&gt;&lt;a href=&quot;#each&quot; class=&quot;headerlink&quot; title=&quot;each()&quot;&gt;&lt;/a&gt;each()&lt;/h3&gt;&lt;p&gt;.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://www.imooc.com/article/17456&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.imooc.com/article/17456&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;jquery——dom篇&lt;/p&gt;
    
    </summary>
    
    
      <category term="jquery" scheme="http://blog.newbug.xyz/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包面试题</title>
    <link href="http://blog.newbug.xyz/2017/04/18/JavaScript%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/18/JavaScript闭包面试题/</id>
    <published>2017-04-18T02:52:22.000Z</published>
    <updated>2017-04-18T05:48:15.061Z</updated>
    
    <content type="html">&lt;p&gt;这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;function fun(n, o) {
    console.log(o);
    return {
        fun: function(m){
            return fun(m, n)
        }
    }
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一道很经典的js闭包问题，其中嵌套了三层fun函数：&lt;br&gt;    //答案：&lt;br&gt;    //a: undefined,0,0,0&lt;br&gt;    //b: undefined,0,1,2&lt;br&gt;    //c: undefined,0,1,1&lt;br&gt;首先，在此之前需要了解的是，在JS中函数可以分为两种，具名函数（命名函数）和匿名函数。&lt;/p&gt;
&lt;p&gt;区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数&lt;br&gt;或是采用兼容IE的获取函数name方法来获取函数名称：&lt;br&gt;    /**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    * 获取指定函数的函数名称（用于兼容IE）
    * @param {Function} fun 任意函数
    */
function getFunctionName(fun) {
    if (fun.name !== undefined)
        return fun.name;
    var ret = fun.toString();
    ret = ret.substr(&amp;apos;function &amp;apos;.length);
    ret = ret.substr(0, ret.indexOf(&amp;apos;(&amp;apos;));
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;js有两种创建函数方式，一种是声明函数：&quot;&gt;&lt;a href=&quot;#js有两种创建函数方式，一种是声明函数：&quot; class=&quot;headerlink&quot; title=&quot;　js有两种创建函数方式，一种是声明函数：&quot;&gt;&lt;/a&gt;　js有两种创建函数方式，一种是声明函数：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function fn1(){}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;一种是创建匿名函数表达式：&quot;&gt;&lt;a href=&quot;#一种是创建匿名函数表达式：&quot; class=&quot;headerlink&quot; title=&quot;　一种是创建匿名函数表达式：&quot;&gt;&lt;/a&gt;　一种是创建匿名函数表达式：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var fn1=function (){}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意采用这种方法创建的函数为匿名函数，即没有函数name；&lt;br&gt;var fn1=function (){};&lt;br&gt;getFunctionName(fn1).length;//0&lt;/p&gt;
&lt;h3 id=&quot;创建具名函数表达式：&quot;&gt;&lt;a href=&quot;#创建具名函数表达式：&quot; class=&quot;headerlink&quot; title=&quot;　创建具名函数表达式：&quot;&gt;&lt;/a&gt;　创建具名函数表达式：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var fn1=function xxcanghai(){};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：具名函数表达式的函数名只能在创建函数内部使用&lt;/p&gt;
&lt;p&gt;即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用&lt;/p&gt;
&lt;p&gt;测试：&lt;br&gt;    var fn1=function xxcanghai(){&lt;br&gt;        console.log(“in:fn1&amp;lt;”,typeof fn1,”&amp;gt;xxcanghai:&amp;lt;”,typeof xxcanghai,”&amp;gt;”);&lt;br&gt;    };&lt;br&gt;    console.log(“out:fn1&amp;lt;”,typeof fn1,”&amp;gt;xxcanghai:&amp;lt;”,typeof xxcanghai,”&amp;gt;”);&lt;br&gt;    fn1();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//out:fn1&amp;lt; function &amp;gt;xxcanghai:&amp;lt; undefined &amp;gt;
//in:fn1&amp;lt; function &amp;gt;xxcanghai:&amp;lt; function &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。&lt;/p&gt;
&lt;h3 id=&quot;自执行函数&quot;&gt;&lt;a href=&quot;#自执行函数&quot; class=&quot;headerlink&quot; title=&quot;　自执行函数&quot;&gt;&lt;/a&gt;　自执行函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;(function(){alert(1);})();
(function fn1(){alert(1);})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自执行函数属于上述的“函数表达式”，规则相同&lt;/p&gt;
&lt;h3 id=&quot;其他创建函数的方法&quot;&gt;&lt;a href=&quot;#其他创建函数的方法&quot; class=&quot;headerlink&quot; title=&quot;　其他创建函数的方法&quot;&gt;&lt;/a&gt;　其他创建函数的方法&lt;/h3&gt;&lt;p&gt;当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 eval ， setTimeout ， setInterval 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开&lt;/p&gt;
&lt;p&gt;###　三个fun函数的关系是什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      //...
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。&lt;/p&gt;
&lt;p&gt;这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。&lt;/p&gt;
&lt;p&gt;注意：所有声明的匿名函数都是一个新函数。&lt;/p&gt;
&lt;h3 id=&quot;函数作用域链的问题&quot;&gt;&lt;a href=&quot;#函数作用域链的问题&quot; class=&quot;headerlink&quot; title=&quot;函数作用域链的问题&quot;&gt;&lt;/a&gt;函数作用域链的问题&lt;/h3&gt;&lt;p&gt;再说第三个fun函数之前需要先说下，在函数表达式内部能不能访问存放当前函数的变量&lt;/p&gt;
&lt;p&gt;测试1，对象内部的函数表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var o={
  fn:function (){
    console.log(fn);
  }
};
o.fn();//ERROR报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试2，非对象内部的函数表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fn=function (){
  console.log(fn);
};
fn();//function (){console.log(fn);};正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。&lt;/p&gt;
&lt;p&gt;原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。&lt;/p&gt;
&lt;p&gt;所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。&lt;/p&gt;
&lt;p&gt;所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。&lt;/p&gt;
&lt;h3 id=&quot;到底在调用哪个函数？&quot;&gt;&lt;a href=&quot;#到底在调用哪个函数？&quot; class=&quot;headerlink&quot; title=&quot;到底在调用哪个函数？&quot;&gt;&lt;/a&gt;到底在调用哪个函数？&lt;/h3&gt;&lt;p&gt;再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####　第一行a&lt;/p&gt;
&lt;p&gt;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);&lt;/p&gt;
&lt;p&gt;可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：&lt;/p&gt;
&lt;p&gt;第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0&lt;/p&gt;
&lt;p&gt;第四次同理；&lt;/p&gt;
&lt;p&gt;即：最终答案为undefined,0,0,0&lt;/p&gt;
&lt;h4 id=&quot;第二行b&quot;&gt;&lt;a href=&quot;#第二行b&quot; class=&quot;headerlink&quot; title=&quot;第二行b&quot;&gt;&lt;/a&gt;第二行b&lt;/h4&gt;&lt;p&gt;var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?&lt;/p&gt;
&lt;p&gt;先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用第一层fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；&lt;/p&gt;
&lt;p&gt;第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；&lt;/p&gt;
&lt;p&gt;即最终答案：undefined,0,1,2&lt;/p&gt;
&lt;h4 id=&quot;第三行c&quot;&gt;&lt;a href=&quot;#第三行c&quot; class=&quot;headerlink&quot; title=&quot;第三行c&quot;&gt;&lt;/a&gt;第三行c&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据前面两个例子，可以得知：&lt;/p&gt;
&lt;p&gt;fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。&lt;/p&gt;
&lt;p&gt;遂：&lt;/p&gt;
&lt;p&gt;在第一次调用第一层fun(0)时，o为undefined；&lt;/p&gt;
&lt;p&gt;第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；&lt;/p&gt;
&lt;p&gt;第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；&lt;/p&gt;
&lt;p&gt;第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1&lt;/p&gt;
&lt;p&gt;即最终答案：undefined,0,1,1&lt;/p&gt;
&lt;p&gt;转载：&lt;a href=&quot;http://caibaojian.com/toutiao/5450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://caibaojian.com/toutiao/5450&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端程序员经常忽略的一道js面试题</title>
    <link href="http://blog.newbug.xyz/2017/04/12/%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E9%81%93js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/12/前端程序员经常忽略的一道js面试题/</id>
    <published>2017-04-12T03:02:24.000Z</published>
    <updated>2017-04-13T06:46:31.609Z</updated>
    
    <content type="html">&lt;p&gt;在网上看的这道面试题很经典，就转载过来记录一下，顺便加深自己的印象&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;function Foo() {&lt;br&gt;    getName = function () { alert (1); };&lt;br&gt;    return this;&lt;br&gt;}&lt;br&gt;Foo.getName = function () { alert (2);};&lt;br&gt;Foo.prototype.getName = function () { alert (3);};&lt;br&gt;var getName = function () { alert (4);};&lt;br&gt;function getName() { alert (5);}&lt;/p&gt;
&lt;p&gt;//请写出以下输出结果：&lt;br&gt;Foo.getName();&lt;br&gt;getName();&lt;br&gt;Foo().getName();&lt;br&gt;getName();&lt;br&gt;new Foo.getName();&lt;br&gt;new Foo().getName();&lt;br&gt;new new Foo().getName();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这几道题经常碰见，但是没有好好研究过，今天看了一下，考查的内容确实很多，基本看出了js的综合能力，包含了变量定义提升，this指针指向，运算符优先级，原型，继承，全局变量污染，对象属性以及原型属性优先级等知识。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第一问&quot;&gt;&lt;a href=&quot;#第一问&quot; class=&quot;headerlink&quot; title=&quot;第一问&quot;&gt;&lt;/a&gt;第一问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;先看此题的上半部分说了什么，首先是自定义了一个叫Foo的函数，之后为Foo创建了一个getName的静态属性储存了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个getName函数。

第一问的Foo.getName自然是访问Foo函数上储存的静态属性，答案自然是2，这个很简单，没什么说的，但是我们来复习下基础知识

    function User(name) {
        var name = name ;//私有属性
        this.name = name ;//公有属性
        function getName() {//公有方法
            return name;
        }
    }
    User.prototype.getName = function() {
        return this.name;
    }
    User.name = &amp;apos;Wscats&amp;apos;;//静态属性
    User.getName = function(){//静态方法
        return this.name ;
    }
    var Wscat = new User(&amp;apos;Wscats&amp;apos;);//实例化

注意下面这几点：
    * 调用公有方法，公有属性，我们必须先实例化对象，也就是用new操作符实例化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态属性的
    * 静态方法和静态属性就是我们无需实例化就可以调用
    * 而对象的私有方法和属性，外部是不可以访问的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第二问&quot;&gt;&lt;a href=&quot;#第二问&quot; class=&quot;headerlink&quot; title=&quot;第二问&quot;&gt;&lt;/a&gt;第二问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;直接调用getName函数，就是访问当前尚文作用域内的叫getName的函数，所以这里应该直接把关注点放在4和5上，跟123都没什么关系。此处有两个坑，一是变量生命提升，而是函数表达式和函数声明的区别。
此处可以参考https://github.com/Wscats/Good-text-Share/issues/73

https://github.com/Wscats/Good-text-Share/issues/86

在js中，定义函数有两种类型

### 函数声明
    //函数声明
    function wacat(type){
        return type === &amp;apos;wscat&amp;apos;;
    }

### 函数表达式
    //函数表达式
    var oaoafly = function (type){
        return type ===  &amp;apos;oaoafly&amp;apos;;
    }

    先来看一下下面这个问题，在一个程序里同时用函数声明和函数表达式定义一个名为getName的函数
        getName()//oaoafly
        var getName  = function () {
            console.log(&amp;apos;wscat&amp;apos;)
        }
        getName()//wscat
        function getName(){
            console.log(&amp;apos;oaoafly&amp;apos;)
        }
        getName()//wscat
    #### js解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在后面，也还是会被提升到前面
    #### 而用函数表达式创建的函数在运行时进行赋值，且要等到表达式赋值完成后才能调用

        var getName //变量被提升，此时为undefined

        getName();//oaoafly函数被提升，这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了
        var getName = function () {
            console.log(&amp;apos;wacat&amp;apos;)
        }//函数表达式此时才开始覆盖函数声明的定义
        getName()//wscat
        function getName () {
            console.log(&amp;apos;oaoafly&amp;apos;);
        }
        getName()//wscat 这里就执行了函数表达式的值

    所以可以分解为这两个简单的问题来看清楚区别的本质

        var getName ;
        console.log(getName)//undefined
        getName()//Uncaught TypeError: getName is not a function
        var getName = function () {
            console.log(&amp;apos;wscat&amp;apos;)
        }



        var getName ;
        console.log(getName);//function getName() {console.log(&amp;apos;oaoafly&amp;apos;)}
        getName()//oaoafly
        function getName(){
            console.log(&amp;apos;oaoafly&amp;apos;)
        }
    这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且知名的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机上的差异。
    总结：
        #### js中函数声明和函数表达式是存在区别的，函数声明在js解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪定义，该函数都可以进行调用，而函数表达式的值是在js运行时确定，并且在表达式赋值完成后，该函数才能调用。
        所以第二问的答案就是4，5的函数生命被4的函数表达式覆盖了
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第三问&quot;&gt;&lt;a href=&quot;#第三问&quot; class=&quot;headerlink&quot; title=&quot;第三问&quot;&gt;&lt;/a&gt;第三问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Foo().getName();先执行了Foo函数，然后再调用Foo函数的返回值对象的getName属性函数
Foo函数的第一句getName = function (){alert(1)}是一句函数赋值语句，注意他没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有的话，在想当前函数作用域上层，即外层作用域内寻找是否含有getNAme变量，找到了，也就是第二问种的alert(4)函数,将此变量的值赋值为function(){alert(1)}
此处实际上是将外层作用域内的getName函数修改了。

注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。

之后Foo函数的返回值是this，简单的讲，this的指向室友所在函数的调用方式决定的，而此处的直接调用方式，this指向window对象。所以Foo函数返回的是window对象，相当于执行window.getname(),而window种的getName已经被修改为alert(1),所以最终会输出1

    var name = &amp;apos;wscat&amp;apos;;//全局变量
    window.name = &amp;apos;Wscats&amp;apos;;//全局变量
    function getName () {
        name = &amp;apos;Oaoafly&amp;apos;; //去掉var变成了全局变量
        var privateName = &amp;apos;Stacsw&amp;apos;;
        return function () {
            console.log(this);//window
            return privateName
        }
    }
    var getPrivate = getName(&amp;apos;Hello&amp;apos;);//当然传参是局部变量，但函数里面没有接受这个参数

    console.log(name);//Oaoafly
    console.log(getPrivate());//Stacsw

    因为js没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值得方法会直接或间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真是第一公民呀
    而关于this，this的志向是在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象
    所以第三问中实际上就是window在调用  Foo() 函数，所以this的指向是window

    window.Foo().getName()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第四问&quot;&gt;&lt;a href=&quot;#第四问&quot; class=&quot;headerlink&quot; title=&quot;第四问&quot;&gt;&lt;/a&gt;第四问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;直接调用getName函数，相当于window.getName(),因为这个变量已经被Foo函数执行时修改了，所以结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的拿个getName函数。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第五问&quot;&gt;&lt;a href=&quot;#第五问&quot; class=&quot;headerlink&quot; title=&quot;第五问&quot;&gt;&lt;/a&gt;第五问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;第五问的 new Foo.getName() 此处考查的是js的运算符优先级问题
js运算符的优先级问题，可以参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

这道题首先看优先级的第18和第17都出现关于new的优先级，new(带参数列表)比new(无参数列表)高，跟成员访问同级

new Foo.getName();的优先级是这样的
相当于是：
    new (Foo.getName)();

    * 点的优先级(18)比new无序列表(17)优先级高
    * 当点运算完后又因为有个括号(),此时就是变成new有序列表(18)，所以直接执行new，当然也有可能有朋友会问，为什么遇到()不函数调用在new呢，那是因为函数调用(17)比new有参数列表(18)优先级低
所以这里实际上将getName函数作为了构造函数来执行，所以是2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第六问&quot;&gt;&lt;a href=&quot;#第六问&quot; class=&quot;headerlink&quot; title=&quot;第六问&quot;&gt;&lt;/a&gt;第六问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;这一题比上一题的区别就在Foo那里多了一个括号，这个有括号跟没括号在我们上疑问中就看出来优先级是有区别的

    (new Foo()).getName()

首先new有参数列表(18)跟点的优先级(18)是同级，同级的话按照从左到右的执行顺序，所以先执行new有参数列表(18)在执行点的优先级(18),最后在函数调用(17)
    new有参数列表(18)-&amp;gt;.成员访问(18)-&amp;gt;()函数调用(17)
这里还有一个知识点，Foo作为构造函数有返回值
#### 构造函数的返回值
    在传统语言中， 构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。而在js中构造函数可以有返回值也可以没有。
    1，没有返回值则按照其他语言一样返回实例化对象
        function Foo(name) {
            this.name = name;
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))

    2,若有返回值则检查其返回值是否为引用类型，如果是非引用类型，如基本类型(String.Number.Boolean.Null.Undefined)则于无返回值相同，实际返回其实例化对象

        function Foo(name) {
            this.name = name
            return 520
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))

    3,若返回值是引用类型，则实际返回值为这个引用类型

        function foo(name) {
            this.name = name
            return {
                age:16
            }
        }
        console.log(new Foo(&amp;apos;wscats&amp;apos;))


原题中，由于返回的是this，而在this在构造函数中本来就代表当前实例化对象，最终Foo函数返回实例化对象
之后调用实例化对象的getName函数，因为在Foo构造函数中没有实例化对象添加任何属性，当前对象的原型对象(prototype)中寻找getName函数。
当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认会拿构造函数的公有方法而不是原型链，这个知识点在原题中没有表现出来，后面改进版我已经加上

    function Foo(name) {
        this.name = name ;
        this.getName = function() {
            return this.name
        }
    }
    Foo.prototype.name = &amp;apos;Oaoafly&amp;apos;;
    Foo.prototype.getName = function () {
        return &amp;apos;Oaoafly&amp;apos;
    }
    console.log((new Foo(&amp;apos;Wscats&amp;apos;)).name)//Wscats
    console.log((new Foo(&amp;apos;Wscats&amp;apos;)).getName)//Wscats
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;第七问&quot;&gt;&lt;a href=&quot;#第七问&quot; class=&quot;headerlink&quot; title=&quot;第七问&quot;&gt;&lt;/a&gt;第七问&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;new new Foo().getName(); 同样是运算符优先级问题

实际上问的是 

    new ((new Foo()).getName)()
    new有参数列表(18)-&amp;gt;new有参数列表(18)
先初始化Foo的实例化对象，然后将原型上的getName函数作为构造函数再次new
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##答案&lt;br&gt;        function Foo() {&lt;br&gt;            getName = function () { alert (1); };&lt;br&gt;            return this;&lt;br&gt;        }&lt;br&gt;        Foo.getName = function () { alert (2);};&lt;br&gt;        Foo.prototype.getName = function () { alert (3);};&lt;br&gt;        var getName = function () { alert (4);};&lt;br&gt;        function getName() { alert (5);}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//答案：
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;难度加大，在Foo函数里面加多一个公有方法getName

            function Foo() {
                this.getName = function() {
                    console.log(3);
                    return {
                        getName: getName//这个就是第六问中涉及的构造函数的返回值问题
                    }
                };//这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级
                getName = function() {
                    console.log(1);
                };
                return this
            }
            Foo.getName = function() {
                console.log(2);
            };
            Foo.prototype.getName = function() {
                console.log(6);
            };
            var getName = function() {
                console.log(4);
            };

            function getName() {
                console.log(5);
            } //答案：
            Foo.getName(); //2
            getName(); //4
            console.log(Foo())
            Foo().getName(); //1
            getName(); //1
            new Foo.getName(); //2
            new Foo().getName(); //3
                    //多了一问
            new Foo().getName().getName(); //3 1
            new new Foo().getName(); //3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转载自&lt;a href=&quot;https://github.com/Wscats/Good-text-Share/issues/85&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Wscats/Good-text-Share/issues/85&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看的这道面试题很经典，就转载过来记录一下，顺便加深自己的印象&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>typeof和instanceof</title>
    <link href="http://blog.newbug.xyz/2017/04/11/typeof%E5%92%8Cinstanceof/"/>
    <id>http://blog.newbug.xyz/2017/04/11/typeof和instanceof/</id>
    <published>2017-04-11T07:41:31.000Z</published>
    <updated>2017-04-11T07:49:56.363Z</updated>
    
    <content type="html">&lt;p&gt;JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。但它们之间还是有区别的：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;typeof是一个一元运算，放在一个运算数之前，运算数可以是任意类型。他返回值是一个字符串，该字符串说明运算数的类型，typeof 一般只能返回如下几个结果：
number,boolean,string,function,object,undefined。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;我们可以使用-typeof-来获取一个变量是否存在，如-if-typeof-a-”undefined”-alert-“ok”-，而不要去使用-if-a-因为如果-a-不存在（未声明）则会出错，对于-Array-Null-等特殊对象使用-typeof-一律返回-object，这正是-typeof-的局限性。&quot;&gt;&lt;a href=&quot;#我们可以使用-typeof-来获取一个变量是否存在，如-if-typeof-a-”undefined”-alert-“ok”-，而不要去使用-if-a-因为如果-a-不存在（未声明）则会出错，对于-Array-Null-等特殊对象使用-typeof-一律返回-object，这正是-typeof-的局限性。&quot; class=&quot;headerlink&quot; title=&quot;我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。&quot;&gt;&lt;/a&gt;我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;document.write (&amp;quot;typeof(1): &amp;quot;+typeof(1)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(NaN): &amp;quot;+typeof(NaN)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Number.MIN_VALUE): &amp;quot;+typeof(Number.MIN_VALUE)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Infinity): &amp;quot;+typeof(Infinity)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(\&amp;quot;123\&amp;quot;): &amp;quot;+typeof(&amp;quot;123&amp;quot;)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(true): &amp;quot;+typeof(true)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(window): &amp;quot;+typeof(window)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Array()): &amp;quot;+typeof(new Array())+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(function(){}): &amp;quot;+typeof(function(){})+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(document): &amp;quot;+typeof(document)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(null): &amp;quot;+typeof(null)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(eval): &amp;quot;+typeof(eval)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(Date): &amp;quot;+typeof(Date)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(sss): &amp;quot;+typeof(sss)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
document.write (&amp;quot;typeof(undefined): &amp;quot;+typeof(undefined)+&amp;quot;&amp;lt;br&amp;gt;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;instanceof&quot;&gt;&lt;a href=&quot;#instanceof&quot; class=&quot;headerlink&quot; title=&quot;instanceof&quot;&gt;&lt;/a&gt;instanceof&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;instance：实例,例子
a instanceof b?alert(&amp;quot;true&amp;quot;):alert(&amp;quot;false&amp;quot;); //a是b的实例？真:假
instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array); 会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。再如：function test(){};var a=new test();alert(a instanceof test) 会返回
谈到 instanceof 我们要多插入一个问题，就是 function 的 arguments，我们大家也许都认为 arguments 是一个 Array，但如果使用 instaceof 去测试会发现 arguments 不是一个 Array 对象，尽管看起来很像。
另外：
测试 var a=new Array();if (a instanceof Object) alert(&amp;apos;Y&amp;apos;);else alert(&amp;apos;N&amp;apos;);
得&amp;apos;Y’
但 if (window instanceof Object) alert(&amp;apos;Y&amp;apos;);else alert(&amp;apos;N&amp;apos;);
得&amp;apos;N&amp;apos;
所以，这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。
使用 typeof 会有些区别
alert(typeof(window)) 会得 object
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。但它们之间还是有区别的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js复习重点</title>
    <link href="http://blog.newbug.xyz/2017/04/11/js%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.newbug.xyz/2017/04/11/js复习重点/</id>
    <published>2017-04-11T03:30:42.000Z</published>
    <updated>2017-04-11T03:31:21.579Z</updated>
    
    <content type="html">&lt;p&gt;1.闭包的概念及其应用&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;2.原型链/继承，构造对象的方法&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.oyanglul.us/javascript/understand-prototype.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.oyanglul.us/javascript/understand-prototype.html&lt;/a&gt;&lt;br&gt;这一部分 js高级程序设计上面讲的挺好的&lt;/p&gt;
&lt;p&gt;3.bom/dom(重点是dom)&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000654274（这个说的挺详细）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/a/1190000000654274（这个说的挺详细）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.itxueyuan.org/view/6299.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.itxueyuan.org/view/6299.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.NET/xiao__gui/article/details/8315148&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.NET/xiao__gui/article/details/8315148&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.获取元素的方法，queryselector()（get—byid，byclassname。。。。。）&lt;br&gt;&lt;a href=&quot;http://blog.csdn.Net/mydeman/article/details/2078107&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.Net/mydeman/article/details/2078107&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.nodelist和array&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/jeffwongishandsome/archive/2010/07/07/1773144.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/jeffwongishandsome/archive/2010/07/07/1773144.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.数组的常规操作&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/ahthw/p/4279642.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/ahthw/p/4279642.html&lt;/a&gt;&lt;br&gt;熟悉一下一下基本的算法，排序，逆置什么的。&lt;br&gt;7.apply/call&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html&lt;/a&gt;&lt;br&gt;call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过：var domNodes =  Array.prototype.slice.call(document.getElementsByTagName(“*”));这样domNodes就可以应用Array下的所有方法了。&lt;br&gt;8.string对象的操作&lt;br&gt;&lt;a href=&quot;http://itbilu.com/javascript/js/EymJA6WY.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://itbilu.com/javascript/js/EymJA6WY.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9.五种基本类型（数字，字符串，undefined，null，boolearn）以及复合类型（array，object，function），他们二者的判别方法&lt;br&gt;&lt;a href=&quot;http://www.xiabingbao.com/javascript/2015/07/04/javascript-type/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.xiabingbao.com/javascript/2015/07/04/javascript-type/&lt;/a&gt;&lt;br&gt;10.事件流（冒泡，捕获）&lt;br&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000003497939&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://segmentfault.com/a/1190000003497939&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11.事件的添加，删除&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/jaylongli/article/details/4038042&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/jaylongli/article/details/4038042&lt;/a&gt;&lt;br&gt;结合事件流选择合适的元素进行事件添加可以适当的优化性能，也就是事件委托&lt;/p&gt;
&lt;p&gt;12.事件委托&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html&lt;/a&gt;&lt;br&gt;13.this&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14.new&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/hy6688_/article/details/22453043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/hy6688_/article/details/22453043&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;15.js跨域&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html&lt;/a&gt;&lt;br&gt;js的类库看一下jQuery，有时间浏览一下源码，$符的实现原理&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1.闭包的概念及其应用&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot;&gt;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript初级试题</title>
    <link href="http://blog.newbug.xyz/2017/04/10/JavaScript%E5%88%9D%E7%BA%A7%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/04/10/JavaScript初级试题/</id>
    <published>2017-04-10T02:27:55.000Z</published>
    <updated>2017-04-11T02:44:34.794Z</updated>
    
    <content type="html">&lt;p&gt;今天在网上看了几个初级的试题，没想到竟然后好几个不确定答案的，所以就在此记录下&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;1,输出下面的值&lt;br&gt;        var a = 10, b = 20, c = (a++,b++,100);&lt;br&gt;        console.log(c);&lt;br&gt;运算符的优先级，这里的运算符逗号是多重求值，不论多少个逗号，都是返回最后一个逗号后面的值&lt;br&gt;2,判断是否为质数&lt;br&gt;        function isZhuShu(m){&lt;br&gt;            if( m &amp;lt;= 1 || m%1 !== 0){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            var n = 2;&lt;br&gt;            while(n&amp;lt;m){&lt;br&gt;                if(m%n==0){&lt;br&gt;                    return false;&lt;br&gt;                }else{&lt;br&gt;                    n++;&lt;br&gt;                    continue;&lt;br&gt;                }&lt;br&gt;            }&lt;br&gt;            return true&lt;br&gt;        }&lt;br&gt;下面的是优化算法：&lt;br&gt;        function isPrime(number){&lt;br&gt;            if (typeof number !== ‘number’ || number &amp;lt; 2){&lt;br&gt;                //不是数字或者字数小于2&lt;br&gt;                return false;&lt;br&gt;            }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if (number === 2){
        //2是质数
        return true 
    } else if (number % 2 === 0){
        //排除偶数
        return true
    } 
    var squareRoot = Math.sqrt(number);
    for(var i = 3; i &amp;lt;= squareRoot; i+=2){
        //因为2已经验证过，所以从三开始，且已经排除偶数，所以每次加2
        if(number % i === 0){
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3,获取斐波那契数列的第n个值，如果n不是有限的数字，则返回undefined&lt;br&gt;        function getFBN(n){&lt;br&gt;            if(typeof n !== ‘number’){&lt;br&gt;                return&lt;br&gt;            }&lt;br&gt;            if(n &amp;lt; 0){&lt;br&gt;                return 1&lt;br&gt;            }&lt;br&gt;            else if (n &amp;lt;= 2){&lt;br&gt;                return 2&lt;br&gt;            }&lt;br&gt;            return getFBN(n-1) + getFBN(n-2);&lt;br&gt;        }&lt;br&gt;        console.log(getFBN(3))&lt;br&gt;4,计算从10到100中能被3或者5整除的数的和&lt;br&gt;        function getSum(){&lt;br&gt;            var sum = 0;&lt;br&gt;            for(var i = 10;i&amp;lt;=100;i++){&lt;br&gt;                sum += (i%3 === 0 || i%5 === 0) &amp;amp;&amp;amp; i&lt;br&gt;            }&lt;br&gt;            return sum&lt;br&gt;        }&lt;br&gt;        console.log(getSum)&lt;br&gt;5,将传入的字符串翻转输出，如果不是字符串输出undefined&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getReverse(str){
    var result = &amp;apos;&amp;apos;;
    if(typeof str !== &amp;apos;string&amp;apos;){
        return 
    }
    for(var len = str.length,i=len-1;i&amp;gt;=0;i--){
        result += str[i]
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是简便的方法&lt;br&gt;        function getReverse(str){&lt;br&gt;            if(typeof str !== ‘string’){&lt;br&gt;                return null&lt;br&gt;            }&lt;br&gt;            return str.split(‘’).reverse().join(‘’)&lt;br&gt;        }&lt;/p&gt;
&lt;p&gt;6,写一个函数，来实现判断一个字符串是否为回文（忽略大小写）&lt;br&gt;        function isHuiWen(str){&lt;br&gt;            if(typeof str !== ‘string’ || str.constructor !== String){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            for(var i = 0,len=(str.length+1)/2;i&amp;lt;len;i++){&lt;br&gt;                if(str[i] !== str[str.length-i-1]){&lt;br&gt;                    return false;&lt;br&gt;                }&lt;br&gt;            }&lt;br&gt;        }&lt;/p&gt;
&lt;p&gt;7,去除字符串中重复的字符&lt;br&gt;        function getNoRepeat(str){&lt;br&gt;            var tempObj = {},result = ‘’;&lt;br&gt;            if(typeof str !== ‘string’ || str.constructor !== String){&lt;br&gt;                return false;&lt;br&gt;            }&lt;br&gt;            for(var i = 0,len =str.length;i&lt;len;i++){ 1=&quot;&quot; if(!tempobj[str[i]]){=&quot;&quot; result=&quot;&quot; +=&quot;str[i];&quot; tempobj[str[i]]=&quot;true&quot; }=&quot;&quot; return=&quot;&quot; 8,=&quot;&quot; 输出1000内水仙花数水仙花数是指一个=&quot;&quot; n=&quot;&quot; 位数=&quot;&quot; (=&quot;&quot; n≥3=&quot;&quot; )，它的每个位上的数字的=&quot;&quot; 次幂之和等于它本身。（例如：1^3=&quot;&quot; 5^3+=&quot;&quot; 3^3=&quot;153）三位的水仙花数共有4个：153，370，371，407&quot; 先封装一个简易版的math.pow封装=&quot;&quot; function=&quot;&quot; pospow(n,x){=&quot;&quot; var=&quot;&quot; if(x=&quot;==0){&quot; &lt;=&quot;&quot; 0){=&quot;&quot; 只运算乘方=&quot;&quot; null=&quot;&quot; while(x=&quot;&quot;&gt;1){&lt;br&gt;                result = result*n;&lt;br&gt;                x–;&lt;br&gt;            }&lt;br&gt;            return result;&lt;br&gt;        }&lt;/len;i++){&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//最终函数
    function narc(max){
        var resultList = [],
            maxDigit=3, //max的位数
            tempResult=0;
        if(max &amp;lt;= 100){
            return null;
        }else if(typeof max !== &amp;apos;number&amp;apos;){
            return null
        }
        //取得max的位数
        maxDigit = max.toString().length+1;

        //第一层对于位数进行循环，从3位开始
        for(var digit = 3; digit &amp;lt;= maxDigit; digit++){
            //第二层循环从 0到 Max
            for(var i = 100; i &amp;lt; max; i++){
                tempResult = 0;
                //第三层循环，从i的第0位到最后一位
                for(var j=0;j&amp;lt;digit-1; j++){
                    tempResult += posPow(i.toString()[j], digit-1)
                }
                (tempResult === i) &amp;amp;&amp;amp; (resultList[resultList.length]  = i)
            }
        }

        return resultList;
    }

    console.log(narc(1000))
    console.log(narc(10000))
    console.log(narc(8209))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9,以下js代码会输出什么&lt;br&gt;        console.log(1 + “2” + “2”);//122&lt;br&gt;        console.log(1 +  + “2” + “2”);//32  空格加字符串变成数字，隐式转换&lt;br&gt;        console.log(+ “1” + “1” + “2”);//112&lt;br&gt;        console.log( “A” - “B” + “2”);//NAN2   “A” - “B” 会返回 NaN，因为 “A” 和 “B” 无法转成数字进行运算，这里不要以为 “A” 和 “B” 能转为 ASCII码 进行运算（这个和C语言是不同的，不要搞乱了）。而 NaN 和字符串相加，会转成 “NaN” 和字符串去拼接，所以，倒数第二问是 NAN+”2”,为 NAN2，NaN 和任何数字相加结果还是 NaN。&lt;br&gt;        console.log( “A” - “B” + 2 ); //NAN&lt;/p&gt;
&lt;p&gt;10,以下js输出结果为&lt;br&gt;        var length = 10;&lt;br&gt;        function fn(){&lt;br&gt;            alert(this.length);&lt;br&gt;        }&lt;br&gt;        var obj = {&lt;br&gt;            length: 5,&lt;br&gt;            method: function(fn){&lt;br&gt;                fn();&lt;br&gt;                arguments&lt;a href=&quot;&quot;&gt;0&lt;/a&gt;;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;        obj.method(fn);&lt;/p&gt;
&lt;p&gt;这个主要是考arguments，对象属于除了点操作符还可以用中括号，这里fn的scope是arguments，即fn内的this===arguments，调用时仅传了一个参数fn，因此length为1。&lt;/p&gt;
&lt;p&gt;11，&lt;br&gt;        var a = 1;&lt;br&gt;        function func(){&lt;br&gt;            a = b = 2;&lt;br&gt;        }&lt;br&gt;        func();&lt;br&gt;        alert(a); //2&lt;br&gt;        alert(b); //2&lt;br&gt;js中不用var声明的变量默认是全局变量，所以b是全聚德，所以func是可以对外进行访问的&lt;/p&gt;
&lt;p&gt;12，简述readyonly与disabled的区别&lt;br&gt;   1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。&lt;br&gt;   2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网上看了几个初级的试题，没想到竟然后好几个不确定答案的，所以就在此记录下&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html5常见的面试题</title>
    <link href="http://blog.newbug.xyz/2017/02/11/html5%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.newbug.xyz/2017/02/11/html5常见的面试题/</id>
    <published>2017-02-11T05:31:48.000Z</published>
    <updated>2017-04-21T02:18:03.769Z</updated>
    
    <content type="html">&lt;p&gt;市场总结，提高自己&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1,常见的块级元素，内联元素&lt;br&gt;        fieldset - 表单字段集&lt;br&gt;        colgroup - 表单列分组元素&lt;br&gt;        pre 格式化文本&lt;br&gt;        i - 斜体&lt;br&gt;        em - 强调&lt;br&gt;        label - 表单标签&lt;br&gt;        sub - 下标&lt;br&gt;        sup - 上标&lt;br&gt;        u - 下划线&lt;br&gt;2，实现文本三个点的几个条件&lt;br&gt;    text-overflow属性仅是：当文本溢出时是否显示省略标记，并不具备其他的样式属性定义，要实现溢出时产生省略号的效果还需定义：&lt;br&gt;    1，容器宽度： width&lt;br&gt;    2，强制文本在一行内显示： white-space：nowrap&lt;br&gt;    3，溢出内容为隐藏：overflow：hidden；&lt;br&gt;    4，溢出文本显示省略号：text-overflow：ellipsis&lt;br&gt;    但行文本才可以设置文本溢出&lt;br&gt;3，垂直居中的几个条件&lt;br&gt;    设置一个元素在一个容器内垂直居中，必须更改默认的display属性值为inline-block&lt;br&gt;    并加上统计元素（标尺）（同级元素[标尺]样式设置为vertical-align:middle；width：0；height：100%；display：inline-block；）&lt;br&gt;    三个条件：&lt;br&gt;        1，必须给容器加上text-align:center；&lt;br&gt;        2，必须给当前元素转化为内块元素（display：inline-block)再给当前元素加上vertical-align:middle&lt;br&gt;        3，在当前元素的后面加上同级元素span进行vertical-align:middle；width：0；height：100%；display：inline-block；&lt;br&gt;4，图片精灵，优势&lt;br&gt;    图片整合，将小的单张背景图片整合到一张大的背景图片上&lt;br&gt;    优势：1）通过图片来整合减少对服务器的请求次数，从而提高页面的加载速度。2）通过整合图片来减少图片的体积&lt;br&gt;5，display:none与visibility:hidden的区别&lt;/p&gt;
&lt;p&gt;前者：隐藏不占位  后者：隐藏但是占位置&lt;br&gt;6，清除浮动的几种方式&lt;/p&gt;
&lt;p&gt;hack1：给父元素添加声明overflow:hidden;&lt;/p&gt;
&lt;p&gt;hack2:   给父元素加height&lt;/p&gt;
&lt;p&gt;hack3:   在浮动元素下方添加空div,并给该元素添加         声明：div{clear:both; height:0; overflow:hidden;}&lt;/p&gt;
&lt;p&gt;hack4:万能清除浮动法 p:after{content:“.”;clear:both;display:block;height:0;overflow:hidden;  visibility:hidden;}&lt;br&gt;7，哪些属性可以继承？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）文字相关：font-family、font-size、font-style、font-variant、font-weight、font、letter-spacing、line-height、text-align、text-indent、text-transform、word-spacing
2）列表相关：list-style-image、list-style-position、list-style-type、list-style
3）颜色相关：color
4）透明度（子元素会继承祖元素的opacity，但是无法更改）
注：font-size继承的是父元素的大小，而不是比例。line-height当父元素是百分比或px值得时候，子元素跟父元素相同，当父元素是normal或数字的时候，子元素的line-height是子元素的字体大小乘以数字。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8，link和@import区别？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。

2、link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了

3、加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）

4、兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题

5、使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9，定位的属性值都有哪些？每个值得意思？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;各属性值的作用：

static：默认值。位置设置为 static 的元素会正常显示，它始终会处于文档流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。

absolute：相对于父级元素的绝对定位，s浮出、脱离布局流，它不占据空间，就是我们所说的层，其位置相对于最近的已定位父元素而言的位置，可直接指定 “left”、“top”、“right” 以及 “bottom” 属性。若父级都没有定位，则以html（根元素）。(层叠的顺序z-index:value)

relative：是相对于默认位置的偏移定位，通过设置left、top、right、bottom值可将其移至相对于其正常位置的地方（相对于自己的开始的位置发生的位置上的移动，【不会破坏正常的布局流】

fixed：相对浏览器的绝对定位，是相对于浏览器窗口的指定坐标进行定位。此元素的位置可通过 &amp;quot;left&amp;quot;、&amp;quot;top&amp;quot;、&amp;quot;right&amp;quot; 以及&amp;quot;bottom&amp;quot; 属性来规定。不论窗口滚动与否，元素都会留在那个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10，写出html5新增的标签15个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;header nav footer main aside article section figure datalist video audio fieldest  legend  label caption
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11，实现垂直+水平居中有哪些方法？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、div{width:200px;height:200px;background:#f00;position:fixed;left:0;right:0;top:0;bottom:0;margin:auto;}

2、div{width:200px;height:200px;background:#f00;position:fixed;left:50%;top:50%;margin:-100px 0 0 -100px;}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;市场总结，提高自己&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图片预加载</title>
    <link href="http://blog.newbug.xyz/2016/11/16/%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.newbug.xyz/2016/11/16/图片预加载/</id>
    <published>2016-11-16T12:26:28.000Z</published>
    <updated>2016-11-16T12:30:14.000Z</updated>
    
    <content type="html">&lt;p&gt;预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方法一：用CSS和JavaScript实现预加载&lt;/p&gt;
&lt;p&gt;实现预加载图片有很多方法，包括使用CSS、JavaScript及两者的各种组合。这些技术可根据不同设计场景设计出相应的解决方案，十分高效。&lt;/p&gt;
&lt;p&gt;单纯使用CSS，可容易、高效地预加载图片，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#preload-01 { background: url(-01.png) no-repeat -9999px -9999px; }

#preload-02 { background: url(-02.png) no-repeat -9999px -9999px; }

#preload-03 { background: url(-03.png) no-repeat -9999px -9999px; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。&lt;/p&gt;
&lt;p&gt;该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：&lt;br&gt;    // better image preloading @ &amp;lt;a href=”;&amp;gt;;/a&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function preloader() {

if (document.getElementById) {

    document.getElementById(&amp;quot;preload-01&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

    document.getElementById(&amp;quot;preload-02&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

    document.getElementById(&amp;quot;preload-03&amp;quot;).style.background = &amp;quot;url() no-repeat -9999px -9999px&amp;quot;;

}

}

function addLoadEvent(func) {

var oldonload = window.onload;

if (typeof window.onload != &amp;apos;function&amp;apos;) {

    window.onload = func;

} else {

    window.onload = function() {

        if (oldonload) {

            oldonload();

        }

        func();

    }

}

}

addLoadEvent(preloader);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。&lt;/p&gt;
&lt;p&gt;该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。&lt;/p&gt;
&lt;p&gt;如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。&lt;/p&gt;
&lt;p&gt;方法二：仅使用JavaScript实现预加载&lt;/p&gt;
&lt;p&gt;上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。&lt;/p&gt;
&lt;p&gt;JavaScript代码段1&lt;/p&gt;
&lt;p&gt;只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：&lt;br&gt;    &lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

    &amp;lt;!--//--&amp;gt;&amp;lt;![CDATA[//&amp;gt;&amp;lt;!--

        var images = new Array()

        function preload() {

            for (i = 0; i &amp;lt; preload.arguments.length; i++) {

                images[i] = new Image()

                images[i].src = preload.arguments[i]
            }

        }

        preload(

            &amp;quot;;,

            &amp;quot;;,

            &amp;quot;;

        )

    //--&amp;gt;&amp;lt;!]]&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。 &lt;/p&gt;
&lt;p&gt;JavaScript代码段2&lt;/p&gt;
&lt;p&gt;该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;hidden&amp;quot;&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

    &amp;lt;!--//--&amp;gt;&amp;lt;![CDATA[//&amp;gt;&amp;lt;!--

        if (document.images) {

            img1 = new Image();

            img2 = new Image();

            img3 = new Image();

            img1.src = &amp;quot;;;

            img2.src = &amp;quot;;;

            img3.src = &amp;quot;;;

        }

    //--&amp;gt;&amp;lt;!]]&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。&lt;/p&gt;
&lt;p&gt;我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function preloader() {

if (document.images) {

    var img1 = new Image();

    var img2 = new Image();

    var img3 = new Image();

    img1.src = &amp;quot;;;

    img2.src = &amp;quot;;;

    img3.src = &amp;quot;;;

}

}

function addLoadEvent(func) {

var oldonload = window.onload;

if (typeof window.onload != &amp;apos;function&amp;apos;) {

    window.onload = func;

} else {

    window.onload = function() {

        if (oldonload) {

            oldonload();

        }

        func();

    }

}

}

addLoadEvent(preloader);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法三：使用Ajax实现预加载&lt;/p&gt;
&lt;p&gt;上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。&lt;br&gt;    window.onload = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {

    // XHR to request a JS and a CSS

    var xhr = new XMLHttpRequest();

    xhr.open(&amp;apos;GET&amp;apos;, &amp;apos;;);

    xhr.send(&amp;apos;&amp;apos;);

    xhr = new XMLHttpRequest();

    xhr.open(&amp;apos;GET&amp;apos;, &amp;apos;;);

    xhr.send(&amp;apos;&amp;apos;);

    // preload image

    new Image().src = &amp;quot;;;

}, 1000);

};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。&lt;/p&gt;
&lt;p&gt;下面，我们看看如何用JavaScript来实现该加载过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onload = function() {



setTimeout(function() {



    // reference to &amp;lt;head&amp;gt;

    var head = document.getElementsByTagName(&amp;apos;head&amp;apos;)[0];



    // a new CSS

    var css = document.createElement(&amp;apos;link&amp;apos;);

    css.type = &amp;quot;text/css&amp;quot;;

    css.rel  = &amp;quot;stylesheet&amp;quot;;

    css.href = &amp;quot;;;



    // a new JS

    var js  = document.createElement(&amp;quot;script&amp;quot;);

    js.type = &amp;quot;text/javascript&amp;quot;;

    js.src  = &amp;quot;;;



    // preload JS and CSS

    head.appendChild(css);

    head.appendChild(js);



    // preload image

    new Image().src = &amp;quot;;;



}, 1000);



};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，我们通过DOM创建三个元素来实现三个文件的预加载。正如上面提到的那样，使用Ajax，加载文件不会应用到加载页面上。从这点上看，Ajax方法优越于JavaScript。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="http://blog.newbug.xyz/2016/11/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.newbug.xyz/2016/11/10/面试总结/</id>
    <published>2016-11-10T12:49:23.000Z</published>
    <updated>2016-11-16T12:38:58.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;a href=&quot;#用js写一个函数计算出字符串的长度&quot; class=&quot;headerlink&quot; title=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;/a&gt;用js写一个函数计算出字符串的长度&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;GBK字符集实际长度计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getStrLeng(str) {
    var realLength = 0;
    var len = str.length;
    var charCode = -1;
    for (var i = 0; i &amp;lt; len; i++) {
        charCode = str.charCodeAt(i);
        if (charCode &amp;gt;= 0 &amp;amp;&amp;amp; charCode &amp;lt;= 128) {
            realLength += 1;
        }else{
            //如果是中文则长度加2；
            realLength += 2;
        }
    }
    return realLength;
}
console.log(getStrLeng(&amp;apos;ahaak522中文&amp;apos;));//12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;utf8字符集实际长度计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//utf8 字符集实际长度计算
function getStrLeng(str) {
    var realLength = 0;
    var len = str.length;
    var charCode = -1;
    for(var i = 0; i &amp;lt; len; i++){
        charCode = str.charCodeAt(i);
        if (charCode &amp;gt;= 0 &amp;amp;&amp;amp; charCode &amp;lt;= 128) { 
            realLength += 1;
        }else{ 
            // 如果是中文则长度加3
            realLength += 3;
        }
    } 
    return realLength;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在JS中字符串的长度不分中英文字符， 每一个字符都算一个长度，这跟PHP里的strlen()函数就不太一样。PHP里的strlen()函数根据字符集把GBK的中文每个2累加，把UTF-8的中文字符每个按3累加。主要是为了匹配数据库的长度范围内，比如GBK的数据库某字段是varchar(10)，那么就相当于5个汉字长度，一个汉字等于两个字母长度。如果是UTF8的数据库则是每个汉字长度为3    &lt;/p&gt;
&lt;h3 id=&quot;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和HTML5？&quot;&gt;&lt;a href=&quot;#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和HTML5？&quot; class=&quot;headerlink&quot; title=&quot;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？&quot;&gt;&lt;/a&gt;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？&lt;/h3&gt;&lt;p&gt;HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。  &lt;/p&gt;
&lt;p&gt;绘画 canvas  &lt;/p&gt;
&lt;p&gt;用于媒介回放的 video 和 audio 元素  &lt;/p&gt;
&lt;p&gt;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；&lt;br&gt;sessionStorage 的数据在浏览器关闭后自动删除 &lt;/p&gt;
&lt;p&gt;语意化更好的内容元素，比如 article、footer、header、nav、section  &lt;/p&gt;
&lt;p&gt;表单控件，calendar、date、time、email、url、search  &lt;/p&gt;
&lt;p&gt;新的技术webworker, websockt, Geolocation  &lt;/p&gt;
&lt;p&gt;移除的元素  &lt;/p&gt;
&lt;p&gt;纯表现的元素：basefont，big，center，font, s，strike，tt，u；  &lt;/p&gt;
&lt;p&gt;对可用性产生负面影响的元素：frame，frameset，noframes；  &lt;/p&gt;
&lt;p&gt;支持HTML5新标签：  &lt;/p&gt;
&lt;p&gt;IE8/IE7/IE6支持通过document.createElement方法产生的标签，&lt;br&gt;可以利用这一特性让这些浏览器支持HTML5新标签，&lt;br&gt;浏览器支持新标签后，还需要添加标签默认的样式&lt;/p&gt;
&lt;h3 id=&quot;请描述一下-cookies，sessionStorage-和-localStorage-的区别？&quot;&gt;&lt;a href=&quot;#请描述一下-cookies，sessionStorage-和-localStorage-的区别？&quot; class=&quot;headerlink&quot; title=&quot;请描述一下 cookies，sessionStorage 和 localStorage 的区别？&quot;&gt;&lt;/a&gt;请描述一下 cookies，sessionStorage 和 localStorage 的区别？&lt;/h3&gt;&lt;p&gt;cookies在浏览器之间来回传递，sessionStorage和localStorage不会，&lt;br&gt;sessionStorage和localStorage储存空间更大，有更多丰富易用的接口，有各自独立存储的空间，  &lt;/p&gt;
&lt;h3 id=&quot;如何实现浏览器内多个标签页之间的通信&quot;&gt;&lt;a href=&quot;#如何实现浏览器内多个标签页之间的通信&quot; class=&quot;headerlink&quot; title=&quot;如何实现浏览器内多个标签页之间的通信?&quot;&gt;&lt;/a&gt;如何实现浏览器内多个标签页之间的通信?&lt;/h3&gt;&lt;p&gt;调用localstorge、cookies等本地存储方式  &lt;/p&gt;
&lt;h3 id=&quot;添加-删除-替换-插入到某个接点的方法&quot;&gt;&lt;a href=&quot;#添加-删除-替换-插入到某个接点的方法&quot; class=&quot;headerlink&quot; title=&quot;添加 删除 替换 插入到某个接点的方法&quot;&gt;&lt;/a&gt;添加 删除 替换 插入到某个接点的方法&lt;/h3&gt;&lt;p&gt;obj.appendChidl()  &lt;/p&gt;
&lt;p&gt;obj.innersetBefore  &lt;/p&gt;
&lt;p&gt;obj.replaceChild  &lt;/p&gt;
&lt;p&gt;obj.removeChild  &lt;/p&gt;
&lt;h3 id=&quot;说一下什么是javascript的同源策略？&quot;&gt;&lt;a href=&quot;#说一下什么是javascript的同源策略？&quot; class=&quot;headerlink&quot; title=&quot;说一下什么是javascript的同源策略？&quot;&gt;&lt;/a&gt;说一下什么是javascript的同源策略？&lt;/h3&gt;&lt;p&gt;一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合  &lt;/p&gt;
&lt;h3 id=&quot;编写一个b继承a的方法&quot;&gt;&lt;a href=&quot;#编写一个b继承a的方法&quot; class=&quot;headerlink&quot; title=&quot;编写一个b继承a的方法;&quot;&gt;&lt;/a&gt;编写一个b继承a的方法;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function A(name){
    this.name = name;
    this.sayHello = function(){alert(this.name+” say Hello!”);};
}
function B(name,id){
    this.temp = A;
    this.temp(name);        //相当于new A();
    delete this.temp;       
     this.id = id;   
    this.checkId = function(ID){alert(this.id==ID)};
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;面试常见题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 小球从一百米落下，每次弹起的高度是上一次的一半，求第十次
var s = 100 ;
var hight = 100 ;
for (var i = 2; i &amp;lt; 11; i++) {
    hight /= 2;
    s = s + hight;
}
console.log(hight + &amp;apos; + &amp;apos; + s );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;call和apply的区别  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//     // call的定义
//     function add(a,b){
//         console.log(a+b);
//     }
//     function reduce(a,b) {
//         console.log(a-b);
//     }
//     add.call(reduce,3,4);//将add方法运用到reduce,结果为4
//     // call可以改变this的指向
//     function b() {
//         console.log(this);
//     }
//     b();//window
//     b.call();//window
//     b.call(&amp;apos;a&amp;apos;,2,3);//a
//     // 下面看一个复杂点的例子
//     function Animal() {
//         this.name = &amp;apos;animal&amp;apos;;
//         this.showName = function () {
//             console.log(this.name);
//         }
//     }
//     function Cat() {
//         this.name = &amp;apos;cat&amp;apos;;
//     }
//     var animal = new Animal();
//     var cat = new Cat();
//     animal.showName();//结果为animal
//     animal.showName.call(cat);//原本cat没有showName方法，但是通过call方法将animal的showName方法应用到cat上,因此结果为cat

    // 实现继承:
    function Animal(name) {
        this.name = name ;
        this.showName = function(){
            console.log(this.name);
        }
    }
    function Cat(name) {
        Animal.call(this,name);//将Animal应用到Cat上，因此Cat拥有了Animal的所有属性和方法
    }
    var cat = new Cat(&amp;apos;Black Cat&amp;apos;);
    cat.showName();//浏览器弹出Black Cat
    // 区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改input里面的颜色   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;color&amp;quot; placeholder=&amp;quot;你好，我会变颜色&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;nihao ,hahah &amp;quot;&amp;gt;


&amp;lt;p class=&amp;quot;weilei&amp;quot;&amp;gt;我是p&amp;lt;/p&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;css：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input::-webkit-input-placeholder {
        color: red;
}  

input::-moz-placeholder {
    color: red;
}
input:-ms-input-placeholder {
    color: red;
}
input::placeholder {
    color: red;
}
input.color::-webkit-input-placeholder {
    color: yellow;
}
/*.weilei:before {
    content: &amp;apos;我是p前面的东西&amp;apos;;
    color: blue;
}
.weilei:after {
    content: &amp;apos; http://www.baidu.com&amp;apos;;
}
.weilei {
    color: red;
}*/
/*p:before{   
    content:&amp;apos;网站名:&amp;apos;;
}   
p:after{   
    content:&amp;apos;\21E0&amp;apos;;
}*/  
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;a href=&quot;#用js写一个函数计算出字符串的长度&quot; class=&quot;headerlink&quot; title=&quot;用js写一个函数计算出字符串的长度&quot;&gt;&lt;/a&gt;用js写一个函数计算出字符串的长度&lt;/h3&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.newbug.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ajax前后端交互教程</title>
    <link href="http://blog.newbug.xyz/2016/09/21/ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.newbug.xyz/2016/09/21/ajax前后端交互教程/</id>
    <published>2016-09-21T07:52:06.000Z</published>
    <updated>2017-04-21T08:18:07.983Z</updated>
    
    <content type="html">&lt;p&gt;一直都是写的前端，没关心过后端是怎么处理的，看个小案例，了解下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;直接上代码，制作个登录框，用来输入账号密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;login&amp;quot;&amp;gt;
    &amp;lt;p class=&amp;quot;loginTitle&amp;quot;&amp;gt;登录&amp;lt;/p&amp;gt;
    &amp;lt;span class=&amp;quot;loginSpan&amp;quot;&amp;gt;账号
        &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userName&amp;quot; value=&amp;quot;输入你的账号&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;//装一个√或×，提示是否输入正确
        &amp;lt;br&amp;gt;
        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;br&amp;gt; //账号是否正确输入的状态字
        &amp;lt;img src=&amp;quot;&amp;quot; class=&amp;quot;xbtn&amp;quot;&amp;gt;
        密码
        &amp;lt;input type=&amp;quot;password&amp;quot; id=&amp;quot;password&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;br&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;登录&amp;quot;&amp;gt;
    &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是登录框html，下面js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.ajax({
    &amp;apos;type&amp;apos;: post,
    &amp;apos;url&amp;apos;: &amp;apos;login.php&amp;apos;,
    &amp;apos;dataType&amp;apos;: json,
    &amp;apos;data&amp;apos;: {
        &amp;quot;username&amp;quot;: $(&amp;apos;#userName&amp;apos;).val(),
        &amp;quot;password&amp;quot;: $(&amp;apos;#password&amp;apos;).val()
    },
    &amp;apos;success&amp;apos;: function(data){
        switch(data.type){
            case 0 : alert(&amp;apos;账户不存在&amp;apos;);break;
            case 1 : {
                $(&amp;apos;#userMsg&amp;apos;).children(&amp;apos;li&amp;apos;).eq(2).find(&amp;apos;span&amp;apos;).html(&amp;apos; &amp;apos;+data.gouwuchenum+&amp;apos; &amp;apos;); 
                $(&amp;apos;#loginMsg li&amp;apos;).eq(1).empty().html(&amp;apos;&amp;lt;span&amp;gt;&amp;apos;+data.name+&amp;apos;&amp;lt;/span&amp;gt;&amp;apos;); 
                $(&amp;apos;#loginMsg li&amp;apos;).eq(2).empty().html(&amp;apos;&amp;lt;a href=&amp;quot;javascript:tuichu()&amp;quot;&amp;gt;退出&amp;lt;/a&amp;gt;&amp;apos;);
                $(&amp;apos;.login&amp;apos;).animate({right:-180,opacity:0},400,function(){ $(this).css(&amp;apos;display&amp;apos;,&amp;apos;none&amp;apos;); }); break;
            };
            case 2:alert(&amp;apos;密码错误&amp;apos;);break;
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//下面来看，php脚本是如何接受数据，处理数据，返回数据的&lt;br&gt;    &amp;lt;?php&lt;br&gt;        $username=$_POST[‘username’];&lt;br&gt;        $password=$_POST[‘password’];//根据不同的方法，php会把接收的数据储存在$_POST/$_GET这样的全局变量中，前面的ajax我们用的是post方法，所以这里用$_POST接收数据&lt;br&gt;        $usermsg =array(&lt;br&gt;            ‘fhw7328126’ =&amp;gt; ‘7328126’,&lt;br&gt;            ‘fhwlmmz’ =&amp;gt; ‘feng7328126’,&lt;br&gt;            ‘dearmmz’ =&amp;gt; ‘123456’,&lt;br&gt;            ‘rooter’ =&amp;gt; ‘dd’,&lt;br&gt;        );&lt;br&gt;        $gouwuche=array(&lt;br&gt;            ‘fhw7328126’ =&amp;gt; 2,&lt;br&gt;            ‘fhwlovemmz’ =&amp;gt; 3,&lt;br&gt;            ‘dearmmz’ =&amp;gt; 8,&lt;br&gt;            ‘rooter’ =&amp;gt; 123,&lt;br&gt;        );&lt;br&gt;        $name=array(&lt;br&gt;            ‘fhw7328126’ =&amp;gt; ‘鱼鱼风’,&lt;br&gt;            ‘fhwmmz’ =&amp;gt; ‘黄翔’,&lt;br&gt;            ‘dearmmz’ =&amp;gt; ‘明珠’,&lt;br&gt;            ‘rooter’ =&amp;gt; ‘管理员’,&lt;br&gt;        );//这里我定义了3个数组，分别储存有用户的帐号密码购物车信息和昵称，事实上，一般这样的数据都是储存在数据库中，PHP可以与数据库交互，获得这些数据表。由于我还没有掌握如何使用数据库，这里就直接用偷懒的方法定义好数据表；&lt;br&gt;        $type=0;//定义一个变量，用来代表php处理数据的不同结果，默认0&lt;br&gt;        $gouwuchenum=0;//定义一个变量，用来装用户购物车数量信息，默认0&lt;br&gt;        $name2=0;//定义一个变量，用来装用户的昵称，默认0&lt;br&gt;        foreach($usermsg as $key =&amp;gt; $value){//遍历数组&lt;br&gt;            if($username==$key and $password==$value){//如果帐号存在，且密码匹配&lt;br&gt;                $type=1;//状态字赋值为1；&lt;br&gt;                $gouwuchenum=$gouwuche[$key];//获取当前用户的购物车信息；&lt;br&gt;                $name2=$name[$key];//获取当前用户的昵称&lt;br&gt;                break;//跳出遍历&lt;br&gt;            }&lt;br&gt;            else if($username==$key and $password!=$value){//如果帐号存在但密码不匹配&lt;br&gt;                $type=2;//状态字赋值为2；&lt;br&gt;                break;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;        $response=array(//定义php要返回的数据，这里先定义成数组类型&lt;br&gt;            ‘type’ =&amp;gt; $type,//返回状态字&lt;br&gt;            ‘gouwuchenum’ =&amp;gt;$gouwuchenum,//返回购物车信息&lt;br&gt;            ‘name’ =&amp;gt; $name2,//返回昵称&lt;br&gt;        );&lt;br&gt;        echo json_encode($response);//将要返回的数组转化成json数据，打印出来。注意，PHP打印出什么，那么前端接收的数据就是什么。通篇浏览这个php文件，只有最后一行打印了一个json数据，所以前端得到的数据就是这个json。&lt;br&gt;    ?&amp;gt;&lt;/p&gt;
&lt;p&gt;这个php脚本，让大家知道了，后端如何接收数据，处理数据，以及返回数据。&lt;/p&gt;
&lt;p&gt;//success函数，表示前端收到数据成功后，要做什么&lt;br&gt;    ‘success’:function(data){//这里的data储存有后端php返回的json数据&lt;br&gt;            switch(data.type){//以data.type为switch-case关键字，分类处理&lt;br&gt;                case 0:alert(‘账户不存在’);break;//如果type=0，说明帐号密码都不匹配&lt;br&gt;                case 1:{//type=1，说明匹配成功，登录成功&lt;br&gt;                    $(‘#userMsg’).children(‘li’).eq(2).find(‘span’).html(‘ ‘+data.gouwuchenum+’ ‘);//更新购物车数量&lt;br&gt;                    $(‘#loginMsg li’).eq(1).empty().html(‘&lt;span&gt;‘+data.name+’&lt;/span&gt;‘);//登录按钮更换为用户昵称；&lt;br&gt;                    $(‘#loginMsg li’).eq(2).empty().html(‘&lt;a href=&quot;javascript:tuichu()&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;退出&lt;/a&gt;‘);//注册按钮更换为退出按钮；&lt;br&gt;                    $(‘.login’).animate({right:-180,opacity:0},400,function(){//登录框隐藏&lt;br&gt;                        $(this).css(‘display’,’none’);&lt;br&gt;                    });&lt;br&gt;                    break;&lt;br&gt;                }&lt;br&gt;                case 2:alert(‘密码错误’);break;//type=2，表示用户存在但是密码不匹配&lt;br&gt;            }&lt;br&gt;        }&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;http://www.imooc.com/article/10371&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.imooc.com/article/10371&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直都是写的前端，没关心过后端是怎么处理的，看个小案例，了解下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ajax" scheme="http://blog.newbug.xyz/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>js通过Ajax异步操作后端xml数据的基本原理</title>
    <link href="http://blog.newbug.xyz/2016/05/30/js%E9%80%9A%E8%BF%87Ajax%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%90%8E%E7%AB%AFxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.newbug.xyz/2016/05/30/js通过Ajax异步操作后端xml数据的基本原理/</id>
    <published>2016-05-30T04:20:31.000Z</published>
    <updated>2016-10-16T02:29:52.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;Ajax的核心操作对象是xmlHttpRequest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　  简化操作步骤：实例化一个xmlHttpRequest对象 ==&amp;gt; 发送请求 ==&amp;gt; 接受响应 ==&amp;gt; 执行回调&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;实例化对象&lt;/p&gt;
&lt;p&gt;　　考虑到兼容问题,非IE5/IE6 使用 =&amp;gt; new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;　　IE5/IE6使用 =&amp;gt; new ActiveXObject(Microsoft.XMLHTTP);    ☯神呐，请带走IE吧！&lt;/p&gt;
&lt;p&gt;发送请求&lt;/p&gt;
&lt;p&gt;　　使用 XMLHttpRequest 对象的 open(‘GET’,url,async) 和 send() 方法：&lt;/p&gt;
&lt;p&gt;　　❶ open() 有三个参数：&lt;/p&gt;
&lt;p&gt;　　　　分别为http请求方式(get/post) ==》与 POST 相比，GET 更简单也更快，POST 没有数据量限制，不会缓存，相对安全&lt;/p&gt;
&lt;p&gt;　　　　http请求地址 ==》url(统一资源定位符)文件所在服务器的地址&lt;/p&gt;
&lt;p&gt;　　　　async：true（异步）或 false（同步）&lt;/p&gt;
&lt;p&gt;　　❷send(string)   string：仅用于 POST 请求&lt;/p&gt;
&lt;p&gt;接受响应，执行回调&lt;/p&gt;
&lt;p&gt;　　当readyState的值发生改变时，触发readystatechange事件，事件中就可以为所欲为了&lt;/p&gt;
&lt;p&gt;　　readyState==4  =&amp;gt;请求加载完成  /    http的状态为200 =&amp;gt;响应成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;异步操作集合啦&amp;lt;/title&amp;gt;
        &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
            /*
             * Ajax的核心操作对象是xmlHttpRequest
             *    简化操作步骤：实例化一个xmlHttpRequest对象  ==&amp;gt; 发送请求  ==&amp;gt; 接受响应 ==&amp;gt; 执行回调
             */
            var jsAjax = function() {
                var xmlHttpR = null;
                if(window.ActiveXObject) {
                    //IE5/IE6把xmlHttpRequest封装在window的子对象ActiveXObject中
                    xmlHttpR = new ActiveXObject(Microsoft.XMLHTTP);
                } else if(window.XMLHttpRequest) {
                    //非IE5、IE6
                    xmlHttpR = new XMLHttpRequest();
                }

                if(xmlHttpR) {
                    xmlHttpR.open(&amp;quot;GET&amp;quot;, &amp;quot;ajax.xml&amp;quot;, true);
                    xmlHttpR.onreadystatechange = function(e) {
                        if(xmlHttpR.readyState == 4) {
                            if(xmlHttpR.status == 200) {
                                console.log(xmlHttpR.responseText);
                            }
                        }
                    }
                    xmlHttpR.send(null);
                }
            }
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

01
    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
02
    &amp;lt;bookstore&amp;gt;
03
    &amp;lt;book category=&amp;quot;COOKING&amp;quot;&amp;gt;
04
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Everyday Italian&amp;lt;/title&amp;gt;
05
        &amp;lt;author&amp;gt;Giada De Laurentiis&amp;lt;/author&amp;gt;
06
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
07
        &amp;lt;price&amp;gt;30.00&amp;lt;/price&amp;gt;
08
    &amp;lt;/book&amp;gt;
09
    &amp;lt;book category=&amp;quot;CHILDREN&amp;quot;&amp;gt;
10
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Harry Potter&amp;lt;/title&amp;gt;
11
        &amp;lt;author&amp;gt;J K. Rowling&amp;lt;/author&amp;gt;
12
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
13
        &amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;
14
    &amp;lt;/book&amp;gt;
15
    &amp;lt;book category=&amp;quot;WEB&amp;quot;&amp;gt;
16
        &amp;lt;title lang=&amp;quot;en&amp;quot;&amp;gt;Learning XML&amp;lt;/title&amp;gt;
17
        &amp;lt;author&amp;gt;Erik T. Ray&amp;lt;/author&amp;gt;
18
        &amp;lt;year&amp;gt;2003&amp;lt;/year&amp;gt;
19
        &amp;lt;price&amp;gt;39.95&amp;lt;/price&amp;gt;
20
    &amp;lt;/book&amp;gt;
21
    &amp;lt;/bookstore&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;js中几种实用的跨域方法原理详解&quot;&gt;&lt;a href=&quot;#js中几种实用的跨域方法原理详解&quot; class=&quot;headerlink&quot; title=&quot;js中几种实用的跨域方法原理详解&quot;&gt;&lt;/a&gt;js中几种实用的跨域方法原理详解&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/2050/p/3191744.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考博客&lt;/a&gt;  &lt;/p&gt;
&lt;h3 id=&quot;ajax的简单发送&quot;&gt;&lt;a href=&quot;#ajax的简单发送&quot; class=&quot;headerlink&quot; title=&quot;ajax的简单发送&quot;&gt;&lt;/a&gt;ajax的简单发送&lt;/h3&gt;&lt;p&gt;前段代码  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script&amp;gt;
document.getElementById(&amp;quot;search&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;GET&amp;quot;, &amp;quot;server.php?number=&amp;quot; + document.getElementById(&amp;quot;keyword&amp;quot;).value);
    request.send();
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = request.responseText;
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}

document.getElementById(&amp;quot;save&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;POST&amp;quot;, &amp;quot;server.php&amp;quot;);
    var data = &amp;quot;name=&amp;quot; + document.getElementById(&amp;quot;staffName&amp;quot;).value 
                      + &amp;quot;&amp;amp;number=&amp;quot; + document.getElementById(&amp;quot;staffNumber&amp;quot;).value 
                      + &amp;quot;&amp;amp;sex=&amp;quot; + document.getElementById(&amp;quot;staffSex&amp;quot;).value 
                      + &amp;quot;&amp;amp;job=&amp;quot; + document.getElementById(&amp;quot;staffJob&amp;quot;).value;
    request.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);
    request.send(data);
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = request.responseText;
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后台php代码：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;quot;参数错误&amp;quot;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;quot;没有找到员工。&amp;quot;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;quot;找到员工：员工编号：&amp;quot; . $value[&amp;quot;number&amp;quot;] . &amp;quot;，员工姓名：&amp;quot; . $value[&amp;quot;name&amp;quot;] . 
                              &amp;quot;，员工性别：&amp;quot; . $value[&amp;quot;sex&amp;quot;] . &amp;quot;，员工职位：&amp;quot; . $value[&amp;quot;job&amp;quot;];
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;quot;参数错误，员工信息填写不全&amp;quot;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;quot;员工：&amp;quot; . $_POST[&amp;quot;name&amp;quot;] . &amp;quot; 信息保存成功！&amp;quot;;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ajaxjson数据格式&quot;&gt;&lt;a href=&quot;#ajaxjson数据格式&quot; class=&quot;headerlink&quot; title=&quot;ajaxjson数据格式&quot;&gt;&lt;/a&gt;ajaxjson数据格式&lt;/h3&gt;&lt;p&gt;HTML：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script&amp;gt;
document.getElementById(&amp;quot;search&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;GET&amp;quot;, &amp;quot;serverjson.php?number=&amp;quot; + document.getElementById(&amp;quot;keyword&amp;quot;).value);
    request.send();
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                var data = JSON.parse(request.responseText);
                if (data.success) { 
                    document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = data.msg;
                } else {
                    document.getElementById(&amp;quot;searchResult&amp;quot;).innerHTML = &amp;quot;出现错误：&amp;quot; + data.msg;
                }
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}

document.getElementById(&amp;quot;save&amp;quot;).onclick = function() { 
    var request = new XMLHttpRequest();
    request.open(&amp;quot;POST&amp;quot;, &amp;quot;serverjson.php&amp;quot;);
    var data = &amp;quot;name=&amp;quot; + document.getElementById(&amp;quot;staffName&amp;quot;).value 
                      + &amp;quot;&amp;amp;number=&amp;quot; + document.getElementById(&amp;quot;staffNumber&amp;quot;).value 
                      + &amp;quot;&amp;amp;sex=&amp;quot; + document.getElementById(&amp;quot;staffSex&amp;quot;).value 
                      + &amp;quot;&amp;amp;job=&amp;quot; + document.getElementById(&amp;quot;staffJob&amp;quot;).value;
    request.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);
    request.send(data);
    request.onreadystatechange = function() {
        if (request.readyState===4) {
            if (request.status===200) { 
                var data = JSON.parse(request.responseText);
                if (data.success) { 
                    document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = data.msg;
                } else {
                    document.getElementById(&amp;quot;createResult&amp;quot;).innerHTML = &amp;quot;出现错误：&amp;quot; + data.msg;
                }
            } else {
                alert(&amp;quot;发生错误：&amp;quot; + request.status);
            }
        } 
    }
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ajaxjson php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;}&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;}&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] . 
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;}&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jqueryajax&quot;&gt;&lt;a href=&quot;#jqueryajax&quot; class=&quot;headerlink&quot; title=&quot;jqueryajax&quot;&gt;&lt;/a&gt;jqueryajax&lt;/h3&gt;&lt;p&gt;HTML：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script src=&amp;quot;jquery-3.1.1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function(){ 
    $(&amp;quot;#search&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;GET&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:80/ajax/serverjQueryjson.php?number=&amp;quot; + $(&amp;quot;#keyword&amp;quot;).val(),
            dataType: &amp;quot;json&amp;quot;,
            success: function(data) {
                if (data.success) { 
                    $(&amp;quot;#searchResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#searchResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });

    $(&amp;quot;#save&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;POST&amp;quot;,     
            url: &amp;quot;serverjson.php&amp;quot;,
            data: {
                name: $(&amp;quot;#staffName&amp;quot;).val(), 
                number: $(&amp;quot;#staffNumber&amp;quot;).val(), 
                sex: $(&amp;quot;#staffSex&amp;quot;).val(), 
                job: $(&amp;quot;#staffJob&amp;quot;).val()
            },
            dataType: &amp;quot;json&amp;quot;,
            success: function(data){
                if (data.success) { 
                    $(&amp;quot;#createResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#createResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jquery 后台 php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
//header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
header(&amp;apos;Access-Control-Allow-Origin:*&amp;apos;);
header(&amp;apos;Access-Control-Allow-Methods:POST,GET&amp;apos;);
header(&amp;apos;Access-Control-Allow-Credentials:true&amp;apos;); 
header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;}&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;}&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] . 
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;}&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jQueryjsonp：&quot;&gt;&lt;a href=&quot;#jQueryjsonp：&quot; class=&quot;headerlink&quot; title=&quot;jQueryjsonp：&quot;&gt;&lt;/a&gt;jQueryjsonp：&lt;/h3&gt;&lt;p&gt;HTML：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
    font-size: 28px;
    line-height:1.7;
}
&amp;lt;/style&amp;gt;    
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;keyword&amp;quot; /&amp;gt;
&amp;lt;button id=&amp;quot;search&amp;quot;&amp;gt;查询&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;searchResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffName&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffNumber&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
&amp;lt;select id=&amp;quot;staffSex&amp;quot;&amp;gt;
&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;staffJob&amp;quot; /&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;button id=&amp;quot;save&amp;quot;&amp;gt;保存&amp;lt;/button&amp;gt;
&amp;lt;p id=&amp;quot;createResult&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script src=&amp;quot;jquery-3.1.1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function(){ 
    $(&amp;quot;#search&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;GET&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:80/ajax/serverjQueryjsonp.php?number=&amp;quot; + $(&amp;quot;#keyword&amp;quot;).val(),
            dataType: &amp;quot;jsonp&amp;quot;,
            jsonp: &amp;quot;callback&amp;quot;,
            success: function(data) {
                if (data.success) {
                    $(&amp;quot;#searchResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#searchResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });

    $(&amp;quot;#save&amp;quot;).click(function(){ 
        $.ajax({ 
            type: &amp;quot;POST&amp;quot;,     
            url: &amp;quot;http://127.0.0.1:8000/ajaxdemo/serverjsonp.php&amp;quot;,
            data: {
                name: $(&amp;quot;#staffName&amp;quot;).val(), 
                number: $(&amp;quot;#staffNumber&amp;quot;).val(), 
                sex: $(&amp;quot;#staffSex&amp;quot;).val(), 
                job: $(&amp;quot;#staffJob&amp;quot;).val()
            },
            dataType: &amp;quot;json&amp;quot;,
            success: function(data){
                if (data.success) { 
                    $(&amp;quot;#createResult&amp;quot;).html(data.msg);
                } else {
                    $(&amp;quot;#createResult&amp;quot;).html(&amp;quot;出现错误：&amp;quot; + data.msg);
                }  
            },
            error: function(jqXHR){     
               alert(&amp;quot;发生错误：&amp;quot; + jqXHR.status);  
            },     
        });
    });
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jqueryjsonp php：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
//header(&amp;quot;Content-Type: text/plain;charset=utf-8&amp;quot;); 
header(&amp;quot;Content-Type: application/json;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/xml;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: text/html;charset=utf-8&amp;quot;); 
//header(&amp;quot;Content-Type: application/javascript;charset=utf-8&amp;quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组
$staff = array
    (
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;洪七&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;101&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;总经理&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;郭靖&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;102&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;男&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;开发工程师&amp;quot;),
        array(&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;黄蓉&amp;quot;, &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;103&amp;quot;, &amp;quot;sex&amp;quot; =&amp;gt; &amp;quot;女&amp;quot;, &amp;quot;job&amp;quot; =&amp;gt; &amp;quot;产品经理&amp;quot;)
    );

//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;]返回访问页面使用的请求方法
if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;GET&amp;quot;) {
    search();
} elseif ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;){
    create();
}

//通过员工编号搜索员工
function search(){
    $jsonp = $_GET[&amp;quot;callback&amp;quot;];
    //检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据
    if (!isset($_GET[&amp;quot;number&amp;quot;]) || empty($_GET[&amp;quot;number&amp;quot;])) {
        echo $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误&amp;quot;})&amp;apos;;
        return;
    }
    //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量
    global $staff;
    //获取number参数
    $number = $_GET[&amp;quot;number&amp;quot;];
    $result = $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;没有找到员工。&amp;quot;})&amp;apos;;

    //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
    foreach ($staff as $value) {
        if ($value[&amp;quot;number&amp;quot;] == $number) {
            $result = $jsonp . &amp;apos;({&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;找到员工：员工编号：&amp;apos; . $value[&amp;quot;number&amp;quot;] .
                            &amp;apos;，员工姓名：&amp;apos; . $value[&amp;quot;name&amp;quot;] . 
                            &amp;apos;，员工性别：&amp;apos; . $value[&amp;quot;sex&amp;quot;] . 
                            &amp;apos;，员工职位：&amp;apos; . $value[&amp;quot;job&amp;quot;] . &amp;apos;&amp;quot;})&amp;apos;;
            break;
        }
    }
    echo $result;
}

//创建员工
function create(){
    //判断信息是否填写完全
    if (!isset($_POST[&amp;quot;name&amp;quot;]) || empty($_POST[&amp;quot;name&amp;quot;])
        || !isset($_POST[&amp;quot;number&amp;quot;]) || empty($_POST[&amp;quot;number&amp;quot;])
        || !isset($_POST[&amp;quot;sex&amp;quot;]) || empty($_POST[&amp;quot;sex&amp;quot;])
        || !isset($_POST[&amp;quot;job&amp;quot;]) || empty($_POST[&amp;quot;job&amp;quot;])) {
        echo &amp;apos;{&amp;quot;success&amp;quot;:false,&amp;quot;msg&amp;quot;:&amp;quot;参数错误，员工信息填写不全&amp;quot;}&amp;apos;;
        return;
    }
    //TODO: 获取POST表单数据并保存到数据库

    //提示保存成功
    echo &amp;apos;{&amp;quot;success&amp;quot;:true,&amp;quot;msg&amp;quot;:&amp;quot;员工：&amp;apos; . $_POST[&amp;quot;name&amp;quot;] . &amp;apos; 信息保存成功！&amp;quot;}&amp;apos;;
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Ajax的核心操作对象是xmlHttpRequest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　  简化操作步骤：实例化一个xmlHttpRequest对象 ==&amp;gt; 发送请求 ==&amp;gt; 接受响应 ==&amp;gt; 执行回调&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://blog.newbug.xyz/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://blog.newbug.xyz/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>js轮播图透明度切换</title>
    <link href="http://blog.newbug.xyz/2016/04/25/js%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%80%8F%E6%98%8E%E5%BA%A6%E5%88%87%E6%8D%A2/"/>
    <id>http://blog.newbug.xyz/2016/04/25/js轮播图透明度切换/</id>
    <published>2016-04-25T02:22:16.000Z</published>
    <updated>2017-04-25T02:32:42.789Z</updated>
    
    <content type="html">&lt;p&gt;js轮播图透明度切换（带上下页和底部圆点切换）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;js轮播图透明度切换&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        * {
            margin: 0;
            padding: 0;
            border: none;
        }
        li {
            list-style: none;
        }
        #box {
            height: 340px;
            width: 790px;
            position: relative;
            margin: 100px auto;
        }
        #box #list1 {
            height: 340px;
            width: 790px;
        }
        #box #list1 li {
            position: absolute;
            font-size: 80px;
            text-align: center;
            height: 340px;
            width: 790px;
            left: 0;
            top: 0;
            opacity: 0;
            filter: alpha(opacity=0);
        }
        #box #list1 li img {
            height: 340px;
            width: 790px;
        }
        #shang,#xia {
            height: 80px;
            width: 50px;
            color: #212121;
            background: #ccc;
            font-size: 60px;
            font-weight: bold;
            line-height: 80px;
            text-align: center;
            position: absolute;
            top: 130px;
            opacity: 0.8;
            filter: alpha(opacity=80);
            cursor: pointer;
        }
        #shang {
            left: 0;
        }
        #xia {
            right: 0;
        }
        #box #list2 {
            height: 20px;
            width: 195px;
            position: absolute;
            left: 297px;
            bottom: 25px;
            opacity: 0.8;
            filter: alpha(opacity=80);
        }
        #box #list2 li {
            height: 20px;
            width: 20px;
            background: #ccc;
            border-radius: 50%;
            float: left;
            margin-right: 5px;
            cursor: pointer;
        }
        #box #list2 li.active {
            background: black;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul id=&amp;quot;list1&amp;quot;&amp;gt;
            &amp;lt;li style=&amp;quot;background: red;&amp;quot;&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: yellow;&amp;quot;&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: green;&amp;quot;&amp;gt;3&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: blue;&amp;quot;&amp;gt;4&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: blueviolet;&amp;quot;&amp;gt;5&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: brown;&amp;quot;&amp;gt;6&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: orangered;&amp;quot;&amp;gt;7&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;background: palevioletred;&amp;quot;&amp;gt;8&amp;lt;/li&amp;gt;               
        &amp;lt;/ul&amp;gt;
        &amp;lt;ul id=&amp;quot;list2&amp;quot;&amp;gt;
            &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li style=&amp;quot;margin-right:0px;&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;div id=&amp;quot;shang&amp;quot;&amp;gt;
            &amp;amp;lt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div id=&amp;quot;xia&amp;quot;&amp;gt;
            &amp;amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        onload = function(){
            var oBox = document.getElementById(&amp;apos;box&amp;apos;);
            var oList1 = document.getElementById(&amp;apos;list1&amp;apos;);
            var aLi1 = oList1.getElementsByTagName(&amp;apos;li&amp;apos;);
            var oList2 = document.getElementById(&amp;apos;list2&amp;apos;);
            var aLi2 = oList2.getElementsByTagName(&amp;apos;li&amp;apos;);
            var oShang = document.getElementById(&amp;apos;shang&amp;apos;);
            var oXia = document.getElementById(&amp;apos;xia&amp;apos;);
            aLi1[0].style.opacity = 1;
            aLi1[0].style.filter = &amp;apos;alpha(opacity=100)&amp;apos;;
            var size = aLi1.length;
            var i = 0;
            var timer = setInterval(function(){
                i++;
                move();
            },2000);
            function move(){
                if (i &amp;gt;= size ) {
                    i = 0;
                }
                if (i &amp;lt; 0 ) {
                    i = size - 1;
                }
                for (var j = 0; j &amp;lt; aLi1.length; j++) {
                    if (j == i) {
                        animate(aLi1[j],{opacity:100});
                        aLi2[j].className = &amp;apos;active&amp;apos;;
                    }else{
                        animate(aLi1[j],{opacity:0});
                        aLi2[j].className = &amp;apos;&amp;apos;;
                    }
                }
            }
            //前一张
            oShang.onclick = function(e){
                var evt = e || event;
                evt.preventDefault();
                i--;
                move();
            }
            //后一张
            oXia.onclick = function(e){
                var evt = e || event;
                evt.preventDefault();
                i ++;
                move();
            }
            //下面的圆点
            for(var k = 0;k &amp;lt; aLi2.length; k ++){
                aLi2[k].index = k;
                aLi2[k].onmouseenter = function(){
                    i = this.index;
                    move();
                }
            }
            oBox.onmouseenter = function(){
                clearInterval(timer);
            }
            oBox.onmouseleave = function(){
                timer = setInterval(function(){
                    i ++;
                    move();
                },2000);
            }








/*************************缓冲运动可封装留着以后备用^_^*************************/
            function getStyleAttr(obj, attr){
                if (window.getComputedStyle){
                    return getComputedStyle(obj, null)[attr]; 
                }
                else {
                    return obj.currentStyle[attr];  
                }
            }
            function animate(obj, json, fn){
                clearInterval(obj.timer); 
                obj.timer = setInterval(function(){
                    var bStop = true; 
                    for (var attr in json){
                        var iTarget = json[attr]; 
                        var current;
                        if (attr == &amp;quot;opacity&amp;quot;){ 
                            current = parseFloat(getStyleAttr(obj, attr))*100;
                            current = Math.round(current);
                        }
                        else { 
                            current = parseFloat(getStyleAttr(obj, attr));
                            current = Math.round(current);
                        }
                        var speed = (iTarget-current)/8;    (400-393)/8
                        speed = speed&amp;gt;0 ? Math.ceil(speed) : Math.floor(speed);
                        if (current != iTarget){
                            bStop = false; 
                        }
                        if (attr == &amp;quot;opacity&amp;quot;){ 
                            obj.style[attr] = (current+speed)/100;
                            obj.style.filter = &amp;quot;alpha(opacity=&amp;quot; + (current+speed) + &amp;quot;)&amp;quot;;
                        }
                        else { 
                            obj.style[attr] = current+speed + &amp;quot;px&amp;quot;;
                        }
                    }
                    if (bStop){
                        console.log(&amp;quot;停止运动&amp;quot;);
                        clearInterval(obj.timer); 
                        if (fn) {
                            fn(); 
                        }
                    }
                }, 30);
            }
        }

    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;js轮播图透明度切换（带上下页和底部圆点切换）&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://blog.newbug.xyz/tags/js/"/>
    
  </entry>
  
</feed>
